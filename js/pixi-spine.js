/*!
 * pixi-spine - v4.0.4
 * Compiled Wed, 23 Oct 2024 12:49:53 UTC
 *
 * pixi-spine is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2024, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.spine=function(Rt,G,Lt,Ye,Gr,zr,Hr){"use strict";var Xp=Object.defineProperty,Bp=(u,t,e)=>t in u?Xp(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,en=(u,t,e)=>Bp(u,typeof t!="symbol"?t+"":t,e);const jn=class Ug{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new Ug().setFromString(t)}};en(jn,"WHITE",new jn(1,1,1,1)),en(jn,"RED",new jn(1,0,0,1)),en(jn,"GREEN",new jn(0,1,0,1)),en(jn,"BLUE",new jn(0,0,1,1)),en(jn,"MAGENTA",new jn(1,0,1,1));const Ns=class Vo{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*Vo.degRad)}static sinDeg(t){return Math.sin(t*Vo.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*Vo.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return Vo.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};en(Ns,"PI",3.1415927),en(Ns,"PI2",Ns.PI*2),en(Ns,"invPI2",1/Ns.PI2),en(Ns,"radiansToDegrees",180/Ns.PI),en(Ns,"radDeg",Ns.radiansToDegrees),en(Ns,"degreesToRadians",Ns.PI/180),en(Ns,"degRad",Ns.degreesToRadians);let Vp=Ns;en(class Xa{static arrayCopy(t,e,s,n,r){for(let c=e,h=n;c<e+r;c++,h++)s[h]=t[c]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:Xa.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(Xa.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(Xa.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return Xa.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return Xa.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}},"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");var Np=Object.defineProperty,Dp=(u,t,e)=>t in u?Np(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ga=(u,t,e)=>Dp(u,typeof t!="symbol"?t+"":t,e);function Dd(u){switch(u.toLowerCase()){case"nearest":return 9728;case"linear":return 9729;case"mipmap":return 9987;case"mipmapnearestnearest":return 9984;case"mipmaplinearnearest":return 9985;case"mipmapnearestlinear":return 9986;case"mipmaplinearlinear":return 9987;default:throw new Error(`Unknown texture filter ${u}`)}}var Fi=(u=>(u[u.Nearest=9728]="Nearest",u[u.Linear=9729]="Linear",u[u.MipMap=9987]="MipMap",u[u.MipMapNearestNearest=9984]="MipMapNearestNearest",u[u.MipMapLinearNearest=9985]="MipMapLinearNearest",u[u.MipMapNearestLinear=9986]="MipMapNearestLinear",u[u.MipMapLinearLinear=9987]="MipMapLinearLinear",u))(Fi||{}),Yi=(u=>(u[u.MirroredRepeat=33648]="MirroredRepeat",u[u.ClampToEdge=33071]="ClampToEdge",u[u.Repeat=10497]="Repeat",u))(Yi||{});let _l=class{constructor(){Ga(this,"texture"),Ga(this,"size",null),Ga(this,"names",null),Ga(this,"values",null),Ga(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}};var Lp=Object.defineProperty,Op=(u,t,e)=>t in u?Lp(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,se=(u,t,e)=>Op(u,typeof t!="symbol"?t+"":t,e);let Wp=class{constructor(){se(this,"x",0),se(this,"y",0),se(this,"width",0),se(this,"height",0),se(this,"offsetX",0),se(this,"offsetY",0),se(this,"originalWidth",0),se(this,"originalHeight",0),se(this,"rotate",0),se(this,"index",0)}},Xl=class{constructor(t,e,s){se(this,"pages",new Array),se(this,"regions",new Array),t&&this.addSpineAtlas(t,e,s)}addTexture(t,e){const s=this.pages;let n=null;for(let c=0;c<s.length;c++)if(s[c].baseTexture===e.baseTexture){n=s[c];break}if(n===null){n=new Ld,n.name="texturePage";const c=e.baseTexture;n.width=c.realWidth,n.height=c.realHeight,n.baseTexture=c,n.minFilter=n.magFilter=Fi.Nearest,n.uWrap=Yi.ClampToEdge,n.vWrap=Yi.ClampToEdge,s.push(n)}const r=new Od;return r.name=t,r.page=n,r.texture=e,r.index=-1,this.regions.push(r),r}addTextureHash(t,e){for(const s in t)t.hasOwnProperty(s)&&this.addTexture(e&&s.indexOf(".")!==-1?s.substr(0,s.lastIndexOf(".")):s,t[s])}addSpineAtlas(t,e,s){return this.load(t,e,s)}load(t,e,s){if(e==null)throw new Error("textureLoader cannot be null.");const n=new Up(t),r=new Array(4);let c=null;const h={};let i=null;h.size=()=>{c.width=parseInt(r[1]),c.height=parseInt(r[2])},h.format=()=>{},h.filter=()=>{c.minFilter=Dd(r[1]),c.magFilter=Dd(r[2])},h.repeat=()=>{r[1].indexOf("x")!=-1&&(c.uWrap=Yi.Repeat),r[1].indexOf("y")!=-1&&(c.vWrap=Yi.Repeat)},h.pma=()=>{c.pma=r[1]=="true"};const a={};a.xy=()=>{i.x=parseInt(r[1]),i.y=parseInt(r[2])},a.size=()=>{i.width=parseInt(r[1]),i.height=parseInt(r[2])},a.bounds=()=>{i.x=parseInt(r[1]),i.y=parseInt(r[2]),i.width=parseInt(r[3]),i.height=parseInt(r[4])},a.offset=()=>{i.offsetX=parseInt(r[1]),i.offsetY=parseInt(r[2])},a.orig=()=>{i.originalWidth=parseInt(r[1]),i.originalHeight=parseInt(r[2])},a.offsets=()=>{i.offsetX=parseInt(r[1]),i.offsetY=parseInt(r[2]),i.originalWidth=parseInt(r[3]),i.originalHeight=parseInt(r[4])},a.rotate=()=>{const f=r[1];let m=0;f.toLocaleLowerCase()=="true"?m=6:f.toLocaleLowerCase()=="false"?m=0:m=(720-parseFloat(f))%360/45,i.rotate=m},a.index=()=>{i.index=parseInt(r[1])};let o=n.readLine();for(;o!=null&&o.trim().length==0;)o=n.readLine();for(;!(o==null||o.trim().length==0||n.readEntry(r,o)==0);)o=n.readLine();const d=()=>{for(;;){if(o==null)return s&&s(this);if(o.trim().length==0)c=null,o=n.readLine();else if(c===null){for(c=new Ld,c.name=o.trim();n.readEntry(r,o=n.readLine())!=0;){const f=h[r[0]];f&&f()}this.pages.push(c),e(c.name,f=>{if(f===null)return this.pages.splice(this.pages.indexOf(c),1),s&&s(null);c.baseTexture=f,c.pma&&(f.alphaMode=G.ALPHA_MODES.PMA),f.valid||f.setSize(c.width,c.height),c.setFilters(),(!c.width||!c.height)&&(c.width=f.realWidth,c.height=f.realHeight,(!c.width||!c.height)&&console.log(`ERROR spine atlas page ${c.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)),d()});break}else{i=new Wp;const f=new Od;f.name=o,f.page=c;let m=null,l=null;for(;;){const x=n.readEntry(r,o=n.readLine());if(x==0)break;const S=a[r[0]];if(S)S();else{m==null&&(m=[],l=[]),m.push(r[0]);const C=[];for(let A=0;A<x;A++)C.push(parseInt(r[A+1]));l.push(C)}}i.originalWidth==0&&i.originalHeight==0&&(i.originalWidth=i.width,i.originalHeight=i.height);const g=c.baseTexture.resolution;i.x/=g,i.y/=g,i.width/=g,i.height/=g,i.originalWidth/=g,i.originalHeight/=g,i.offsetX/=g,i.offsetY/=g;const p=i.rotate%4!==0,y=new G.Rectangle(i.x,i.y,p?i.height:i.width,p?i.width:i.height),w=new G.Rectangle(0,0,i.originalWidth,i.originalHeight),b=new G.Rectangle(i.offsetX,i.originalHeight-i.height-i.offsetY,i.width,i.height);f.texture=new G.Texture(f.page.baseTexture,y,w,b,i.rotate),f.index=i.index,f.texture.updateUvs(),this.regions.push(f)}}};d()}findRegion(t){for(let e=0;e<this.regions.length;e++)if(this.regions[e].name==t)return this.regions[e];return null}dispose(){for(let t=0;t<this.pages.length;t++)this.pages[t].baseTexture.dispose()}},Up=class{constructor(t){se(this,"lines"),se(this,"index",0),this.lines=t.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readEntry(t,e){if(e==null||(e=e.trim(),e.length==0))return 0;const s=e.indexOf(":");if(s==-1)return 0;t[0]=e.substr(0,s).trim();for(let n=1,r=s+1;;n++){const c=e.indexOf(",",r);if(c==-1)return t[n]=e.substr(r).trim(),n;if(t[n]=e.substr(r,c-r).trim(),r=c+1,n==4)return 4}}},Ld=class{constructor(){se(this,"name"),se(this,"minFilter",Fi.Nearest),se(this,"magFilter",Fi.Nearest),se(this,"uWrap",Yi.ClampToEdge),se(this,"vWrap",Yi.ClampToEdge),se(this,"baseTexture"),se(this,"width"),se(this,"height"),se(this,"pma")}setFilters(){const t=this.baseTexture,e=this.minFilter;e==Fi.Linear?t.scaleMode=G.SCALE_MODES.LINEAR:this.minFilter==Fi.Nearest?t.scaleMode=G.SCALE_MODES.NEAREST:(t.mipmap=G.MIPMAP_MODES.POW2,e==Fi.MipMapNearestNearest?t.scaleMode=G.SCALE_MODES.NEAREST:t.scaleMode=G.SCALE_MODES.LINEAR)}},Od=class extends _l{constructor(){super(...arguments),se(this,"page"),se(this,"name"),se(this,"index")}};var $i=(u=>(u[u.Region=0]="Region",u[u.BoundingBox=1]="BoundingBox",u[u.Mesh=2]="Mesh",u[u.LinkedMesh=3]="LinkedMesh",u[u.Path=4]="Path",u[u.Point=5]="Point",u[u.Clipping=6]="Clipping",u))($i||{}),Wd=(u=>(u[u.none=0]="none",u[u.reset=1]="reset",u[u.update=2]="update",u[u.pose=3]="pose",u))(Wd||{}),Ud=(u=>(u[u.UNKNOWN=0]="UNKNOWN",u[u.VER37=37]="VER37",u[u.VER38=38]="VER38",u[u.VER40=40]="VER40",u[u.VER41=41]="VER41",u[u.VER42=42]="VER42",u))(Ud||{});function qp(u){const t=u.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}const Gp={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var zp=Object.defineProperty,Hp=(u,t,e)=>t in u?zp(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Qe=(u,t,e)=>Hp(u,typeof t!="symbol"?t+"":t,e);const Kr=[0,0,0];let Kp=class extends zr.Sprite{constructor(){super(...arguments),Qe(this,"region",null),Qe(this,"attachment",null)}},Zp=class extends Gr.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),Qe(this,"region",null),Qe(this,"attachment",null)}};const qd=class qg extends Lt.Container{constructor(t){if(super(),Qe(this,"tintRgb"),Qe(this,"spineData"),Qe(this,"skeleton"),Qe(this,"stateData"),Qe(this,"state"),Qe(this,"slotContainers"),Qe(this,"tempClipContainers"),Qe(this,"localDelayLimit"),Qe(this,"_autoUpdate"),Qe(this,"_visible"),Qe(this,"_debug"),Qe(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),c=this.newContainer();if(this.slotContainers.push(c),this.addChild(c),this.tempClipContainers.push(null),!!r)if(r.type===$i.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,c.addChild(i)}else if(r.type===$i.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,c.addChild(h)}else r.type===$i.Clipping&&(this.createGraphics(n,r),c.addChild(n.clippingContainer),c.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?qg.prototype.autoUpdateTransform:Lt.Container.prototype.updateTransform)}get tint(){return G.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=G.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:Gp.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=qp(this.spineData.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===Ud.VER42&&Wd.update);const n=this.skeleton.slots,r=this.color;let c=null,h=null;r?(c=r.light,h=r.dark):c=this.tintRgb;for(let f=0,m=n.length;f<m;f++){const l=n[f],g=l.getAttachment(),p=this.slotContainers[f];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(l,g);let w=g.region;const b=g.color;switch(g!=null&&g.type){case $i.Region:if(p.transform.setFromMatrix(l.bone.matrix),w=g.region,l.currentMesh&&(l.currentMesh.visible=!1,l.currentMesh=null,l.currentMeshId=void 0,l.currentMeshName=void 0),!w){l.currentSprite&&(l.currentSprite.renderable=!1);break}if(!l.currentSpriteName||l.currentSpriteName!==g.name){const C=g.name;if(l.currentSprite&&(l.currentSprite.visible=!1),l.sprites=l.sprites||{},l.sprites[C]!==void 0)l.sprites[C].visible=!0;else{const A=this.createSprite(l,g,C);p.addChild(A)}l.currentSprite=l.sprites[C],l.currentSpriteName=C}l.currentSprite.renderable=!0,l.hackRegion||this.setSpriteRegion(g,l.currentSprite,w),l.currentSprite.color?y=l.currentSprite.color:(Kr[0]=c[0]*l.color.r*b.r,Kr[1]=c[1]*l.color.g*b.g,Kr[2]=c[2]*l.color.b*b.b,l.currentSprite.tint=G.utils.rgb2hex(Kr)),l.currentSprite.blendMode=l.blendMode;break;case $i.Mesh:if(l.currentSprite){l.currentSprite.visible=!1,l.currentSprite=null,l.currentSpriteName=void 0;const C=new G.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){l.currentMesh&&(l.currentMesh.renderable=!1);break}const S=g.id;if(l.currentMeshId===void 0||l.currentMeshId!==S){const C=S;if(l.currentMesh&&(l.currentMesh.visible=!1),l.meshes=l.meshes||{},l.meshes[C]!==void 0)l.meshes[C].visible=!0;else{const A=this.createMesh(l,g);p.addChild(A)}l.currentMesh=l.meshes[C],l.currentMeshName=g.name,l.currentMeshId=C}l.currentMesh.renderable=!0,g.computeWorldVerticesOld(l,l.currentMesh.vertices),l.currentMesh.color?y=l.currentMesh.color:(Kr[0]=c[0]*l.color.r*b.r,Kr[1]=c[1]*l.color.g*b.g,Kr[2]=c[2]*l.color.b*b.b,l.currentMesh.tint=G.utils.rgb2hex(Kr)),l.currentMesh.blendMode=l.blendMode,l.hackRegion||this.setMeshRegion(g,l.currentMesh,w);break;case $i.Clipping:l.currentGraphics||(this.createGraphics(l,g),p.addChild(l.clippingContainer),p.addChild(l.currentGraphics)),this.updateGraphics(l,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let x=l.color.r*b.r,S=l.color.g*b.g,C=l.color.b*b.b;y.setLight(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C)),l.darkColor?(x=l.darkColor.r,S=l.darkColor.g,C=l.darkColor.b):(x=0,S=0,C=0),y.setDark(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C))}p.alpha=l.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let f=0,m=i.length;f<m;f++){const l=n[i[f].data.index],g=this.slotContainers[i[f].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),l.currentGraphics&&l.getAttachment())o=l.clippingContainer,a=l.getAttachment(),o.children.length=0,this.children[f]=g,a.endSlot===l.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[f];p||(p=this.tempClipContainers[f]=this.newContainer(),p.visible=!1),this.children[f]=p,g.parent=null,o.addChild(g),a.endSlot==l.data&&(o.renderable=!0,o=null,a=null)}else this.children[f]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*Vp.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}Lt.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,c=this.newSprite(r);return c.anchor.set(.5),n&&this.setSpriteRegion(e,c,e.region),t.sprites=t.sprites||{},t.sprites[s]=c,c}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),G.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new G.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let c=r.region;return e?(c=new _l,c.texture=e,c.size=s,n.hackRegion=c,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,c):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,c),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),c=this.skeleton.getAttachmentByName(t,e);c.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=c.region;return s?(a=new _l,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Lt.Container}newSprite(t){return new Kp(t)}newGraphics(){return new Ye.Graphics}newMesh(t,e,s,n,r){return new Zp(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let c=0,h=this.skeleton.slots.length;c<h;c++){const i=this.skeleton.slots[c],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};Qe(qd,"clippingPolygon",[]),Object.defineProperty(qd.prototype,"visible",{get(){return this._visible},set(u){u!==this._visible&&(this._visible=u,u&&(this.lastTime=0))}});const Qp={extension:G.ExtensionType.Asset,loader:{extension:{type:G.ExtensionType.LoadParser,priority:Hr.LoaderParserPriority.Normal},test(u){return Hr.checkExtension(u,".atlas")},async load(u){return await(await G.settings.ADAPTER.fetch(u)).text()},testParse(u,t){const e=Hr.checkExtension(t.src,".atlas"),s=typeof u=="string";return Promise.resolve(e&&s)},async parse(u,t,e){const s=t.data;let n=G.utils.path.dirname(t.src);n&&n.lastIndexOf("/")!==n.length-1&&(n+="/");let r=null,c=null;const h=new Promise((o,d)=>{r=o,c=d});let i;const a=o=>{o||c(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),r(i)};if(s.image||s.images){const o=Object.assign(s.image?{default:s.image}:{},s.images);i=new Xl(u,(d,f)=>{const m=o[d]||o.default;m&&m.baseTexture?f(m.baseTexture):f(m)},a)}else i=new Xl(u,Gd(e,n,s.imageMetadata),a);return await h},unload(u){u.dispose()}}},Gd=(u,t,e)=>async(s,n)=>{const r=G.utils.path.normalize([...t.split(G.utils.path.sep),s].join(G.utils.path.sep)),c=await u.load({src:r,data:e});n(c.baseTexture)};G.extensions.add(Qp);let zd=class{constructor(t,e=new Array,s=0,n=new DataView(t.buffer)){this.strings=e,this.index=s,this.buffer=n}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),s=e&127;return e&128&&(e=this.readByte(),s|=(e&127)<<7,e&128&&(e=this.readByte(),s|=(e&127)<<14,e&128&&(e=this.readByte(),s|=(e&127)<<21,e&128&&(e=this.readByte(),s|=(e&127)<<28)))),t?s:s>>>1^-(s&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let s=0;s<t;){const n=this.readUnsignedByte();switch(n>>4){case 12:case 13:e+=String.fromCharCode((n&31)<<6|this.readByte()&63),s+=2;break;case 14:e+=String.fromCharCode((n&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),s+=3;break;default:e+=String.fromCharCode(n),s++}}return e}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}};var Jp=Object.defineProperty,jp=(u,t,e)=>t in u?Jp(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,sn=(u,t,e)=>jp(u,typeof t!="symbol"?t+"":t,e);const tr=class Gg{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new Gg().setFromString(t)}};sn(tr,"WHITE",new tr(1,1,1,1)),sn(tr,"RED",new tr(1,0,0,1)),sn(tr,"GREEN",new tr(0,1,0,1)),sn(tr,"BLUE",new tr(0,0,1,1)),sn(tr,"MAGENTA",new tr(1,0,1,1));const Ds=class No{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*No.degRad)}static sinDeg(t){return Math.sin(t*No.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*No.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return No.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};sn(Ds,"PI",3.1415927),sn(Ds,"PI2",Ds.PI*2),sn(Ds,"invPI2",1/Ds.PI2),sn(Ds,"radiansToDegrees",180/Ds.PI),sn(Ds,"radDeg",Ds.radiansToDegrees),sn(Ds,"degreesToRadians",Ds.PI/180),sn(Ds,"degRad",Ds.degreesToRadians);let t0=Ds;sn(class Ba{static arrayCopy(t,e,s,n,r){for(let c=e,h=n;c<e+r;c++,h++)s[h]=t[c]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:Ba.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(Ba.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(Ba.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return Ba.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return Ba.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}},"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");var Je=(u=>(u[u.UNKNOWN=0]="UNKNOWN",u[u.VER37=37]="VER37",u[u.VER38=38]="VER38",u[u.VER40=40]="VER40",u[u.VER41=41]="VER41",u[u.VER42=42]="VER42",u))(Je||{});function za(u){const t=u.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}var _i=(u=>(u[u.Region=0]="Region",u[u.BoundingBox=1]="BoundingBox",u[u.Mesh=2]="Mesh",u[u.LinkedMesh=3]="LinkedMesh",u[u.Path=4]="Path",u[u.Point=5]="Point",u[u.Clipping=6]="Clipping",u))(_i||{}),Bl=(u=>(u[u.none=0]="none",u[u.reset=1]="reset",u[u.update=2]="update",u[u.pose=3]="pose",u))(Bl||{}),e0=Object.defineProperty,s0=(u,t,e)=>t in u?e0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ha=(u,t,e)=>s0(u,typeof t!="symbol"?t+"":t,e);let Hd=class{constructor(){Ha(this,"texture"),Ha(this,"size",null),Ha(this,"names",null),Ha(this,"values",null),Ha(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}};const n0={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var r0=Object.defineProperty,i0=(u,t,e)=>t in u?r0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,je=(u,t,e)=>i0(u,typeof t!="symbol"?t+"":t,e);const Zr=[0,0,0];let a0=class extends zr.Sprite{constructor(){super(...arguments),je(this,"region",null),je(this,"attachment",null)}},o0=class extends Gr.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),je(this,"region",null),je(this,"attachment",null)}};const Kd=class zg extends Lt.Container{constructor(t){if(super(),je(this,"tintRgb"),je(this,"spineData"),je(this,"skeleton"),je(this,"stateData"),je(this,"state"),je(this,"slotContainers"),je(this,"tempClipContainers"),je(this,"localDelayLimit"),je(this,"_autoUpdate"),je(this,"_visible"),je(this,"_debug"),je(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),c=this.newContainer();if(this.slotContainers.push(c),this.addChild(c),this.tempClipContainers.push(null),!!r)if(r.type===_i.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,c.addChild(i)}else if(r.type===_i.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,c.addChild(h)}else r.type===_i.Clipping&&(this.createGraphics(n,r),c.addChild(n.clippingContainer),c.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?zg.prototype.autoUpdateTransform:Lt.Container.prototype.updateTransform)}get tint(){return G.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=G.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:n0.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=za(this.spineData.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===Je.VER42&&Bl.update);const n=this.skeleton.slots,r=this.color;let c=null,h=null;r?(c=r.light,h=r.dark):c=this.tintRgb;for(let f=0,m=n.length;f<m;f++){const l=n[f],g=l.getAttachment(),p=this.slotContainers[f];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(l,g);let w=g.region;const b=g.color;switch(g!=null&&g.type){case _i.Region:if(p.transform.setFromMatrix(l.bone.matrix),w=g.region,l.currentMesh&&(l.currentMesh.visible=!1,l.currentMesh=null,l.currentMeshId=void 0,l.currentMeshName=void 0),!w){l.currentSprite&&(l.currentSprite.renderable=!1);break}if(!l.currentSpriteName||l.currentSpriteName!==g.name){const C=g.name;if(l.currentSprite&&(l.currentSprite.visible=!1),l.sprites=l.sprites||{},l.sprites[C]!==void 0)l.sprites[C].visible=!0;else{const A=this.createSprite(l,g,C);p.addChild(A)}l.currentSprite=l.sprites[C],l.currentSpriteName=C}l.currentSprite.renderable=!0,l.hackRegion||this.setSpriteRegion(g,l.currentSprite,w),l.currentSprite.color?y=l.currentSprite.color:(Zr[0]=c[0]*l.color.r*b.r,Zr[1]=c[1]*l.color.g*b.g,Zr[2]=c[2]*l.color.b*b.b,l.currentSprite.tint=G.utils.rgb2hex(Zr)),l.currentSprite.blendMode=l.blendMode;break;case _i.Mesh:if(l.currentSprite){l.currentSprite.visible=!1,l.currentSprite=null,l.currentSpriteName=void 0;const C=new G.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){l.currentMesh&&(l.currentMesh.renderable=!1);break}const S=g.id;if(l.currentMeshId===void 0||l.currentMeshId!==S){const C=S;if(l.currentMesh&&(l.currentMesh.visible=!1),l.meshes=l.meshes||{},l.meshes[C]!==void 0)l.meshes[C].visible=!0;else{const A=this.createMesh(l,g);p.addChild(A)}l.currentMesh=l.meshes[C],l.currentMeshName=g.name,l.currentMeshId=C}l.currentMesh.renderable=!0,g.computeWorldVerticesOld(l,l.currentMesh.vertices),l.currentMesh.color?y=l.currentMesh.color:(Zr[0]=c[0]*l.color.r*b.r,Zr[1]=c[1]*l.color.g*b.g,Zr[2]=c[2]*l.color.b*b.b,l.currentMesh.tint=G.utils.rgb2hex(Zr)),l.currentMesh.blendMode=l.blendMode,l.hackRegion||this.setMeshRegion(g,l.currentMesh,w);break;case _i.Clipping:l.currentGraphics||(this.createGraphics(l,g),p.addChild(l.clippingContainer),p.addChild(l.currentGraphics)),this.updateGraphics(l,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let x=l.color.r*b.r,S=l.color.g*b.g,C=l.color.b*b.b;y.setLight(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C)),l.darkColor?(x=l.darkColor.r,S=l.darkColor.g,C=l.darkColor.b):(x=0,S=0,C=0),y.setDark(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C))}p.alpha=l.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let f=0,m=i.length;f<m;f++){const l=n[i[f].data.index],g=this.slotContainers[i[f].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),l.currentGraphics&&l.getAttachment())o=l.clippingContainer,a=l.getAttachment(),o.children.length=0,this.children[f]=g,a.endSlot===l.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[f];p||(p=this.tempClipContainers[f]=this.newContainer(),p.visible=!1),this.children[f]=p,g.parent=null,o.addChild(g),a.endSlot==l.data&&(o.renderable=!0,o=null,a=null)}else this.children[f]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*t0.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}Lt.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,c=this.newSprite(r);return c.anchor.set(.5),n&&this.setSpriteRegion(e,c,e.region),t.sprites=t.sprites||{},t.sprites[s]=c,c}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),G.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new G.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let c=r.region;return e?(c=new Hd,c.texture=e,c.size=s,n.hackRegion=c,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,c):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,c),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),c=this.skeleton.getAttachmentByName(t,e);c.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=c.region;return s?(a=new Hd,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Lt.Container}newSprite(t){return new a0(t)}newGraphics(){return new Ye.Graphics}newMesh(t,e,s,n,r){return new o0(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let c=0,h=this.skeleton.slots.length;c<h;c++){const i=this.skeleton.slots[c],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};je(Kd,"clippingPolygon",[]);let Zd=Kd;Object.defineProperty(Zd.prototype,"visible",{get(){return this._visible},set(u){u!==this._visible&&(this._visible=u,u&&(this.lastTime=0))}});function Qd(u){return u.hasOwnProperty("bones")}function l0(u){return u instanceof ArrayBuffer}class c0{constructor(){}installLoader(){console.log("installLoader");const t=this,e={extension:G.ExtensionType.Asset,loader:{extension:{type:G.ExtensionType.LoadParser,priority:Hr.LoaderParserPriority.Normal},test(s){return Hr.checkExtension(s,".skel")},async load(s){return await(await G.settings.ADAPTER.fetch(s)).arrayBuffer()},testParse(s,n){var i;const r=Hr.checkExtension(n.src,".json")&&Qd(s),c=Hr.checkExtension(n.src,".skel")&&l0(s),h=((i=n.data)==null?void 0:i.spineAtlas)===!1;return Promise.resolve(r&&!h||c)},async parse(s,n,r){var w;const c=G.utils.path.extname(n.src).toLowerCase(),h=G.utils.path.basename(n.src,c);let i=G.utils.path.dirname(n.src);i&&i.lastIndexOf("/")!==i.length-1&&(i+="/");const a=Hr.checkExtension(n.src,".json")&&Qd(s);let o=null,d=s;a?o=t.createJsonParser():(o=t.createBinaryParser(),d=new Uint8Array(s));const f=n.data||{},m=(w=f==null?void 0:f.spineSkeletonScale)!=null?w:null;m&&(o.scale=m);const l=f.spineAtlas;if(l&&l.pages)return t.parseData(o,l,d);const g=f.atlasRawData;if(g){let b=null,x=null;const S=new Promise((v,M)=>{b=v,x=M}),C=new Xl(g,Gd(r,i,f.imageMetadata),v=>{v||x(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),b(C)}),A=await S;return t.parseData(o,A,d)}let p=f.spineAtlasFile;p||(p=`${i+h}.atlas`);const y=await r.load({src:p,data:f,alias:f.spineAtlasAlias});return t.parseData(o,y,d)}}};return G.extensions.add(e),e}}var h0=Object.defineProperty,d0=(u,t,e)=>t in u?h0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Xi=(u,t,e)=>d0(u,typeof t!="symbol"?t+"":t,e);let Vl=class{constructor(t){if(Xi(this,"name"),Xi(this,"type"),t==null)throw new Error("name cannot be null.");this.name=t}};const Jd=class Hg extends Vl{constructor(t){super(t),Xi(this,"id",(Hg.nextID++&65535)<<11),Xi(this,"bones"),Xi(this,"vertices"),Xi(this,"worldVerticesLength",0)}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,s,n,r,c){s=r+(s>>1)*c;const h=t.bone.skeleton,i=t.attachmentVertices;let a=this.vertices;const o=this.bones;if(o==null){i.length>0&&(a=i);const l=t.bone.matrix,g=l.tx,p=l.ty,y=l.a,w=l.c,b=l.b,x=l.d;for(let S=e,C=r;C<s;S+=2,C+=c){const A=a[S],v=a[S+1];n[C]=A*y+v*w+g,n[C+1]=A*b+v*x+p}return}let d=0,f=0;for(let l=0;l<e;l+=2){const g=o[d];d+=g+1,f+=g}const m=h.bones;if(i.length==0)for(let l=r,g=f*3;l<s;l+=c){let p=0,y=0,w=o[d++];for(w+=d;d<w;d++,g+=3){const b=m[o[d]].matrix,x=a[g],S=a[g+1],C=a[g+2];p+=(x*b.a+S*b.c+b.tx)*C,y+=(x*b.b+S*b.d+b.ty)*C}n[l]=p,n[l+1]=y}else{const l=i;for(let g=r,p=f*3,y=f<<1;g<s;g+=c){let w=0,b=0,x=o[d++];for(x+=d;d<x;d++,p+=3,y+=2){const S=m[o[d]].matrix,C=a[p]+l[y],A=a[p+1]+l[y+1],v=a[p+2];w+=(C*S.a+A*S.c+S.tx)*v,b+=(C*S.b+A*S.d+S.ty)*v}n[g]=w,n[g+1]=b}}}applyDeform(t){return this==t}};Xi(Jd,"nextID",0);let Bi=Jd;var u0=Object.defineProperty,f0=(u,t,e)=>t in u?u0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ts=(u,t,e)=>f0(u,typeof t!="symbol"?t+"":t,e);let m0=class{constructor(){ts(this,"array",new Array)}add(t){const e=this.contains(t);return this.array[t|0]=t|0,!e}contains(t){return this.array[t|0]!=null}remove(t){this.array[t|0]=void 0}clear(){this.array.length=0}};const wn=class Kg{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new Kg().setFromString(t)}};ts(wn,"WHITE",new wn(1,1,1,1)),ts(wn,"RED",new wn(1,0,0,1)),ts(wn,"GREEN",new wn(0,1,0,1)),ts(wn,"BLUE",new wn(0,0,1,1)),ts(wn,"MAGENTA",new wn(1,0,1,1));let Cs=wn;const Ls=class Do{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*Do.degRad)}static sinDeg(t){return Math.sin(t*Do.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*Do.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return Do.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};ts(Ls,"PI",3.1415927),ts(Ls,"PI2",Ls.PI*2),ts(Ls,"invPI2",1/Ls.PI2),ts(Ls,"radiansToDegrees",180/Ls.PI),ts(Ls,"radDeg",Ls.radiansToDegrees),ts(Ls,"degreesToRadians",Ls.PI/180),ts(Ls,"degRad",Ls.degreesToRadians);let j=Ls,g0=class{apply(t,e,s){return t+(e-t)*this.applyInternal(s)}},p0=class extends g0{constructor(t){super(),ts(this,"power",2),this.power=t}applyInternal(t){return t<=.5?Math.pow(t*2,this.power)/2:Math.pow((t-1)*2,this.power)/(this.power%2==0?-2:2)+1}},b0=class extends p0{applyInternal(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1}};const jd=class Va{static arrayCopy(t,e,s,n,r){for(let c=e,h=n;c<e+r;c++,h++)s[h]=t[c]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:Va.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(Va.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(Va.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return Va.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return Va.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}};ts(jd,"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");let pt=jd,tu=class{constructor(t){ts(this,"items",new Array),ts(this,"instantiator"),this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}},x0=class{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}};var Os=(u=>(u[u.Region=0]="Region",u[u.BoundingBox=1]="BoundingBox",u[u.Mesh=2]="Mesh",u[u.LinkedMesh=3]="LinkedMesh",u[u.Path=4]="Path",u[u.Point=5]="Point",u[u.Clipping=6]="Clipping",u))(Os||{}),nn=(u=>(u[u.Normal=0]="Normal",u[u.OnlyTranslation=1]="OnlyTranslation",u[u.NoRotationOrReflection=2]="NoRotationOrReflection",u[u.NoScale=3]="NoScale",u[u.NoScaleOrReflection=4]="NoScaleOrReflection",u))(nn||{}),eu=(u=>(u[u.none=0]="none",u[u.reset=1]="reset",u[u.update=2]="update",u[u.pose=3]="pose",u))(eu||{}),w0=Object.defineProperty,y0=(u,t,e)=>t in u?w0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ka=(u,t,e)=>y0(u,typeof t!="symbol"?t+"":t,e);let su=class{constructor(){Ka(this,"texture"),Ka(this,"size",null),Ka(this,"names",null),Ka(this,"values",null),Ka(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}};var nu=(u=>(u[u.UNKNOWN=0]="UNKNOWN",u[u.VER37=37]="VER37",u[u.VER38=38]="VER38",u[u.VER40=40]="VER40",u[u.VER41=41]="VER41",u[u.VER42=42]="VER42",u))(nu||{});function S0(u){const t=u.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}const C0={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var A0=Object.defineProperty,v0=(u,t,e)=>t in u?A0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,es=(u,t,e)=>v0(u,typeof t!="symbol"?t+"":t,e);const Qr=[0,0,0];let M0=class extends zr.Sprite{constructor(){super(...arguments),es(this,"region",null),es(this,"attachment",null)}},E0=class extends Gr.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),es(this,"region",null),es(this,"attachment",null)}};const ru=class Zg extends Lt.Container{constructor(t){if(super(),es(this,"tintRgb"),es(this,"spineData"),es(this,"skeleton"),es(this,"stateData"),es(this,"state"),es(this,"slotContainers"),es(this,"tempClipContainers"),es(this,"localDelayLimit"),es(this,"_autoUpdate"),es(this,"_visible"),es(this,"_debug"),es(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),c=this.newContainer();if(this.slotContainers.push(c),this.addChild(c),this.tempClipContainers.push(null),!!r)if(r.type===Os.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,c.addChild(i)}else if(r.type===Os.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,c.addChild(h)}else r.type===Os.Clipping&&(this.createGraphics(n,r),c.addChild(n.clippingContainer),c.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?Zg.prototype.autoUpdateTransform:Lt.Container.prototype.updateTransform)}get tint(){return G.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=G.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:C0.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=S0(this.spineData.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===nu.VER42&&eu.update);const n=this.skeleton.slots,r=this.color;let c=null,h=null;r?(c=r.light,h=r.dark):c=this.tintRgb;for(let f=0,m=n.length;f<m;f++){const l=n[f],g=l.getAttachment(),p=this.slotContainers[f];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(l,g);let w=g.region;const b=g.color;switch(g!=null&&g.type){case Os.Region:if(p.transform.setFromMatrix(l.bone.matrix),w=g.region,l.currentMesh&&(l.currentMesh.visible=!1,l.currentMesh=null,l.currentMeshId=void 0,l.currentMeshName=void 0),!w){l.currentSprite&&(l.currentSprite.renderable=!1);break}if(!l.currentSpriteName||l.currentSpriteName!==g.name){const C=g.name;if(l.currentSprite&&(l.currentSprite.visible=!1),l.sprites=l.sprites||{},l.sprites[C]!==void 0)l.sprites[C].visible=!0;else{const A=this.createSprite(l,g,C);p.addChild(A)}l.currentSprite=l.sprites[C],l.currentSpriteName=C}l.currentSprite.renderable=!0,l.hackRegion||this.setSpriteRegion(g,l.currentSprite,w),l.currentSprite.color?y=l.currentSprite.color:(Qr[0]=c[0]*l.color.r*b.r,Qr[1]=c[1]*l.color.g*b.g,Qr[2]=c[2]*l.color.b*b.b,l.currentSprite.tint=G.utils.rgb2hex(Qr)),l.currentSprite.blendMode=l.blendMode;break;case Os.Mesh:if(l.currentSprite){l.currentSprite.visible=!1,l.currentSprite=null,l.currentSpriteName=void 0;const C=new G.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){l.currentMesh&&(l.currentMesh.renderable=!1);break}const S=g.id;if(l.currentMeshId===void 0||l.currentMeshId!==S){const C=S;if(l.currentMesh&&(l.currentMesh.visible=!1),l.meshes=l.meshes||{},l.meshes[C]!==void 0)l.meshes[C].visible=!0;else{const A=this.createMesh(l,g);p.addChild(A)}l.currentMesh=l.meshes[C],l.currentMeshName=g.name,l.currentMeshId=C}l.currentMesh.renderable=!0,g.computeWorldVerticesOld(l,l.currentMesh.vertices),l.currentMesh.color?y=l.currentMesh.color:(Qr[0]=c[0]*l.color.r*b.r,Qr[1]=c[1]*l.color.g*b.g,Qr[2]=c[2]*l.color.b*b.b,l.currentMesh.tint=G.utils.rgb2hex(Qr)),l.currentMesh.blendMode=l.blendMode,l.hackRegion||this.setMeshRegion(g,l.currentMesh,w);break;case Os.Clipping:l.currentGraphics||(this.createGraphics(l,g),p.addChild(l.clippingContainer),p.addChild(l.currentGraphics)),this.updateGraphics(l,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let x=l.color.r*b.r,S=l.color.g*b.g,C=l.color.b*b.b;y.setLight(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C)),l.darkColor?(x=l.darkColor.r,S=l.darkColor.g,C=l.darkColor.b):(x=0,S=0,C=0),y.setDark(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C))}p.alpha=l.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let f=0,m=i.length;f<m;f++){const l=n[i[f].data.index],g=this.slotContainers[i[f].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),l.currentGraphics&&l.getAttachment())o=l.clippingContainer,a=l.getAttachment(),o.children.length=0,this.children[f]=g,a.endSlot===l.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[f];p||(p=this.tempClipContainers[f]=this.newContainer(),p.visible=!1),this.children[f]=p,g.parent=null,o.addChild(g),a.endSlot==l.data&&(o.renderable=!0,o=null,a=null)}else this.children[f]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*j.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}Lt.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,c=this.newSprite(r);return c.anchor.set(.5),n&&this.setSpriteRegion(e,c,e.region),t.sprites=t.sprites||{},t.sprites[s]=c,c}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),G.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new G.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let c=r.region;return e?(c=new su,c.texture=e,c.size=s,n.hackRegion=c,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,c):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,c),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),c=this.skeleton.getAttachmentByName(t,e);c.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=c.region;return s?(a=new su,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Lt.Container}newSprite(t){return new M0(t)}newGraphics(){return new Ye.Graphics}newMesh(t,e,s,n,r){return new E0(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let c=0,h=this.skeleton.slots.length;c<h;c++){const i=this.skeleton.slots[c],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};es(ru,"clippingPolygon",[]);let iu=ru;Object.defineProperty(iu.prototype,"visible",{get(){return this._visible},set(u){u!==this._visible&&(this._visible=u,u&&(this.lastTime=0))}});var T0=Object.defineProperty,I0=(u,t,e)=>t in u?T0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Jr=(u,t,e)=>I0(u,typeof t!="symbol"?t+"":t,e);let Nl=class{constructor(t,e){if(Jr(this,"blendMode"),Jr(this,"data"),Jr(this,"bone"),Jr(this,"color"),Jr(this,"darkColor"),Jr(this,"attachment"),Jr(this,"attachmentTime"),Jr(this,"attachmentVertices",new Array),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new Cs,this.darkColor=t.darkColor==null?null:new Cs,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.attachmentVertices.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}};var R0=Object.defineProperty,P0=(u,t,e)=>t in u?R0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ft=(u,t,e)=>P0(u,typeof t!="symbol"?t+"":t,e);const vt=class Ss extends Vl{constructor(t){super(t),ft(this,"type",Os.Region),ft(this,"x",0),ft(this,"y",0),ft(this,"scaleX",1),ft(this,"scaleY",1),ft(this,"rotation",0),ft(this,"width",0),ft(this,"height",0),ft(this,"color",new Cs(1,1,1,1)),ft(this,"path"),ft(this,"rendererObject"),ft(this,"region"),ft(this,"offset",pt.newFloatArray(8)),ft(this,"uvs",pt.newFloatArray(8)),ft(this,"tempColor",new Cs(1,1,1,1))}updateOffset(){const t=this.width/this.region.originalWidth*this.scaleX,e=this.height/this.region.originalHeight*this.scaleY,s=-this.width/2*this.scaleX+this.region.offsetX*t,n=-this.height/2*this.scaleY+this.region.offsetY*e,r=s+this.region.width*t,c=n+this.region.height*e,h=this.rotation*Math.PI/180,i=Math.cos(h),a=Math.sin(h),o=s*i+this.x,d=s*a,f=n*i+this.y,m=n*a,l=r*i+this.x,g=r*a,p=c*i+this.y,y=c*a,w=this.offset;w[Ss.OX1]=o-m,w[Ss.OY1]=f+d,w[Ss.OX2]=o-y,w[Ss.OY2]=p+d,w[Ss.OX3]=l-y,w[Ss.OY3]=p+g,w[Ss.OX4]=l-m,w[Ss.OY4]=f+g}setRegion(t){this.region=t;const e=this.uvs;t.rotate?(e[2]=t.u,e[3]=t.v2,e[4]=t.u,e[5]=t.v,e[6]=t.u2,e[7]=t.v,e[0]=t.u2,e[1]=t.v2):(e[0]=t.u,e[1]=t.v2,e[2]=t.u,e[3]=t.v,e[4]=t.u2,e[5]=t.v,e[6]=t.u2,e[7]=t.v2)}computeWorldVertices(t,e,s,n){const r=this.offset,c=t instanceof Nl?t.bone.matrix:t.matrix,h=c.tx,i=c.ty,a=c.a,o=c.c,d=c.b,f=c.d;let m=0,l=0;m=r[Ss.OX1],l=r[Ss.OY1],e[s]=m*a+l*o+h,e[s+1]=m*d+l*f+i,s+=n,m=r[Ss.OX2],l=r[Ss.OY2],e[s]=m*a+l*o+h,e[s+1]=m*d+l*f+i,s+=n,m=r[Ss.OX3],l=r[Ss.OY3],e[s]=m*a+l*o+h,e[s+1]=m*d+l*f+i,s+=n,m=r[Ss.OX4],l=r[Ss.OY4],e[s]=m*a+l*o+h,e[s+1]=m*d+l*f+i}};ft(vt,"OX1",0),ft(vt,"OY1",1),ft(vt,"OX2",2),ft(vt,"OY2",3),ft(vt,"OX3",4),ft(vt,"OY3",5),ft(vt,"OX4",6),ft(vt,"OY4",7),ft(vt,"X1",0),ft(vt,"Y1",1),ft(vt,"C1R",2),ft(vt,"C1G",3),ft(vt,"C1B",4),ft(vt,"C1A",5),ft(vt,"U1",6),ft(vt,"V1",7),ft(vt,"X2",8),ft(vt,"Y2",9),ft(vt,"C2R",10),ft(vt,"C2G",11),ft(vt,"C2B",12),ft(vt,"C2A",13),ft(vt,"U2",14),ft(vt,"V2",15),ft(vt,"X3",16),ft(vt,"Y3",17),ft(vt,"C3R",18),ft(vt,"C3G",19),ft(vt,"C3B",20),ft(vt,"C3A",21),ft(vt,"U3",22),ft(vt,"V3",23),ft(vt,"X4",24),ft(vt,"Y4",25),ft(vt,"C4R",26),ft(vt,"C4G",27),ft(vt,"C4B",28),ft(vt,"C4A",29),ft(vt,"U4",30),ft(vt,"V4",31);let Dl=vt;var k0=Object.defineProperty,F0=(u,t,e)=>t in u?k0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Vi=(u,t,e)=>F0(u,typeof t!="symbol"?t+"":t,e);const au=class Qg{constructor(t){Vi(this,"centerX",0),Vi(this,"centerY",0),Vi(this,"radius",0),Vi(this,"angle",0),Vi(this,"worldX",0),Vi(this,"worldY",0),this.radius=t}begin(t){this.worldX=t.x+this.centerX,this.worldY=t.y+this.centerY}transform(t,e,s,n){const r=this.angle*j.degreesToRadians,c=t.x-this.worldX,h=t.y-this.worldY,i=Math.sqrt(c*c+h*h);if(i<this.radius){const a=Qg.interpolation.apply(0,r,(this.radius-i)/this.radius),o=Math.cos(a),d=Math.sin(a);t.x=o*c-d*h+this.worldX,t.y=d*c+o*h+this.worldY}}end(){}};Vi(au,"interpolation",new b0(2));let Y0=au;var et=(u=>(u[u.setup=0]="setup",u[u.first=1]="first",u[u.replace=2]="replace",u[u.add=3]="add",u))(et||{}),Ps=(u=>(u[u.mixIn=0]="mixIn",u[u.mixOut=1]="mixOut",u))(Ps||{}),$0=Object.defineProperty,_0=(u,t,e)=>t in u?$0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,K=(u,t,e)=>_0(u,typeof t!="symbol"?t+"":t,e);let $e=class{constructor(t,e,s){if(K(this,"name"),K(this,"timelines"),K(this,"duration"),t==null)throw new Error("name cannot be null.");if(e==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=e,this.duration=s}apply(t,e,s,n,r,c,h,i){if(t==null)throw new Error("skeleton cannot be null.");n&&this.duration!=0&&(s%=this.duration,e>0&&(e%=this.duration));const a=this.timelines;for(let o=0,d=a.length;o<d;o++)a[o].apply(t,e,s,r,c,h,i)}static binarySearch(t,e,s=1){let n=0,r=t.length/s-2;if(r==0)return s;let c=r>>>1;for(;;){if(t[(c+1)*s]<=e?n=c+1:r=c,n==r)return(n+1)*s;c=n+r>>>1}}static linearSearch(t,e,s){for(let n=0,r=t.length-s;n<=r;n+=s)if(t[n]>e)return n;return-1}};var ou=(u=>(u[u.rotate=0]="rotate",u[u.translate=1]="translate",u[u.scale=2]="scale",u[u.shear=3]="shear",u[u.attachment=4]="attachment",u[u.color=5]="color",u[u.deform=6]="deform",u[u.event=7]="event",u[u.drawOrder=8]="drawOrder",u[u.ikConstraint=9]="ikConstraint",u[u.transformConstraint=10]="transformConstraint",u[u.pathConstraintPosition=11]="pathConstraintPosition",u[u.pathConstraintSpacing=12]="pathConstraintSpacing",u[u.pathConstraintMix=13]="pathConstraintMix",u[u.twoColor=14]="twoColor",u))(ou||{});const Za=class Re{constructor(t){if(K(this,"curves"),t<=0)throw new Error(`frameCount must be > 0: ${t}`);this.curves=pt.newFloatArray((t-1)*Re.BEZIER_SIZE)}getFrameCount(){return this.curves.length/Re.BEZIER_SIZE+1}setLinear(t){this.curves[t*Re.BEZIER_SIZE]=Re.LINEAR}setStepped(t){this.curves[t*Re.BEZIER_SIZE]=Re.STEPPED}getCurveType(t){const e=t*Re.BEZIER_SIZE;if(e==this.curves.length)return Re.LINEAR;const s=this.curves[e];return s==Re.LINEAR?Re.LINEAR:s==Re.STEPPED?Re.STEPPED:Re.BEZIER}setCurve(t,e,s,n,r){const c=(-e*2+n)*.03,h=(-s*2+r)*.03,i=((e-n)*3+1)*.006,a=((s-r)*3+1)*.006;let o=c*2+i,d=h*2+a,f=e*.3+c+i*.16666667,m=s*.3+h+a*.16666667,l=t*Re.BEZIER_SIZE;const g=this.curves;g[l++]=Re.BEZIER;let p=f,y=m;for(let w=l+Re.BEZIER_SIZE-1;l<w;l+=2)g[l]=p,g[l+1]=y,f+=o,m+=d,o+=i,d+=a,p+=f,y+=m}getCurvePercent(t,e){e=j.clamp(e,0,1);const s=this.curves;let n=t*Re.BEZIER_SIZE;const r=s[n];if(r==Re.LINEAR)return e;if(r==Re.STEPPED)return 0;n++;let c=0;for(let i=n,a=n+Re.BEZIER_SIZE-1;n<a;n+=2)if(c=s[n],c>=e){let o,d;return n==i?(o=0,d=0):(o=s[n-2],d=s[n-1]),d+(s[n+1]-d)*(e-o)/(c-o)}const h=s[n-1];return h+(1-h)*(e-c)/(1-c)}};K(Za,"LINEAR",0),K(Za,"STEPPED",1),K(Za,"BEZIER",2),K(Za,"BEZIER_SIZE",10*2-1);let er=Za;const Qa=class vi extends er{constructor(t){super(t),K(this,"boneIndex"),K(this,"frames"),this.frames=pt.newFloatArray(t<<1)}getPropertyId(){return 0+this.boneIndex}setFrame(t,e,s){t<<=1,this.frames[t]=e,this.frames[t+vi.ROTATION]=s}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.bones[this.boneIndex];if(s<i[0]){switch(c){case et.setup:a.rotation=a.data.rotation;return;case et.first:const g=a.data.rotation-a.rotation;a.rotation+=(g-(16384-(16384.499999999996-g/360|0))*360)*r}return}if(s>=i[i.length-vi.ENTRIES]){let g=i[i.length+vi.PREV_ROTATION];switch(c){case et.setup:a.rotation=a.data.rotation+g*r;break;case et.first:case et.replace:g+=a.data.rotation-a.rotation,g-=(16384-(16384.499999999996-g/360|0))*360;case et.add:a.rotation+=g*r}return}const o=$e.binarySearch(i,s,vi.ENTRIES),d=i[o+vi.PREV_ROTATION],f=i[o],m=this.getCurvePercent((o>>1)-1,1-(s-f)/(i[o+vi.PREV_TIME]-f));let l=i[o+vi.ROTATION]-d;switch(l=d+(l-(16384-(16384.499999999996-l/360|0))*360)*m,c){case et.setup:a.rotation=a.data.rotation+(l-(16384-(16384.499999999996-l/360|0))*360)*r;break;case et.first:case et.replace:l+=a.data.rotation-a.rotation;case et.add:a.rotation+=(l-(16384-(16384.499999999996-l/360|0))*360)*r}}};K(Qa,"ENTRIES",2),K(Qa,"PREV_TIME",-2),K(Qa,"PREV_ROTATION",-1),K(Qa,"ROTATION",1);let yn=Qa;const Ni=class _s extends er{constructor(t){super(t),K(this,"boneIndex"),K(this,"frames"),this.frames=pt.newFloatArray(t*_s.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(t,e,s,n){t*=_s.ENTRIES,this.frames[t]=e,this.frames[t+_s.X]=s,this.frames[t+_s.Y]=n}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.bones[this.boneIndex];if(s<i[0]){switch(c){case et.setup:a.x=a.data.x,a.y=a.data.y;return;case et.first:a.x+=(a.data.x-a.x)*r,a.y+=(a.data.y-a.y)*r}return}let o=0,d=0;if(s>=i[i.length-_s.ENTRIES])o=i[i.length+_s.PREV_X],d=i[i.length+_s.PREV_Y];else{const f=$e.binarySearch(i,s,_s.ENTRIES);o=i[f+_s.PREV_X],d=i[f+_s.PREV_Y];const m=i[f],l=this.getCurvePercent(f/_s.ENTRIES-1,1-(s-m)/(i[f+_s.PREV_TIME]-m));o+=(i[f+_s.X]-o)*l,d+=(i[f+_s.Y]-d)*l}switch(c){case et.setup:a.x=a.data.x+o*r,a.y=a.data.y+d*r;break;case et.first:case et.replace:a.x+=(a.data.x+o-a.x)*r,a.y+=(a.data.y+d-a.y)*r;break;case et.add:a.x+=o*r,a.y+=d*r}}};K(Ni,"ENTRIES",3),K(Ni,"PREV_TIME",-3),K(Ni,"PREV_X",-2),K(Ni,"PREV_Y",-1),K(Ni,"X",1),K(Ni,"Y",2);let Ja=Ni,lu=class zn extends Ja{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.bones[this.boneIndex];if(s<i[0]){switch(c){case et.setup:a.scaleX=a.data.scaleX,a.scaleY=a.data.scaleY;return;case et.first:a.scaleX+=(a.data.scaleX-a.scaleX)*r,a.scaleY+=(a.data.scaleY-a.scaleY)*r}return}let o=0,d=0;if(s>=i[i.length-zn.ENTRIES])o=i[i.length+zn.PREV_X]*a.data.scaleX,d=i[i.length+zn.PREV_Y]*a.data.scaleY;else{const f=$e.binarySearch(i,s,zn.ENTRIES);o=i[f+zn.PREV_X],d=i[f+zn.PREV_Y];const m=i[f],l=this.getCurvePercent(f/zn.ENTRIES-1,1-(s-m)/(i[f+zn.PREV_TIME]-m));o=(o+(i[f+zn.X]-o)*l)*a.data.scaleX,d=(d+(i[f+zn.Y]-d)*l)*a.data.scaleY}if(r==1)c==et.add?(a.scaleX+=o-a.data.scaleX,a.scaleY+=d-a.data.scaleY):(a.scaleX=o,a.scaleY=d);else{let f=0,m=0;if(h==Ps.mixOut)switch(c){case et.setup:f=a.data.scaleX,m=a.data.scaleY,a.scaleX=f+(Math.abs(o)*j.signum(f)-f)*r,a.scaleY=m+(Math.abs(d)*j.signum(m)-m)*r;break;case et.first:case et.replace:f=a.scaleX,m=a.scaleY,a.scaleX=f+(Math.abs(o)*j.signum(f)-f)*r,a.scaleY=m+(Math.abs(d)*j.signum(m)-m)*r;break;case et.add:f=a.scaleX,m=a.scaleY,a.scaleX=f+(Math.abs(o)*j.signum(f)-a.data.scaleX)*r,a.scaleY=m+(Math.abs(d)*j.signum(m)-a.data.scaleY)*r}else switch(c){case et.setup:f=Math.abs(a.data.scaleX)*j.signum(o),m=Math.abs(a.data.scaleY)*j.signum(d),a.scaleX=f+(o-f)*r,a.scaleY=m+(d-m)*r;break;case et.first:case et.replace:f=Math.abs(a.scaleX)*j.signum(o),m=Math.abs(a.scaleY)*j.signum(d),a.scaleX=f+(o-f)*r,a.scaleY=m+(d-m)*r;break;case et.add:f=j.signum(o),m=j.signum(d),a.scaleX=Math.abs(a.scaleX)*f+(o-Math.abs(a.data.scaleX)*f)*r,a.scaleY=Math.abs(a.scaleY)*m+(d-Math.abs(a.data.scaleY)*m)*r}}}},cu=class Hn extends Ja{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.bones[this.boneIndex];if(s<i[0]){switch(c){case et.setup:a.shearX=a.data.shearX,a.shearY=a.data.shearY;return;case et.first:a.shearX+=(a.data.shearX-a.shearX)*r,a.shearY+=(a.data.shearY-a.shearY)*r}return}let o=0,d=0;if(s>=i[i.length-Hn.ENTRIES])o=i[i.length+Hn.PREV_X],d=i[i.length+Hn.PREV_Y];else{const f=$e.binarySearch(i,s,Hn.ENTRIES);o=i[f+Hn.PREV_X],d=i[f+Hn.PREV_Y];const m=i[f],l=this.getCurvePercent(f/Hn.ENTRIES-1,1-(s-m)/(i[f+Hn.PREV_TIME]-m));o=o+(i[f+Hn.X]-o)*l,d=d+(i[f+Hn.Y]-d)*l}switch(c){case et.setup:a.shearX=a.data.shearX+o*r,a.shearY=a.data.shearY+d*r;break;case et.first:case et.replace:a.shearX+=(a.data.shearX+o-a.shearX)*r,a.shearY+=(a.data.shearY+d-a.shearY)*r;break;case et.add:a.shearX+=o*r,a.shearY+=d*r}}};const Sn=class oe extends er{constructor(t){super(t),K(this,"slotIndex"),K(this,"frames"),this.frames=pt.newFloatArray(t*oe.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(t,e,s,n,r,c){t*=oe.ENTRIES,this.frames[t]=e,this.frames[t+oe.R]=s,this.frames[t+oe.G]=n,this.frames[t+oe.B]=r,this.frames[t+oe.A]=c}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex],a=this.frames;if(s<a[0]){switch(c){case et.setup:i.color.setFromColor(i.data.color);return;case et.first:const l=i.color,g=i.data.color;l.add((g.r-l.r)*r,(g.g-l.g)*r,(g.b-l.b)*r,(g.a-l.a)*r)}return}let o=0,d=0,f=0,m=0;if(s>=a[a.length-oe.ENTRIES]){const l=a.length;o=a[l+oe.PREV_R],d=a[l+oe.PREV_G],f=a[l+oe.PREV_B],m=a[l+oe.PREV_A]}else{const l=$e.binarySearch(a,s,oe.ENTRIES);o=a[l+oe.PREV_R],d=a[l+oe.PREV_G],f=a[l+oe.PREV_B],m=a[l+oe.PREV_A];const g=a[l],p=this.getCurvePercent(l/oe.ENTRIES-1,1-(s-g)/(a[l+oe.PREV_TIME]-g));o+=(a[l+oe.R]-o)*p,d+=(a[l+oe.G]-d)*p,f+=(a[l+oe.B]-f)*p,m+=(a[l+oe.A]-m)*p}if(r==1)i.color.set(o,d,f,m);else{const l=i.color;c==et.setup&&l.setFromColor(i.data.color),l.add((o-l.r)*r,(d-l.g)*r,(f-l.b)*r,(m-l.a)*r)}}};K(Sn,"ENTRIES",5),K(Sn,"PREV_TIME",-5),K(Sn,"PREV_R",-4),K(Sn,"PREV_G",-3),K(Sn,"PREV_B",-2),K(Sn,"PREV_A",-1),K(Sn,"R",1),K(Sn,"G",2),K(Sn,"B",3),K(Sn,"A",4);let Ll=Sn;const ss=class Nt extends er{constructor(t){super(t),K(this,"slotIndex"),K(this,"frames"),this.frames=pt.newFloatArray(t*Nt.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(t,e,s,n,r,c,h,i,a){t*=Nt.ENTRIES,this.frames[t]=e,this.frames[t+Nt.R]=s,this.frames[t+Nt.G]=n,this.frames[t+Nt.B]=r,this.frames[t+Nt.A]=c,this.frames[t+Nt.R2]=h,this.frames[t+Nt.G2]=i,this.frames[t+Nt.B2]=a}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex],a=this.frames;if(s<a[0]){switch(c){case et.setup:i.color.setFromColor(i.data.color),i.darkColor.setFromColor(i.data.darkColor);return;case et.first:const y=i.color,w=i.darkColor,b=i.data.color,x=i.data.darkColor;y.add((b.r-y.r)*r,(b.g-y.g)*r,(b.b-y.b)*r,(b.a-y.a)*r),w.add((x.r-w.r)*r,(x.g-w.g)*r,(x.b-w.b)*r,0)}return}let o=0,d=0,f=0,m=0,l=0,g=0,p=0;if(s>=a[a.length-Nt.ENTRIES]){const y=a.length;o=a[y+Nt.PREV_R],d=a[y+Nt.PREV_G],f=a[y+Nt.PREV_B],m=a[y+Nt.PREV_A],l=a[y+Nt.PREV_R2],g=a[y+Nt.PREV_G2],p=a[y+Nt.PREV_B2]}else{const y=$e.binarySearch(a,s,Nt.ENTRIES);o=a[y+Nt.PREV_R],d=a[y+Nt.PREV_G],f=a[y+Nt.PREV_B],m=a[y+Nt.PREV_A],l=a[y+Nt.PREV_R2],g=a[y+Nt.PREV_G2],p=a[y+Nt.PREV_B2];const w=a[y],b=this.getCurvePercent(y/Nt.ENTRIES-1,1-(s-w)/(a[y+Nt.PREV_TIME]-w));o+=(a[y+Nt.R]-o)*b,d+=(a[y+Nt.G]-d)*b,f+=(a[y+Nt.B]-f)*b,m+=(a[y+Nt.A]-m)*b,l+=(a[y+Nt.R2]-l)*b,g+=(a[y+Nt.G2]-g)*b,p+=(a[y+Nt.B2]-p)*b}if(r==1)i.color.set(o,d,f,m),i.darkColor.set(l,g,p,1);else{const y=i.color,w=i.darkColor;c==et.setup&&(y.setFromColor(i.data.color),w.setFromColor(i.data.darkColor)),y.add((o-y.r)*r,(d-y.g)*r,(f-y.b)*r,(m-y.a)*r),w.add((l-w.r)*r,(g-w.g)*r,(p-w.b)*r,0)}}};K(ss,"ENTRIES",8),K(ss,"PREV_TIME",-8),K(ss,"PREV_R",-7),K(ss,"PREV_G",-6),K(ss,"PREV_B",-5),K(ss,"PREV_A",-4),K(ss,"PREV_R2",-3),K(ss,"PREV_G2",-2),K(ss,"PREV_B2",-1),K(ss,"R",1),K(ss,"G",2),K(ss,"B",3),K(ss,"A",4),K(ss,"R2",5),K(ss,"G2",6),K(ss,"B2",7);let Ol=ss,Zo=class{constructor(t){K(this,"slotIndex"),K(this,"frames"),K(this,"attachmentNames"),this.frames=pt.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.attachmentNames[t]=s}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(h==Ps.mixOut&&c==et.setup){const f=i.data.attachmentName;i.setAttachment(f==null?null:t.getAttachment(this.slotIndex,f));return}const a=this.frames;if(s<a[0]){if(c==et.setup||c==et.first){const f=i.data.attachmentName;i.setAttachment(f==null?null:t.getAttachment(this.slotIndex,f))}return}let o=0;s>=a[a.length-1]?o=a.length-1:o=$e.binarySearch(a,s,1)-1;const d=this.attachmentNames[o];t.slots[this.slotIndex].setAttachment(d==null?null:t.getAttachment(this.slotIndex,d))}},hu=null,du=class extends er{constructor(t){super(t),K(this,"slotIndex"),K(this,"attachment"),K(this,"frames"),K(this,"frameVertices"),this.frames=pt.newFloatArray(t),this.frameVertices=new Array(t),hu==null&&(hu=pt.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,e,s){this.frames[t]=e,this.frameVertices[t]=s}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex],a=i.getAttachment();if(!(a instanceof Bi)||!a.applyDeform(this.attachment))return;const o=i.attachmentVertices;o.length==0&&(c=et.setup);const d=this.frameVertices,f=d[0].length,m=this.frames;if(s<m[0]){const x=a;switch(c){case et.setup:o.length=0;return;case et.first:if(r==1){o.length=0;break}const S=pt.setArraySize(o,f);if(x.bones==null){const C=x.vertices;for(let A=0;A<f;A++)S[A]+=(C[A]-S[A])*r}else{r=1-r;for(let C=0;C<f;C++)S[C]*=r}}return}const l=pt.setArraySize(o,f);if(s>=m[m.length-1]){const x=d[m.length-1];if(r==1)if(c==et.add){const S=a;if(S.bones==null){const C=S.vertices;for(let A=0;A<f;A++)l[A]+=x[A]-C[A]}else for(let C=0;C<f;C++)l[C]+=x[C]}else pt.arrayCopy(x,0,l,0,f);else switch(c){case et.setup:{const C=a;if(C.bones==null){const A=C.vertices;for(let v=0;v<f;v++){const M=A[v];l[v]=M+(x[v]-M)*r}}else for(let A=0;A<f;A++)l[A]=x[A]*r;break}case et.first:case et.replace:for(let C=0;C<f;C++)l[C]+=(x[C]-l[C])*r;case et.add:const S=a;if(S.bones==null){const C=S.vertices;for(let A=0;A<f;A++)l[A]+=(x[A]-C[A])*r}else for(let C=0;C<f;C++)l[C]+=x[C]*r}return}const g=$e.binarySearch(m,s),p=d[g-1],y=d[g],w=m[g],b=this.getCurvePercent(g-1,1-(s-w)/(m[g-1]-w));if(r==1)if(c==et.add){const x=a;if(x.bones==null){const S=x.vertices;for(let C=0;C<f;C++){const A=p[C];l[C]+=A+(y[C]-A)*b-S[C]}}else for(let S=0;S<f;S++){const C=p[S];l[S]+=C+(y[S]-C)*b}}else for(let x=0;x<f;x++){const S=p[x];l[x]=S+(y[x]-S)*b}else switch(c){case et.setup:{const S=a;if(S.bones==null){const C=S.vertices;for(let A=0;A<f;A++){const v=p[A],M=C[A];l[A]=M+(v+(y[A]-v)*b-M)*r}}else for(let C=0;C<f;C++){const A=p[C];l[C]=(A+(y[C]-A)*b)*r}break}case et.first:case et.replace:for(let S=0;S<f;S++){const C=p[S];l[S]+=(C+(y[S]-C)*b-l[S])*r}break;case et.add:const x=a;if(x.bones==null){const S=x.vertices;for(let C=0;C<f;C++){const A=p[C];l[C]+=(A+(y[C]-A)*b-S[C])*r}}else for(let S=0;S<f;S++){const C=p[S];l[S]+=(C+(y[S]-C)*b)*r}}}},uu=class{constructor(t){K(this,"frames"),K(this,"events"),this.frames=pt.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,s,n,r,c,h){if(n==null)return;const i=this.frames,a=this.frames.length;if(e>s)this.apply(t,e,Number.MAX_VALUE,n,r,c,h),e=-1;else if(e>=i[a-1])return;if(s<i[0])return;let o=0;if(e<i[0])o=0;else{o=$e.binarySearch(i,e);const d=i[o];for(;o>0&&i[o-1]==d;)o--}for(;o<a&&s>=i[o];o++)n.push(this.events[o])}},Qo=class{constructor(t){K(this,"frames"),K(this,"drawOrders"),this.frames=pt.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.drawOrders[t]=s}apply(t,e,s,n,r,c,h){const i=t.drawOrder,a=t.slots;if(h==Ps.mixOut&&c==et.setup){pt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const o=this.frames;if(s<o[0]){(c==et.setup||c==et.first)&&pt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let d=0;s>=o[o.length-1]?d=o.length-1:d=$e.binarySearch(o,s)-1;const f=this.drawOrders[d];if(f==null)pt.arrayCopy(a,0,i,0,a.length);else for(let m=0,l=f.length;m<l;m++)i[m]=a[f[m]]}};const Cn=class jt extends er{constructor(t){super(t),K(this,"ikConstraintIndex"),K(this,"frames"),this.frames=pt.newFloatArray(t*jt.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(t,e,s,n,r,c){t*=jt.ENTRIES,this.frames[t]=e,this.frames[t+jt.MIX]=s,this.frames[t+jt.BEND_DIRECTION]=n,this.frames[t+jt.COMPRESS]=r?1:0,this.frames[t+jt.STRETCH]=c?1:0}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.ikConstraints[this.ikConstraintIndex];if(s<i[0]){switch(c){case et.setup:a.mix=a.data.mix,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch;return;case et.first:a.mix+=(a.data.mix-a.mix)*r,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch}return}if(s>=i[i.length-jt.ENTRIES]){c==et.setup?(a.mix=a.data.mix+(i[i.length+jt.PREV_MIX]-a.data.mix)*r,h==Ps.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=i[i.length+jt.PREV_BEND_DIRECTION],a.compress=i[i.length+jt.PREV_COMPRESS]!=0,a.stretch=i[i.length+jt.PREV_STRETCH]!=0)):(a.mix+=(i[i.length+jt.PREV_MIX]-a.mix)*r,h==Ps.mixIn&&(a.bendDirection=i[i.length+jt.PREV_BEND_DIRECTION],a.compress=i[i.length+jt.PREV_COMPRESS]!=0,a.stretch=i[i.length+jt.PREV_STRETCH]!=0));return}const o=$e.binarySearch(i,s,jt.ENTRIES),d=i[o+jt.PREV_MIX],f=i[o],m=this.getCurvePercent(o/jt.ENTRIES-1,1-(s-f)/(i[o+jt.PREV_TIME]-f));c==et.setup?(a.mix=a.data.mix+(d+(i[o+jt.MIX]-d)*m-a.data.mix)*r,h==Ps.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=i[o+jt.PREV_BEND_DIRECTION],a.compress=i[o+jt.PREV_COMPRESS]!=0,a.stretch=i[o+jt.PREV_STRETCH]!=0)):(a.mix+=(d+(i[o+jt.MIX]-d)*m-a.mix)*r,h==Ps.mixIn&&(a.bendDirection=i[o+jt.PREV_BEND_DIRECTION],a.compress=i[o+jt.PREV_COMPRESS]!=0,a.stretch=i[o+jt.PREV_STRETCH]!=0))}};K(Cn,"ENTRIES",5),K(Cn,"PREV_TIME",-5),K(Cn,"PREV_MIX",-4),K(Cn,"PREV_BEND_DIRECTION",-3),K(Cn,"PREV_COMPRESS",-2),K(Cn,"PREV_STRETCH",-1),K(Cn,"MIX",1),K(Cn,"BEND_DIRECTION",2),K(Cn,"COMPRESS",3),K(Cn,"STRETCH",4);let Wl=Cn;const An=class le extends er{constructor(t){super(t),K(this,"transformConstraintIndex"),K(this,"frames"),this.frames=pt.newFloatArray(t*le.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(t,e,s,n,r,c){t*=le.ENTRIES,this.frames[t]=e,this.frames[t+le.ROTATE]=s,this.frames[t+le.TRANSLATE]=n,this.frames[t+le.SCALE]=r,this.frames[t+le.SHEAR]=c}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.transformConstraints[this.transformConstraintIndex];if(s<i[0]){const l=a.data;switch(c){case et.setup:a.rotateMix=l.rotateMix,a.translateMix=l.translateMix,a.scaleMix=l.scaleMix,a.shearMix=l.shearMix;return;case et.first:a.rotateMix+=(l.rotateMix-a.rotateMix)*r,a.translateMix+=(l.translateMix-a.translateMix)*r,a.scaleMix+=(l.scaleMix-a.scaleMix)*r,a.shearMix+=(l.shearMix-a.shearMix)*r}return}let o=0,d=0,f=0,m=0;if(s>=i[i.length-le.ENTRIES]){const l=i.length;o=i[l+le.PREV_ROTATE],d=i[l+le.PREV_TRANSLATE],f=i[l+le.PREV_SCALE],m=i[l+le.PREV_SHEAR]}else{const l=$e.binarySearch(i,s,le.ENTRIES);o=i[l+le.PREV_ROTATE],d=i[l+le.PREV_TRANSLATE],f=i[l+le.PREV_SCALE],m=i[l+le.PREV_SHEAR];const g=i[l],p=this.getCurvePercent(l/le.ENTRIES-1,1-(s-g)/(i[l+le.PREV_TIME]-g));o+=(i[l+le.ROTATE]-o)*p,d+=(i[l+le.TRANSLATE]-d)*p,f+=(i[l+le.SCALE]-f)*p,m+=(i[l+le.SHEAR]-m)*p}if(c==et.setup){const l=a.data;a.rotateMix=l.rotateMix+(o-l.rotateMix)*r,a.translateMix=l.translateMix+(d-l.translateMix)*r,a.scaleMix=l.scaleMix+(f-l.scaleMix)*r,a.shearMix=l.shearMix+(m-l.shearMix)*r}else a.rotateMix+=(o-a.rotateMix)*r,a.translateMix+=(d-a.translateMix)*r,a.scaleMix+=(f-a.scaleMix)*r,a.shearMix+=(m-a.shearMix)*r}};K(An,"ENTRIES",5),K(An,"PREV_TIME",-5),K(An,"PREV_ROTATE",-4),K(An,"PREV_TRANSLATE",-3),K(An,"PREV_SCALE",-2),K(An,"PREV_SHEAR",-1),K(An,"ROTATE",1),K(An,"TRANSLATE",2),K(An,"SCALE",3),K(An,"SHEAR",4);let Ul=An;const ja=class Kn extends er{constructor(t){super(t),K(this,"pathConstraintIndex"),K(this,"frames"),this.frames=pt.newFloatArray(t*Kn.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(t,e,s){t*=Kn.ENTRIES,this.frames[t]=e,this.frames[t+Kn.VALUE]=s}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(s<i[0]){switch(c){case et.setup:a.position=a.data.position;return;case et.first:a.position+=(a.data.position-a.position)*r}return}let o=0;if(s>=i[i.length-Kn.ENTRIES])o=i[i.length+Kn.PREV_VALUE];else{const d=$e.binarySearch(i,s,Kn.ENTRIES);o=i[d+Kn.PREV_VALUE];const f=i[d],m=this.getCurvePercent(d/Kn.ENTRIES-1,1-(s-f)/(i[d+Kn.PREV_TIME]-f));o+=(i[d+Kn.VALUE]-o)*m}c==et.setup?a.position=a.data.position+(o-a.data.position)*r:a.position+=(o-a.position)*r}};K(ja,"ENTRIES",2),K(ja,"PREV_TIME",-2),K(ja,"PREV_VALUE",-1),K(ja,"VALUE",1);let Jo=ja,fu=class Mi extends Jo{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(s<i[0]){switch(c){case et.setup:a.spacing=a.data.spacing;return;case et.first:a.spacing+=(a.data.spacing-a.spacing)*r}return}let o=0;if(s>=i[i.length-Mi.ENTRIES])o=i[i.length+Mi.PREV_VALUE];else{const d=$e.binarySearch(i,s,Mi.ENTRIES);o=i[d+Mi.PREV_VALUE];const f=i[d],m=this.getCurvePercent(d/Mi.ENTRIES-1,1-(s-f)/(i[d+Mi.PREV_TIME]-f));o+=(i[d+Mi.VALUE]-o)*m}c==et.setup?a.spacing=a.data.spacing+(o-a.data.spacing)*r:a.spacing+=(o-a.spacing)*r}};const Di=class Xs extends er{constructor(t){super(t),K(this,"pathConstraintIndex"),K(this,"frames"),this.frames=pt.newFloatArray(t*Xs.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(t,e,s,n){t*=Xs.ENTRIES,this.frames[t]=e,this.frames[t+Xs.ROTATE]=s,this.frames[t+Xs.TRANSLATE]=n}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(s<i[0]){switch(c){case et.setup:a.rotateMix=a.data.rotateMix,a.translateMix=a.data.translateMix;return;case et.first:a.rotateMix+=(a.data.rotateMix-a.rotateMix)*r,a.translateMix+=(a.data.translateMix-a.translateMix)*r}return}let o=0,d=0;if(s>=i[i.length-Xs.ENTRIES])o=i[i.length+Xs.PREV_ROTATE],d=i[i.length+Xs.PREV_TRANSLATE];else{const f=$e.binarySearch(i,s,Xs.ENTRIES);o=i[f+Xs.PREV_ROTATE],d=i[f+Xs.PREV_TRANSLATE];const m=i[f],l=this.getCurvePercent(f/Xs.ENTRIES-1,1-(s-m)/(i[f+Xs.PREV_TIME]-m));o+=(i[f+Xs.ROTATE]-o)*l,d+=(i[f+Xs.TRANSLATE]-d)*l}c==et.setup?(a.rotateMix=a.data.rotateMix+(o-a.data.rotateMix)*r,a.translateMix=a.data.translateMix+(d-a.data.translateMix)*r):(a.rotateMix+=(o-a.rotateMix)*r,a.translateMix+=(d-a.translateMix)*r)}};K(Di,"ENTRIES",3),K(Di,"PREV_TIME",-3),K(Di,"PREV_ROTATE",-2),K(Di,"PREV_TRANSLATE",-1),K(Di,"ROTATE",1),K(Di,"TRANSLATE",2);let ql=Di;var X0=Object.defineProperty,B0=(u,t,e)=>t in u?X0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ot=(u,t,e)=>B0(u,typeof t!="symbol"?t+"":t,e);const Sr=class Ke{constructor(t){ot(this,"data"),ot(this,"tracks",new Array),ot(this,"events",new Array),ot(this,"listeners",new Array),ot(this,"queue",new bu(this)),ot(this,"propertyIDs",new m0),ot(this,"animationsChanged",!1),ot(this,"timeScale",1),ot(this,"trackEntryPool",new tu(()=>new gu)),ot(this,"onComplete"),ot(this,"onEvent"),ot(this,"onStart"),ot(this,"onEnd"),this.data=t}update(t){t*=this.timeScale;const e=this.tracks;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r==null)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let c=t*r.timeScale;if(r.delay>0){if(r.delay-=c,r.delay>0)continue;c=-r.delay,r.delay=0}let h=r.next;if(h!=null){const i=r.trackLast-h.delay;if(i>=0){for(h.delay=0,h.trackTime=r.timeScale==0?0:(i/r.timeScale+t)*h.timeScale,r.trackTime+=c,this.setCurrent(s,h,!0);h.mixingFrom!=null;)h.mixTime+=t,h=h.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&r.mixingFrom==null){e[s]=null,this.queue.end(r),this.disposeNext(r);continue}if(r.mixingFrom!=null&&this.updateMixingFrom(r,t)){let i=r.mixingFrom;for(r.mixingFrom=null,i!=null&&(i.mixingTo=null);i!=null;)this.queue.end(i),i=i.mixingFrom}r.trackTime+=c}this.queue.drain()}updateMixingFrom(t,e){const s=t.mixingFrom;if(s==null)return!0;const n=this.updateMixingFrom(s,e);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?((s.totalAlpha==0||t.mixDuration==0)&&(t.mixingFrom=s.mixingFrom,s.mixingFrom!=null&&(s.mixingFrom.mixingTo=t),t.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=e*s.timeScale,t.mixTime+=e,!1)}apply(t){if(t==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,s=this.tracks;let n=!1;for(let r=0,c=s.length;r<c;r++){const h=s[r];if(h==null||h.delay>0)continue;n=!0;const i=r==0?et.first:h.mixBlend;let a=h.alpha;h.mixingFrom!=null?a*=this.applyMixingFrom(h,t,i):h.trackTime>=h.trackEnd&&h.next==null&&(a=0);const o=h.animationLast,d=h.getAnimationTime(),f=h.animation.timelines.length,m=h.animation.timelines;if(r==0&&a==1||i==et.add)for(let l=0;l<f;l++)pt.webkit602BugfixHelper(a,i),m[l].apply(t,o,d,e,a,i,Ps.mixIn);else{const l=h.timelineMode,g=h.timelinesRotation.length==0;g&&pt.setArraySize(h.timelinesRotation,f<<1,null);const p=h.timelinesRotation;for(let y=0;y<f;y++){const w=m[y],b=l[y]==Ke.SUBSEQUENT?i:et.setup;w instanceof yn?this.applyRotateTimeline(w,t,d,a,b,p,y<<1,g):(pt.webkit602BugfixHelper(a,i),w.apply(t,o,d,e,a,b,Ps.mixIn))}}this.queueEvents(h,d),e.length=0,h.nextAnimationLast=d,h.nextTrackLast=h.trackTime}return this.queue.drain(),n}applyMixingFrom(t,e,s){const n=t.mixingFrom;n.mixingFrom!=null&&this.applyMixingFrom(n,e,s);let r=0;t.mixDuration==0?(r=1,s==et.first&&(s=et.setup)):(r=t.mixTime/t.mixDuration,r>1&&(r=1),s!=et.first&&(s=n.mixBlend));const c=r<n.eventThreshold?this.events:null,h=r<n.attachmentThreshold,i=r<n.drawOrderThreshold,a=n.animationLast,o=n.getAnimationTime(),d=n.animation.timelines.length,f=n.animation.timelines,m=n.alpha*t.interruptAlpha,l=m*(1-r);if(s==et.add)for(let g=0;g<d;g++)f[g].apply(e,a,o,c,l,s,Ps.mixOut);else{const g=n.timelineMode,p=n.timelineHoldMix,y=n.timelinesRotation.length==0;y&&pt.setArraySize(n.timelinesRotation,d<<1,null);const w=n.timelinesRotation;n.totalAlpha=0;for(let b=0;b<d;b++){const x=f[b];let S=Ps.mixOut,C,A=0;switch(g[b]){case Ke.SUBSEQUENT:if(!h&&x instanceof Zo||!i&&x instanceof Qo)continue;C=s,A=l;break;case Ke.FIRST:C=et.setup,A=l;break;case Ke.HOLD:C=et.setup,A=m;break;default:C=et.setup;const v=p[b];A=m*Math.max(0,1-v.mixTime/v.mixDuration);break}n.totalAlpha+=A,x instanceof yn?this.applyRotateTimeline(x,e,o,A,C,w,b<<1,y):(pt.webkit602BugfixHelper(A,s),C==et.setup&&(x instanceof Zo?h&&(S=Ps.mixOut):x instanceof Qo&&i&&(S=Ps.mixOut)),x.apply(e,a,o,c,A,C,S))}}return t.mixDuration>0&&this.queueEvents(n,o),this.events.length=0,n.nextAnimationLast=o,n.nextTrackLast=n.trackTime,r}applyRotateTimeline(t,e,s,n,r,c,h,i){if(i&&(c[h]=0),n==1){t.apply(e,0,s,null,1,r,Ps.mixIn);return}const a=t,o=a.frames,d=e.bones[a.boneIndex];let f=0,m=0;if(s<o[0])switch(r){case et.setup:d.rotation=d.data.rotation;default:return;case et.first:f=d.rotation,m=d.data.rotation}else if(f=r==et.setup?d.data.rotation:d.rotation,s>=o[o.length-yn.ENTRIES])m=d.data.rotation+o[o.length+yn.PREV_ROTATION];else{const p=$e.binarySearch(o,s,yn.ENTRIES),y=o[p+yn.PREV_ROTATION],w=o[p],b=a.getCurvePercent((p>>1)-1,1-(s-w)/(o[p+yn.PREV_TIME]-w));m=o[p+yn.ROTATION]-y,m-=(16384-(16384.499999999996-m/360|0))*360,m=y+m*b+d.data.rotation,m-=(16384-(16384.499999999996-m/360|0))*360}let l=0,g=m-f;if(g-=(16384-(16384.499999999996-g/360|0))*360,g==0)l=c[h];else{let p=0,y=0;i?(p=0,y=g):(p=c[h],y=c[h+1]);const w=g>0;let b=p>=0;j.signum(y)!=j.signum(g)&&Math.abs(y)<=90&&(Math.abs(p)>180&&(p+=360*j.signum(p)),b=w),l=g+p-p%360,b!=w&&(l+=360*j.signum(p)),c[h]=l}c[h+1]=g,f+=l*n,d.rotation=f-(16384-(16384.499999999996-f/360|0))*360}queueEvents(t,e){const s=t.animationStart,n=t.animationEnd,r=n-s,c=t.trackLast%r,h=this.events;let i=0;const a=h.length;for(;i<a;i++){const d=h[i];if(d.time<c)break;d.time>n||this.queue.event(t,d)}let o=!1;for(t.loop?o=r==0||c>t.trackTime%r:o=e>=n&&t.animationLast<n,o&&this.queue.complete(t);i<a;i++)h[i].time<s||this.queue.event(t,h[i])}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,s=this.tracks.length;e<s;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(e==null)return;this.queue.end(e),this.disposeNext(e);let s=e;for(;;){const n=s.mixingFrom;if(n==null)break;this.queue.end(n),s.mixingFrom=null,s.mixingTo=null,s=n}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,s){const n=this.expandToIndex(t);this.tracks[t]=e,n!=null&&(s&&this.queue.interrupt(n),e.mixingFrom=n,n.mixingTo=e,e.mixTime=0,n.mixingFrom!=null&&n.mixDuration>0&&(e.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,s){const n=this.data.skeletonData.findAnimation(e);if(n==null)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,n,s)}setAnimationWith(t,e,s){if(e==null)throw new Error("animation cannot be null.");let n=!0,r=this.expandToIndex(t);r!=null&&(r.nextTrackLast==-1?(this.tracks[t]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.disposeNext(r),r=r.mixingFrom,n=!1):this.disposeNext(r));const c=this.trackEntry(t,e,s,r);return this.setCurrent(t,c,n),this.queue.drain(),c}addAnimation(t,e,s,n){const r=this.data.skeletonData.findAnimation(e);if(r==null)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,r,s,n)}addAnimationWith(t,e,s,n){if(e==null)throw new Error("animation cannot be null.");let r=this.expandToIndex(t);if(r!=null)for(;r.next!=null;)r=r.next;const c=this.trackEntry(t,e,s,r);if(r==null)this.setCurrent(t,c,!0),this.queue.drain();else if(r.next=c,n<=0){const h=r.animationEnd-r.animationStart;h!=0?(r.loop?n+=h*(1+(r.trackTime/h|0)):n+=Math.max(h,r.trackTime),n-=this.data.getMix(r.animation,e)):n=r.trackTime}return c.delay=n,c}setEmptyAnimation(t,e){const s=this.setAnimationWith(t,Ke.emptyAnimation,!1);return s.mixDuration=e,s.trackEnd=e,s}addEmptyAnimation(t,e,s){s<=0&&(s-=e);const n=this.addAnimationWith(t,Ke.emptyAnimation,!1,s);return n.mixDuration=e,n.trackEnd=e,n}setEmptyAnimations(t){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,n=this.tracks.length;s<n;s++){const r=this.tracks[s];r!=null&&this.setEmptyAnimation(r.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(pt.ensureArrayCapacity(this.tracks,t-this.tracks.length+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,s,n){const r=this.trackEntryPool.obtain();return r.trackIndex=t,r.animation=e,r.loop=s,r.holdPrevious=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=e.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.interruptAlpha=1,r.mixTime=0,r.mixDuration=n==null?0:this.data.getMix(n.animation,e),r}disposeNext(t){let e=t.next;for(;e!=null;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let t=0,e=this.tracks.length;t<e;t++){let s=this.tracks[t];if(s!=null){for(;s.mixingFrom!=null;)s=s.mixingFrom;do(s.mixingFrom==null||s.mixBlend!=et.add)&&this.setTimelineModes(s),s=s.mixingTo;while(s!=null)}}}setTimelineModes(t){const e=t.mixingTo,s=t.animation.timelines,n=t.animation.timelines.length,r=pt.setArraySize(t.timelineMode,n);t.timelineHoldMix.length=0;const c=pt.setArraySize(t.timelineHoldMix,n),h=this.propertyIDs;if(e!=null&&e.holdPrevious){for(let i=0;i<n;i++)h.add(s[i].getPropertyId()),r[i]=Ke.HOLD;return}t:for(let i=0;i<n;i++){const a=s[i].getPropertyId();if(!h.add(a))r[i]=Ke.SUBSEQUENT;else if(e==null||!this.hasTimeline(e,a))r[i]=Ke.FIRST;else{for(let o=e.mixingTo;o!=null;o=o.mixingTo)if(!this.hasTimeline(o,a)){if(t.mixDuration>0){r[i]=Ke.HOLD_MIX,c[i]=o;continue t}break}r[i]=Ke.HOLD}}}hasTimeline(t,e){const s=t.animation.timelines;for(let n=0,r=s.length;n<r;n++)if(s[n].getPropertyId()==e)return!0;return!1}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(t==null)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,e,s){Ke.deprecatedWarning1||(Ke.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,e,s)}addAnimationByName(t,e,s,n){Ke.deprecatedWarning2||(Ke.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,e,s,n)}hasAnimation(t){return this.data.skeletonData.findAnimation(t)!==null}hasAnimationByName(t){return Ke.deprecatedWarning3||(Ke.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};ot(Sr,"emptyAnimation",new $e("<empty>",[],0)),ot(Sr,"SUBSEQUENT",0),ot(Sr,"FIRST",1),ot(Sr,"HOLD",2),ot(Sr,"HOLD_MIX",3),ot(Sr,"deprecatedWarning1",!1),ot(Sr,"deprecatedWarning2",!1),ot(Sr,"deprecatedWarning3",!1);let mu=Sr;const Gl=class Dr{constructor(){ot(this,"animation"),ot(this,"next"),ot(this,"mixingFrom"),ot(this,"mixingTo"),ot(this,"listener"),ot(this,"trackIndex"),ot(this,"loop"),ot(this,"holdPrevious"),ot(this,"eventThreshold"),ot(this,"attachmentThreshold"),ot(this,"drawOrderThreshold"),ot(this,"animationStart"),ot(this,"animationEnd"),ot(this,"animationLast"),ot(this,"nextAnimationLast"),ot(this,"delay"),ot(this,"trackTime"),ot(this,"trackLast"),ot(this,"nextTrackLast"),ot(this,"trackEnd"),ot(this,"timeScale"),ot(this,"alpha"),ot(this,"mixTime"),ot(this,"mixDuration"),ot(this,"interruptAlpha"),ot(this,"totalAlpha"),ot(this,"mixBlend",et.replace),ot(this,"timelineMode",new Array),ot(this,"timelineHoldMix",new Array),ot(this,"timelinesRotation",new Array),ot(this,"onComplete"),ot(this,"onEvent"),ot(this,"onStart"),ot(this,"onEnd")}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return Dr.deprecatedWarning1||(Dr.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){Dr.deprecatedWarning1||(Dr.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return Dr.deprecatedWarning2||(Dr.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){Dr.deprecatedWarning2||(Dr.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};ot(Gl,"deprecatedWarning1",!1),ot(Gl,"deprecatedWarning2",!1);let gu=Gl;const pu=class Fd{constructor(t){ot(this,"objects",[]),ot(this,"drainDisabled",!1),ot(this,"animState"),this.animState=t}start(t){this.objects.push(0),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(1),this.objects.push(t)}end(t){this.objects.push(2),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(3),this.objects.push(t)}complete(t){this.objects.push(4),this.objects.push(t)}event(t,e){this.objects.push(5),this.objects.push(t),this.objects.push(e)}deprecateStuff(){return Fd.deprecatedWarning1||(Fd.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let s=0;s<t.length;s+=2){const n=t[s],r=t[s+1];switch(n){case 0:r.listener!=null&&r.listener.start&&r.listener.start(r);for(let i=0;i<e.length;i++)e[i].start&&e[i].start(r);r.onStart&&this.deprecateStuff()&&r.onStart(r.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(r.trackIndex);break;case 1:r.listener!=null&&r.listener.interrupt&&r.listener.interrupt(r);for(let i=0;i<e.length;i++)e[i].interrupt&&e[i].interrupt(r);break;case 2:r.listener!=null&&r.listener.end&&r.listener.end(r);for(let i=0;i<e.length;i++)e[i].end&&e[i].end(r);r.onEnd&&this.deprecateStuff()&&r.onEnd(r.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(r.trackIndex);case 3:r.listener!=null&&r.listener.dispose&&r.listener.dispose(r);for(let i=0;i<e.length;i++)e[i].dispose&&e[i].dispose(r);this.animState.trackEntryPool.free(r);break;case 4:r.listener!=null&&r.listener.complete&&r.listener.complete(r);for(let i=0;i<e.length;i++)e[i].complete&&e[i].complete(r);const c=j.toInt(r.loopsCount());r.onComplete&&this.deprecateStuff()&&r.onComplete(r.trackIndex,c),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(r.trackIndex,c);break;case 5:const h=t[s+++2];r.listener!=null&&r.listener.event&&r.listener.event(r,h);for(let i=0;i<e.length;i++)e[i].event&&e[i].event(r,h);r.onEvent&&this.deprecateStuff()&&r.onEvent(r.trackIndex,h),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(r.trackIndex,h);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};ot(pu,"deprecatedWarning1",!1);let bu=pu;var xu=(u=>(u[u.start=0]="start",u[u.interrupt=1]="interrupt",u[u.end=2]="end",u[u.dispose=3]="dispose",u[u.complete=4]="complete",u[u.event=5]="event",u))(xu||{});class V0{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}}var N0=Object.defineProperty,D0=(u,t,e)=>t in u?N0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,jo=(u,t,e)=>D0(u,typeof t!="symbol"?t+"":t,e);const wu=class Yd{constructor(t){if(jo(this,"skeletonData"),jo(this,"animationToMixTime",{}),jo(this,"defaultMix",0),t==null)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,s){const n=this.skeletonData.findAnimation(t);if(n==null)throw new Error(`Animation not found: ${t}`);const r=this.skeletonData.findAnimation(e);if(r==null)throw new Error(`Animation not found: ${e}`);this.setMixWith(n,r,s)}setMixByName(t,e,s){Yd.deprecatedWarning1||(Yd.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(t,e,s)}setMixWith(t,e,s){if(t==null)throw new Error("from cannot be null.");if(e==null)throw new Error("to cannot be null.");const n=`${t.name}.${e.name}`;this.animationToMixTime[n]=s}getMix(t,e){const s=`${t.name}.${e.name}`,n=this.animationToMixTime[s];return n===void 0?this.defaultMix:n}};jo(wu,"deprecatedWarning1",!1);let yu=wu;var L0=Object.defineProperty,O0=(u,t,e)=>t in u?L0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Su=(u,t,e)=>O0(u,typeof t!="symbol"?t+"":t,e);let Cu=class extends Bi{constructor(t){super(t),Su(this,"type",Os.BoundingBox),Su(this,"color",new Cs(1,1,1,1))}};var W0=Object.defineProperty,U0=(u,t,e)=>t in u?W0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,zl=(u,t,e)=>U0(u,typeof t!="symbol"?t+"":t,e);let Au=class extends Bi{constructor(t){super(t),zl(this,"type",Os.Clipping),zl(this,"endSlot"),zl(this,"color",new Cs(.2275,.2275,.8078,1))}};var q0=Object.defineProperty,G0=(u,t,e)=>t in u?q0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,vn=(u,t,e)=>G0(u,typeof t!="symbol"?t+"":t,e);let Hl=class extends Bi{constructor(t){super(t),vn(this,"type",Os.Mesh),vn(this,"region"),vn(this,"path"),vn(this,"regionUVs"),vn(this,"uvs"),vn(this,"triangles"),vn(this,"color",new Cs(1,1,1,1)),vn(this,"hullLength"),vn(this,"parentMesh"),vn(this,"inheritDeform",!1),vn(this,"tempColor",new Cs(0,0,0,0))}applyDeform(t){return this==t||this.inheritDeform&&this.parentMesh==t}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}};var z0=Object.defineProperty,H0=(u,t,e)=>t in u?z0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,to=(u,t,e)=>H0(u,typeof t!="symbol"?t+"":t,e);let eo=class extends Bi{constructor(t){super(t),to(this,"type",Os.Path),to(this,"lengths"),to(this,"closed",!1),to(this,"constantSpeed",!1),to(this,"color",new Cs(1,1,1,1))}};var K0=Object.defineProperty,Z0=(u,t,e)=>t in u?K0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,so=(u,t,e)=>Z0(u,typeof t!="symbol"?t+"":t,e);let vu=class extends Bi{constructor(t){super(t),so(this,"type",Os.Point),so(this,"x"),so(this,"y"),so(this,"rotation"),so(this,"color",new Cs(.38,.94,0,1))}computeWorldPosition(t,e){const s=t.matrix;return e.x=this.x*s.a+this.y*s.c+t.worldX,e.y=this.x*s.b+this.y*s.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,s=j.cosDeg(this.rotation),n=j.sinDeg(this.rotation),r=s*e.a+n*e.c,c=s*e.b+n*e.d;return Math.atan2(c,r)*j.radDeg}};var Q0=Object.defineProperty,J0=(u,t,e)=>t in u?Q0(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,j0=(u,t,e)=>J0(u,typeof t!="symbol"?t+"":t,e);let Mu=class{constructor(t){j0(this,"atlas"),this.atlas=t}newRegionAttachment(t,e,s){const n=this.atlas.findRegion(s);if(n==null)throw new Error(`Region not found in atlas: ${s} (region attachment: ${e})`);const r=new Dl(e);return r.region=n,r}newMeshAttachment(t,e,s){const n=this.atlas.findRegion(s);if(n==null)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${e})`);const r=new Hl(e);return r.region=n,r}newBoundingBoxAttachment(t,e){return new Cu(e)}newPathAttachment(t,e){return new eo(e)}newPointAttachment(t,e){return new vu(e)}newClippingAttachment(t,e){return new Au(e)}};var Ca=(u=>(u[u.Fixed=0]="Fixed",u[u.Percent=1]="Percent",u))(Ca||{}),Li=(u=>(u[u.Tangent=0]="Tangent",u[u.Chain=1]="Chain",u[u.ChainScale=2]="ChainScale",u))(Li||{}),tb=Object.defineProperty,eb=(u,t,e)=>t in u?tb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,mn=(u,t,e)=>eb(u,typeof t!="symbol"?t+"":t,e);let Eu=class{constructor(t){mn(this,"name"),mn(this,"order",0),mn(this,"bones",new Array),mn(this,"target"),mn(this,"positionMode"),mn(this,"spacingMode"),mn(this,"rotateMode"),mn(this,"offsetRotation"),mn(this,"position"),mn(this,"spacing"),mn(this,"rotateMix"),mn(this,"translateMix"),this.name=t}};var Mn=(u=>(u[u.Length=0]="Length",u[u.Fixed=1]="Fixed",u[u.Percent=2]="Percent",u))(Mn||{}),sb=Object.defineProperty,nb=(u,t,e)=>t in u?sb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ns=(u,t,e)=>nb(u,typeof t!="symbol"?t+"":t,e);const no=class ya{constructor(t,e){if(ns(this,"data"),ns(this,"bones"),ns(this,"target"),ns(this,"position",0),ns(this,"spacing",0),ns(this,"rotateMix",0),ns(this,"translateMix",0),ns(this,"spaces",new Array),ns(this,"positions",new Array),ns(this,"world",new Array),ns(this,"curves",new Array),ns(this,"lengths",new Array),ns(this,"segments",new Array),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let s=0,n=t.bones.length;s<n;s++)this.bones.push(e.findBone(t.bones[s].name));this.target=e.findSlot(t.target.name),this.position=t.position,this.spacing=t.spacing,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix}apply(){this.update()}update(){const t=this.target.getAttachment();if(!(t instanceof eo))return;const e=this.rotateMix,s=this.translateMix,n=s>0,r=e>0;if(!n&&!r)return;const c=this.data,h=c.spacingMode,i=h==Mn.Length,a=c.rotateMode,o=a==Li.Tangent,d=a==Li.ChainScale,f=this.bones.length,m=o?f:f+1,l=this.bones,g=pt.setArraySize(this.spaces,m);let p=null;const y=this.spacing;if(d||i){d&&(p=pt.setArraySize(this.lengths,f));for(let A=0,v=m-1;A<v;){const M=l[A],E=M.data.length;if(E<ya.epsilon)d&&(p[A]=0),g[++A]=0;else{const T=E*M.matrix.a,R=E*M.matrix.b,k=Math.sqrt(T*T+R*R);d&&(p[A]=k),g[++A]=(i?E+y:y)*k/E}}}else for(let A=1;A<m;A++)g[A]=y;const w=this.computeWorldPositions(t,m,o,c.positionMode==Ca.Percent,h==Mn.Percent);let b=w[0],x=w[1],S=c.offsetRotation,C=!1;if(S==0)C=a==Li.Chain;else{C=!1;const A=this.target.bone.matrix;S*=A.a*A.d-A.b*A.c>0?j.degRad:-j.degRad}for(let A=0,v=3;A<f;A++,v+=3){const M=l[A],E=M.matrix;E.tx+=(b-E.tx)*s,E.ty+=(x-E.ty)*s;const T=w[v],R=w[v+1],k=T-b,I=R-x;if(d){const P=p[A];if(P!=0){const F=(Math.sqrt(k*k+I*I)/P-1)*e+1;E.a*=F,E.b*=F}}if(b=T,x=R,r){const P=E.a,F=E.c,X=E.b,W=E.d;let Y=0,_=0,O=0;if(o&&(o?Y=w[v-1]:g[A+1]==0?Y=w[v+2]:Y=Math.atan2(I,k)),Y-=Math.atan2(X,P),C){_=Math.cos(Y),O=Math.sin(Y);const z=M.data.length;b+=(z*(_*P-O*X)-k)*e,x+=(z*(O*P+_*X)-I)*e}else Y+=S;Y>j.PI?Y-=j.PI2:Y<-j.PI&&(Y+=j.PI2),Y*=e,_=Math.cos(Y),O=Math.sin(Y),E.a=_*P-O*X,E.c=_*F-O*W,E.b=O*P+_*X,E.d=O*F+_*W}M.appliedValid=!1}}computeWorldPositions(t,e,s,n,r){const c=this.target;let h=this.position;const i=this.spaces,a=pt.setArraySize(this.positions,e*3+2);let o=null;const d=t.closed;let f=t.worldVerticesLength,m=f/6,l=ya.NONE;if(!t.constantSpeed){const Y=t.lengths;m-=d?1:2;const _=Y[m];if(n&&(h*=_),r)for(let O=0;O<e;O++)i[O]*=_;o=pt.setArraySize(this.world,8);for(let O=0,z=0,$=0;O<e;O++,z+=3){const N=i[O];h+=N;let V=h;if(d)V%=_,V<0&&(V+=_),$=0;else if(V<0){l!=ya.BEFORE&&(l=ya.BEFORE,t.computeWorldVertices(c,2,4,o,0,2)),this.addBeforePosition(V,o,0,a,z);continue}else if(V>_){l!=ya.AFTER&&(l=ya.AFTER,t.computeWorldVertices(c,f-6,4,o,0,2)),this.addAfterPosition(V-_,o,0,a,z);continue}for(;;$++){const rt=Y[$];if(!(V>rt)){if($==0)V/=rt;else{const gt=Y[$-1];V=(V-gt)/(rt-gt)}break}}$!=l&&(l=$,d&&$==m?(t.computeWorldVertices(c,f-4,4,o,0,2),t.computeWorldVertices(c,0,4,o,4,2)):t.computeWorldVertices(c,$*6+2,8,o,0,2)),this.addCurvePosition(V,o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7],a,z,s||O>0&&N==0)}return a}d?(f+=2,o=pt.setArraySize(this.world,f),t.computeWorldVertices(c,2,f-4,o,0,2),t.computeWorldVertices(c,0,2,o,f-4,2),o[f-2]=o[0],o[f-1]=o[1]):(m--,f-=4,o=pt.setArraySize(this.world,f),t.computeWorldVertices(c,2,f,o,0,2));const g=pt.setArraySize(this.curves,m);let p=0,y=o[0],w=o[1],b=0,x=0,S=0,C=0,A=0,v=0,M=0,E=0,T=0,R=0,k=0,I=0,P=0,F=0;for(let Y=0,_=2;Y<m;Y++,_+=6)b=o[_],x=o[_+1],S=o[_+2],C=o[_+3],A=o[_+4],v=o[_+5],M=(y-b*2+S)*.1875,E=(w-x*2+C)*.1875,T=((b-S)*3-y+A)*.09375,R=((x-C)*3-w+v)*.09375,k=M*2+T,I=E*2+R,P=(b-y)*.75+M+T*.16666667,F=(x-w)*.75+E+R*.16666667,p+=Math.sqrt(P*P+F*F),P+=k,F+=I,k+=T,I+=R,p+=Math.sqrt(P*P+F*F),P+=k,F+=I,p+=Math.sqrt(P*P+F*F),P+=k+T,F+=I+R,p+=Math.sqrt(P*P+F*F),g[Y]=p,y=A,w=v;if(n&&(h*=p),r)for(let Y=0;Y<e;Y++)i[Y]*=p;const X=this.segments;let W=0;for(let Y=0,_=0,O=0,z=0;Y<e;Y++,_+=3){const $=i[Y];h+=$;let N=h;if(d)N%=p,N<0&&(N+=p),O=0;else if(N<0){this.addBeforePosition(N,o,0,a,_);continue}else if(N>p){this.addAfterPosition(N-p,o,f-4,a,_);continue}for(;;O++){const V=g[O];if(!(N>V)){if(O==0)N/=V;else{const rt=g[O-1];N=(N-rt)/(V-rt)}break}}if(O!=l){l=O;let V=O*6;for(y=o[V],w=o[V+1],b=o[V+2],x=o[V+3],S=o[V+4],C=o[V+5],A=o[V+6],v=o[V+7],M=(y-b*2+S)*.03,E=(w-x*2+C)*.03,T=((b-S)*3-y+A)*.006,R=((x-C)*3-w+v)*.006,k=M*2+T,I=E*2+R,P=(b-y)*.3+M+T*.16666667,F=(x-w)*.3+E+R*.16666667,W=Math.sqrt(P*P+F*F),X[0]=W,V=1;V<8;V++)P+=k,F+=I,k+=T,I+=R,W+=Math.sqrt(P*P+F*F),X[V]=W;P+=k,F+=I,W+=Math.sqrt(P*P+F*F),X[8]=W,P+=k+T,F+=I+R,W+=Math.sqrt(P*P+F*F),X[9]=W,z=0}for(N*=W;;z++){const V=X[z];if(!(N>V)){if(z==0)N/=V;else{const rt=X[z-1];N=z+(N-rt)/(V-rt)}break}}this.addCurvePosition(N*.1,y,w,b,x,S,C,A,v,a,_,s||Y>0&&$==0)}return a}addBeforePosition(t,e,s,n,r){const c=e[s],h=e[s+1],i=e[s+2]-c,a=e[s+3]-h,o=Math.atan2(a,i);n[r]=c+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addAfterPosition(t,e,s,n,r){const c=e[s+2],h=e[s+3],i=c-e[s],a=h-e[s+1],o=Math.atan2(a,i);n[r]=c+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addCurvePosition(t,e,s,n,r,c,h,i,a,o,d,f){(t==0||isNaN(t))&&(t=1e-4);const m=t*t,l=m*t,g=1-t,p=g*g,y=p*g,w=g*t,b=w*3,x=g*b,S=b*t,C=e*y+n*x+c*S+i*l,A=s*y+r*x+h*S+a*l;o[d]=C,o[d+1]=A,f&&(o[d+2]=Math.atan2(A-(s*p+r*w*2+h*m),C-(e*p+n*w*2+c*m)))}getOrder(){return this.data.order}};ns(no,"NONE",-1),ns(no,"BEFORE",-2),ns(no,"AFTER",-3),ns(no,"epsilon",1e-5);let Tu=no;var rb=Object.defineProperty,ib=(u,t,e)=>t in u?rb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ue=(u,t,e)=>ib(u,typeof t!="symbol"?t+"":t,e);let Kl=class{constructor(t,e,s){if(ue(this,"matrix",new G.Matrix),ue(this,"data"),ue(this,"skeleton"),ue(this,"parent"),ue(this,"children",new Array),ue(this,"x",0),ue(this,"y",0),ue(this,"rotation",0),ue(this,"scaleX",0),ue(this,"scaleY",0),ue(this,"shearX",0),ue(this,"shearY",0),ue(this,"ax",0),ue(this,"ay",0),ue(this,"arotation",0),ue(this,"ascaleX",0),ue(this,"ascaleY",0),ue(this,"ashearX",0),ue(this,"ashearY",0),ue(this,"appliedValid",!1),ue(this,"sorted",!1),ue(this,"active",!0),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=s,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,s,n,r,c,h){this.ax=t,this.ay=e,this.arotation=s,this.ascaleX=n,this.ascaleY=r,this.ashearX=c,this.ashearY=h,this.appliedValid=!0;const i=this.parent,a=this.matrix,o=this.skeleton.scaleX,d=-this.skeleton.scaleY;if(i==null){const p=this.skeleton,y=s+90+h;a.a=j.cosDeg(s+c)*n*o,a.c=j.cosDeg(y)*r*o,a.b=j.sinDeg(s+c)*n*d,a.d=j.sinDeg(y)*r*d,a.tx=t*o+p.x,a.ty=e*d+p.y;return}let f=i.matrix.a,m=i.matrix.c,l=i.matrix.b,g=i.matrix.d;switch(a.tx=f*t+m*e+i.matrix.tx,a.ty=l*t+g*e+i.matrix.ty,this.data.transformMode){case nn.Normal:{const p=s+90+h,y=j.cosDeg(s+c)*n,w=j.cosDeg(p)*r,b=j.sinDeg(s+c)*n,x=j.sinDeg(p)*r;a.a=f*y+m*b,a.c=f*w+m*x,a.b=l*y+g*b,a.d=l*w+g*x;return}case nn.OnlyTranslation:{const p=s+90+h;a.a=j.cosDeg(s+c)*n,a.c=j.cosDeg(p)*r,a.b=j.sinDeg(s+c)*n,a.d=j.sinDeg(p)*r;break}case nn.NoRotationOrReflection:{let p=f*f+l*l,y=0;p>1e-4?(p=Math.abs(f*g-m*l)/p,m=l*p,g=f*p,y=Math.atan2(l,f)*j.radDeg):(f=0,l=0,y=90-Math.atan2(g,m)*j.radDeg);const w=s+c-y,b=s+h-y+90,x=j.cosDeg(w)*n,S=j.cosDeg(b)*r,C=j.sinDeg(w)*n,A=j.sinDeg(b)*r;a.a=f*x-m*C,a.c=f*S-m*A,a.b=l*x+g*C,a.d=l*S+g*A;break}case nn.NoScale:case nn.NoScaleOrReflection:{const p=j.cosDeg(s),y=j.sinDeg(s);let w=(f*p+m*y)/o,b=(l*p+g*y)/d,x=Math.sqrt(w*w+b*b);x>1e-5&&(x=1/x),w*=x,b*=x,x=Math.sqrt(w*w+b*b),this.data.transformMode==nn.NoScale&&f*g-m*l<0!=(this.skeleton.scaleX<0!=this.skeleton.scaleY>0)&&(x=-x);const S=Math.PI/2+Math.atan2(b,w),C=Math.cos(S)*x,A=Math.sin(S)*x,v=j.cosDeg(c)*n,M=j.cosDeg(90+h)*r,E=j.sinDeg(c)*n,T=j.sinDeg(90+h)*r;a.a=w*v+C*E,a.c=w*M+C*T,a.b=b*v+A*E,a.d=b*M+A*T;break}}a.a*=o,a.c*=o,a.b*=d,a.d*=d}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*j.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*j.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,e=this.matrix;if(t==null){this.ax=e.tx,this.ay=e.ty,this.arotation=Math.atan2(e.b,e.a)*j.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*j.radDeg;return}const s=t.matrix,n=1/(s.a*s.d-s.b*s.c),r=e.tx-s.tx,c=e.ty-s.ty;this.ax=r*s.d*n-c*s.c*n,this.ay=c*s.a*n-r*s.b*n;const h=n*s.d,i=n*s.a,a=n*s.c,o=n*s.b,d=h*e.a-a*e.b,f=h*e.c-a*e.d,m=i*e.b-o*e.a,l=i*e.d-o*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(d*d+m*m),this.ascaleX>1e-4){const g=d*l-f*m;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(d*f+m*l,g)*j.radDeg,this.arotation=Math.atan2(m,d)*j.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(f*f+l*l),this.ashearY=0,this.arotation=90-Math.atan2(l,f)*j.radDeg}worldToLocal(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,c=e.d,h=1/(s*c-n*r),i=t.x-e.tx,a=t.y-e.ty;return t.x=i*c*h-a*n*h,t.y=a*s*h-i*r*h,t}localToWorld(t){const e=this.matrix,s=t.x,n=t.y;return t.x=s*e.a+n*e.c+e.tx,t.y=s*e.b+n*e.d+e.ty,t}worldToLocalRotation(t){const e=j.sinDeg(t),s=j.cosDeg(t),n=this.matrix;return Math.atan2(n.a*e-n.b*s,n.d*s-n.c*e)*j.radDeg}localToWorldRotation(t){const e=j.sinDeg(t),s=j.cosDeg(t),n=this.matrix;return Math.atan2(s*n.b+e*n.d,s*n.a+e*n.c)*j.radDeg}rotateWorld(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,c=e.d,h=j.cosDeg(t),i=j.sinDeg(t);e.a=h*s-i*r,e.c=h*n-i*c,e.b=i*s+h*r,e.d=i*n+h*c,this.appliedValid=!1}};var ab=Object.defineProperty,ob=(u,t,e)=>t in u?ab(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Oi=(u,t,e)=>ob(u,typeof t!="symbol"?t+"":t,e);let Iu=class{constructor(t,e){if(Oi(this,"data"),Oi(this,"bones"),Oi(this,"target"),Oi(this,"bendDirection",0),Oi(this,"compress",!1),Oi(this,"stretch",!1),Oi(this,"mix",1),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(e.findBone(t.bones[s].name));this.target=e.findBone(t.target.name)}getOrder(){return this.data.order}apply(){this.update()}update(){const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.mix);break}}apply1(t,e,s,n,r,c,h){t.appliedValid||t.updateAppliedTransform();const i=t.parent.matrix,a=1/(i.a*i.d-i.b*i.c),o=e-i.tx,d=s-i.ty,f=(o*i.d-d*i.c)*a-t.ax,m=(d*i.a-o*i.b)*a-t.ay;let l=Math.atan2(m,f)*j.radDeg-t.ashearX-t.arotation;t.ascaleX<0&&(l+=180),l>180?l-=360:l<-180&&(l+=360);let g=t.ascaleX,p=t.ascaleY;if(n||r){const y=t.data.length*g,w=Math.sqrt(f*f+m*m);if(n&&w<y||r&&w>y&&y>1e-4){const b=(w/y-1)*h+1;g*=b,c&&(p*=b)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+l*h,g,p,t.ashearX,t.ashearY)}apply2(t,e,s,n,r,c,h){if(h==0){e.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),e.appliedValid||e.updateAppliedTransform();const i=t.ax,a=t.ay;let o=t.ascaleX,d=o,f=t.ascaleY,m=e.ascaleX;const l=t.matrix;let g=0,p=0,y=0;o<0?(o=-o,g=180,y=-1):(g=0,y=1),f<0&&(f=-f,y=-y),m<0?(m=-m,p=180):p=0;const w=e.ax;let b=0,x=0,S=0,C=l.a,A=l.c,v=l.b,M=l.d;const E=Math.abs(o-f)<=1e-4;E?(b=e.ay,x=C*w+A*b+l.tx,S=v*w+M*b+l.ty):(b=0,x=C*w+l.tx,S=v*w+l.ty);const T=t.parent.matrix;C=T.a,A=T.c,v=T.b,M=T.d;const R=1/(C*M-A*v);let k=s-T.tx,I=n-T.ty;const P=(k*M-I*A)*R-i,F=(I*C-k*v)*R-a,X=P*P+F*F;k=x-T.tx,I=S-T.ty;const W=(k*M-I*A)*R-i,Y=(I*C-k*v)*R-a,_=Math.sqrt(W*W+Y*Y);let O=e.data.length*m,z=0,$=0;t:if(E){O*=o;let rt=(X-_*_-O*O)/(2*_*O);rt<-1?rt=-1:rt>1&&(rt=1,c&&_+O>1e-4&&(d*=(Math.sqrt(X)/(_+O)-1)*h+1)),$=Math.acos(rt)*r,C=_+O*rt,A=O*Math.sin($),z=Math.atan2(F*C-P*A,P*C+F*A)}else{C=o*O,A=f*O;const rt=C*C,gt=A*A,yt=Math.atan2(F,P);v=gt*_*_+rt*X-rt*gt;const lt=-2*gt*_,At=gt-rt;if(M=lt*lt-4*At*v,M>=0){let ae=Math.sqrt(M);lt<0&&(ae=-ae),ae=-(lt+ae)/2;const Fe=ae/At,He=v/ae,Qt=Math.abs(Fe)<Math.abs(He)?Fe:He;if(Qt*Qt<=X){I=Math.sqrt(X-Qt*Qt)*r,z=yt-Math.atan2(I,Qt),$=Math.atan2(I/f,(Qt-_)/o);break t}}let Ot=j.PI,ie=_-C,bs=ie*ie,xs=0,Le=0,ze=_+C,ws=ze*ze,ys=0;v=-C*_/(rt-gt),v>=-1&&v<=1&&(v=Math.acos(v),k=C*Math.cos(v)+_,I=A*Math.sin(v),M=k*k+I*I,M<bs&&(Ot=v,bs=M,ie=k,xs=I),M>ws&&(Le=v,ws=M,ze=k,ys=I)),X<=(bs+ws)/2?(z=yt-Math.atan2(xs*r,ie),$=Ot*r):(z=yt-Math.atan2(ys*r,ze),$=Le*r)}const N=Math.atan2(b,w)*y;let V=t.arotation;z=(z-N)*j.radDeg+g-V,z>180?z-=360:z<-180&&(z+=360),t.updateWorldTransformWith(i,a,V+z*h,d,t.ascaleY,0,0),V=e.arotation,$=(($+N)*j.radDeg-e.ashearX)*y+p-V,$>180?$-=360:$<-180&&($+=360),e.updateWorldTransformWith(w,b,V+$*h,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}};var lb=Object.defineProperty,cb=(u,t,e)=>t in u?lb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,jr=(u,t,e)=>cb(u,typeof t!="symbol"?t+"":t,e);let Ru=class{constructor(t,e){if(jr(this,"data"),jr(this,"bones"),jr(this,"target"),jr(this,"rotateMix",0),jr(this,"translateMix",0),jr(this,"scaleMix",0),jr(this,"shearMix",0),jr(this,"temp",new x0),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(e.findBone(t.bones[s].name));this.target=e.findBone(t.target.name)}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target,c=r.matrix,h=c.a,i=c.c,a=c.b,o=c.d,d=h*o-i*a>0?j.degRad:-j.degRad,f=this.data.offsetRotation*d,m=this.data.offsetShearY*d,l=this.bones;for(let g=0,p=l.length;g<p;g++){const y=l[g];let w=!1;const b=y.matrix;if(t!=0){const x=b.a,S=b.c,C=b.b,A=b.d;let v=Math.atan2(a,h)-Math.atan2(C,x)+f;v>j.PI?v-=j.PI2:v<-j.PI&&(v+=j.PI2),v*=t;const M=Math.cos(v),E=Math.sin(v);b.a=M*x-E*C,b.c=M*S-E*A,b.b=E*x+M*C,b.d=E*S+M*A,w=!0}if(e!=0){const x=this.temp;r.localToWorld(x.set(this.data.offsetX,this.data.offsetY)),b.tx+=(x.x-b.tx)*e,b.ty+=(x.y-b.ty)*e,w=!0}if(s>0){let x=Math.sqrt(b.a*b.a+b.b*b.b),S=Math.sqrt(h*h+a*a);x>1e-5&&(x=(x+(S-x+this.data.offsetScaleX)*s)/x),b.a*=x,b.b*=x,x=Math.sqrt(b.c*b.c+b.d*b.d),S=Math.sqrt(i*i+o*o),x>1e-5&&(x=(x+(S-x+this.data.offsetScaleY)*s)/x),b.c*=x,b.d*=x,w=!0}if(n>0){const x=b.c,S=b.d,C=Math.atan2(S,x);let A=Math.atan2(o,i)-Math.atan2(a,h)-(C-Math.atan2(b.b,b.a));A>j.PI?A-=j.PI2:A<-j.PI&&(A+=j.PI2),A=C+(A+m)*n;const v=Math.sqrt(x*x+S*S);b.c=Math.cos(A)*v,b.d=Math.sin(A)*v,w=!0}w&&(y.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target,c=r.matrix,h=c.a,i=c.c,a=c.b,o=c.d,d=h*o-i*a>0?j.degRad:-j.degRad,f=this.data.offsetRotation*d,m=this.data.offsetShearY*d,l=this.bones;for(let g=0,p=l.length;g<p;g++){const y=l[g];let w=!1;const b=y.matrix;if(t!=0){const x=b.a,S=b.c,C=b.b,A=b.d;let v=Math.atan2(a,h)+f;v>j.PI?v-=j.PI2:v<-j.PI&&(v+=j.PI2),v*=t;const M=Math.cos(v),E=Math.sin(v);b.a=M*x-E*C,b.c=M*S-E*A,b.b=E*x+M*C,b.d=E*S+M*A,w=!0}if(e!=0){const x=this.temp;r.localToWorld(x.set(this.data.offsetX,this.data.offsetY)),b.tx+=x.x*e,b.ty+=x.y*e,w=!0}if(s>0){let x=(Math.sqrt(h*h+a*a)-1+this.data.offsetScaleX)*s+1;b.a*=x,b.b*=x,x=(Math.sqrt(i*i+o*o)-1+this.data.offsetScaleY)*s+1,b.c*=x,b.d*=x,w=!0}if(n>0){let x=Math.atan2(o,i)-Math.atan2(a,h);x>j.PI?x-=j.PI2:x<-j.PI&&(x+=j.PI2);const S=b.c,C=b.d;x=Math.atan2(C,S)+(x-j.PI/2+m)*n;const A=Math.sqrt(S*S+C*C);b.c=Math.cos(x)*A,b.d=Math.sin(x)*A,w=!0}w&&(y.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target;r.appliedValid||r.updateAppliedTransform();const c=this.bones;for(let h=0,i=c.length;h<i;h++){const a=c[h];a.appliedValid||a.updateAppliedTransform();let o=a.arotation;if(t!=0){let p=r.arotation-o+this.data.offsetRotation;p-=(16384-(16384.499999999996-p/360|0))*360,o+=p*t}let d=a.ax,f=a.ay;e!=0&&(d+=(r.ax-d+this.data.offsetX)*e,f+=(r.ay-f+this.data.offsetY)*e);let m=a.ascaleX,l=a.ascaleY;s>0&&(m>1e-5&&(m=(m+(r.ascaleX-m+this.data.offsetScaleX)*s)/m),l>1e-5&&(l=(l+(r.ascaleY-l+this.data.offsetScaleY)*s)/l));const g=a.ashearY;if(n>0){let p=r.ashearY-g+this.data.offsetShearY;p-=(16384-(16384.499999999996-p/360|0))*360,a.shearY+=p*n}a.updateWorldTransformWith(d,f,o,m,l,a.ashearX,g)}}applyRelativeLocal(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target;r.appliedValid||r.updateAppliedTransform();const c=this.bones;for(let h=0,i=c.length;h<i;h++){const a=c[h];a.appliedValid||a.updateAppliedTransform();let o=a.arotation;t!=0&&(o+=(r.arotation+this.data.offsetRotation)*t);let d=a.ax,f=a.ay;e!=0&&(d+=(r.ax+this.data.offsetX)*e,f+=(r.ay+this.data.offsetY)*e);let m=a.ascaleX,l=a.ascaleY;s>0&&(m>1e-5&&(m*=(r.ascaleX-1+this.data.offsetScaleX)*s+1),l>1e-5&&(l*=(r.ascaleY-1+this.data.offsetScaleY)*s+1));let g=a.ashearY;n>0&&(g+=(r.ashearY+this.data.offsetShearY)*n),a.updateWorldTransformWith(d,f,o,m,l,a.ashearX,g)}}getOrder(){return this.data.order}};var hb=Object.defineProperty,db=(u,t,e)=>t in u?hb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,rs=(u,t,e)=>db(u,typeof t!="symbol"?t+"":t,e);const Pu=class Lo{constructor(t){if(rs(this,"data"),rs(this,"bones"),rs(this,"slots"),rs(this,"drawOrder"),rs(this,"ikConstraints"),rs(this,"transformConstraints"),rs(this,"pathConstraints"),rs(this,"_updateCache",new Array),rs(this,"updateCacheReset",new Array),rs(this,"skin"),rs(this,"color"),rs(this,"time",0),rs(this,"scaleX",1),rs(this,"scaleY",1),rs(this,"x",0),rs(this,"y",0),t==null)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const s=t.bones[e];let n;if(s.parent==null)n=new Kl(s,this,null);else{const r=this.bones[s.parent.index];n=new Kl(s,this,r),r.children.push(n)}this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const s=t.slots[e],n=this.bones[s.boneData.index],r=new Nl(s,n);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const s=t.ikConstraints[e];this.ikConstraints.push(new Iu(s,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const s=t.transformConstraints[e];this.transformConstraints.push(new Ru(s,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const s=t.pathConstraints[e];this.pathConstraints.push(new Tu(s,this))}this.color=new Cs(1,1,1,1),this.updateCache()}updateCache(){const t=this._updateCache;t.length=0,this.updateCacheReset.length=0;const e=this.bones;for(let o=0,d=e.length;o<d;o++)e[o].sorted=!1;const s=this.ikConstraints,n=this.transformConstraints,r=this.pathConstraints,c=s.length,h=n.length,i=r.length,a=c+h+i;t:for(let o=0;o<a;o++){for(let d=0;d<c;d++){const f=s[d];if(f.data.order==o){this.sortIkConstraint(f);continue t}}for(let d=0;d<h;d++){const f=n[d];if(f.data.order==o){this.sortTransformConstraint(f);continue t}}for(let d=0;d<i;d++){const f=r[d];if(f.data.order==o){this.sortPathConstraint(f);continue t}}}for(let o=0,d=e.length;o<d;o++)this.sortBone(e[o])}sortIkConstraint(t){const e=t.target;this.sortBone(e);const s=t.bones,n=s[0];if(this.sortBone(n),s.length>1){const r=s[s.length-1];this._updateCache.indexOf(r)>-1||this.updateCacheReset.push(r)}this._updateCache.push(t),this.sortReset(n.children),s[s.length-1].sorted=!0}sortPathConstraint(t){const e=t.target,s=e.data.index,n=e.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,s,n),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,n);for(let i=0,a=this.data.skins.length;i<a;i++)this.sortPathConstraintAttachment(this.data.skins[i],s,n);const r=e.getAttachment();r instanceof eo&&this.sortPathConstraintAttachmentWith(r,n);const c=t.bones,h=c.length;for(let i=0;i<h;i++)this.sortBone(c[i]);this._updateCache.push(t);for(let i=0;i<h;i++)this.sortReset(c[i].children);for(let i=0;i<h;i++)c[i].sorted=!0}sortTransformConstraint(t){this.sortBone(t.target);const e=t.bones,s=e.length;if(t.data.local)for(let n=0;n<s;n++){const r=e[n];this.sortBone(r.parent),this._updateCache.indexOf(r)>-1||this.updateCacheReset.push(r)}else for(let n=0;n<s;n++)this.sortBone(e[n]);this._updateCache.push(t);for(let n=0;n<s;n++)this.sortReset(e[n].children);for(let n=0;n<s;n++)e[n].sorted=!0}sortPathConstraintAttachment(t,e,s){const n=t.attachments[e];if(n)for(const r in n)this.sortPathConstraintAttachmentWith(n[r],s)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof eo))return;const s=t.bones;if(s==null)this.sortBone(e);else{const n=this.bones;let r=0;for(;r<s.length;){const c=s[r++];for(let h=r+c;r<h;r++){const i=s[r];this.sortBone(n[i])}}}}sortBone(t){if(t.sorted)return;const e=t.parent;e!=null&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,s=t.length;e<s;e++){const n=t[e];n.sorted&&this.sortReset(n.children),n.sorted=!1}}updateWorldTransform(){const t=this.updateCacheReset;for(let s=0,n=t.length;s<n;s++){const r=t[s];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY,r.appliedValid=!0}const e=this._updateCache;for(let s=0,n=e.length;s<n;s++)e[s].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let r=0,c=t.length;r<c;r++)t[r].setToSetupPose();const e=this.ikConstraints;for(let r=0,c=e.length;r<c;r++){const h=e[r];h.bendDirection=h.data.bendDirection,h.mix=h.data.mix}const s=this.transformConstraints;for(let r=0,c=s.length;r<c;r++){const h=s[r],i=h.data;h.rotateMix=i.rotateMix,h.translateMix=i.translateMix,h.scaleMix=i.scaleMix,h.shearMix=i.shearMix}const n=this.pathConstraints;for(let r=0,c=n.length;r<c;r++){const h=n[r],i=h.data;h.position=i.position,h.spacing=i.spacing,h.rotateMix=i.rotateMix,h.translateMix=i.translateMix}}setSlotsToSetupPose(){const t=this.slots;pt.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,s=t.length;e<s;e++)t[e].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(e==null)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(t!=null)if(this.skin!=null)t.attachAll(this,this.skin);else{const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s],c=r.data.attachmentName;if(c!=null){const h=t.getAttachment(s,c);h!=null&&r.setAttachment(h)}}}this.skin=t}getAttachmentByName(t,e){return this.getAttachment(this.data.findSlotIndex(t),e)}getAttachment(t,e){if(e==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const s=this.skin.getAttachment(t,e);if(s!=null)return s}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(t==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,r=s.length;n<r;n++){const c=s[n];if(c.data.name==t){let h=null;if(e!=null&&(h=this.getAttachment(n,e),h==null))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);c.setAttachment(h);return}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}getBounds(t,e,s){if(t==null)throw new Error("offset cannot be null.");if(e==null)throw new Error("size cannot be null.");const n=this.drawOrder;let r=Number.POSITIVE_INFINITY,c=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY,i=Number.NEGATIVE_INFINITY;for(let a=0,o=n.length;a<o;a++){const d=n[a];let f=0,m=null;const l=d.getAttachment();if(l instanceof Dl)f=8,m=pt.setArraySize(s,f,0),l.computeWorldVertices(d.bone,m,0,2);else if(l instanceof Hl){const g=l;f=g.worldVerticesLength,m=pt.setArraySize(s,f,0),g.computeWorldVertices(d,0,f,m,0,2)}if(m!=null)for(let g=0,p=m.length;g<p;g+=2){const y=m[g],w=m[g+1];r=Math.min(r,y),c=Math.min(c,w),h=Math.max(h,y),i=Math.max(i,w)}}t.set(r,c),e.set(h-r,i-c)}update(t){this.time+=t}get flipX(){return this.scaleX==-1}set flipX(t){Lo.deprecatedWarning1||(Lo.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return this.scaleY==-1}set flipY(t){Lo.deprecatedWarning1||(Lo.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};rs(Pu,"deprecatedWarning1",!1);let ku=Pu;var ub=Object.defineProperty,fb=(u,t,e)=>t in u?ub(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Wi=(u,t,e)=>fb(u,typeof t!="symbol"?t+"":t,e);let Fu=class{constructor(t,e){if(Wi(this,"data"),Wi(this,"intValue"),Wi(this,"floatValue"),Wi(this,"stringValue"),Wi(this,"time"),Wi(this,"volume"),Wi(this,"balance"),e==null)throw new Error("data cannot be null.");this.time=t,this.data=e}};var mb=Object.defineProperty,gb=(u,t,e)=>t in u?mb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,As=(u,t,e)=>gb(u,typeof t!="symbol"?t+"":t,e);let Yu=class{constructor(){As(this,"name"),As(this,"bones",new Array),As(this,"slots",new Array),As(this,"skins",new Array),As(this,"defaultSkin"),As(this,"events",new Array),As(this,"animations",new Array),As(this,"ikConstraints",new Array),As(this,"transformConstraints",new Array),As(this,"pathConstraints",new Array),As(this,"width"),As(this,"height"),As(this,"version"),As(this,"hash"),As(this,"fps",0),As(this,"imagesPath")}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const e=this.skins;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const e=this.events;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const e=this.animations;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}};var pb=Object.defineProperty,bb=(u,t,e)=>t in u?pb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ui=(u,t,e)=>bb(u,typeof t!="symbol"?t+"":t,e);let $u=class{constructor(t,e,s){if(Ui(this,"index"),Ui(this,"name"),Ui(this,"boneData"),Ui(this,"color",new Cs(1,1,1,1)),Ui(this,"darkColor"),Ui(this,"attachmentName"),Ui(this,"blendMode"),t<0)throw new Error("index must be >= 0.");if(e==null)throw new Error("name cannot be null.");if(s==null)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=s}};var xb=Object.defineProperty,wb=(u,t,e)=>t in u?xb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,gn=(u,t,e)=>wb(u,typeof t!="symbol"?t+"":t,e);let _u=class{constructor(t,e,s){if(gn(this,"index"),gn(this,"name"),gn(this,"parent"),gn(this,"length"),gn(this,"x",0),gn(this,"y",0),gn(this,"rotation",0),gn(this,"scaleX",1),gn(this,"scaleY",1),gn(this,"shearX",0),gn(this,"shearY",0),gn(this,"transformMode",nn.Normal),t<0)throw new Error("index must be >= 0.");if(e==null)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=s}};var yb=Object.defineProperty,Sb=(u,t,e)=>t in u?yb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Cr=(u,t,e)=>Sb(u,typeof t!="symbol"?t+"":t,e);let Xu=class{constructor(t){Cr(this,"name"),Cr(this,"order",0),Cr(this,"bones",new Array),Cr(this,"target"),Cr(this,"bendDirection",1),Cr(this,"compress",!1),Cr(this,"stretch",!1),Cr(this,"uniform",!1),Cr(this,"mix",1),this.name=t}};var Cb=Object.defineProperty,Ab=(u,t,e)=>t in u?Cb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,vs=(u,t,e)=>Ab(u,typeof t!="symbol"?t+"":t,e);let Bu=class{constructor(t){if(vs(this,"name"),vs(this,"order",0),vs(this,"bones",new Array),vs(this,"target"),vs(this,"rotateMix",0),vs(this,"translateMix",0),vs(this,"scaleMix",0),vs(this,"shearMix",0),vs(this,"offsetRotation",0),vs(this,"offsetX",0),vs(this,"offsetY",0),vs(this,"offsetScaleX",0),vs(this,"offsetScaleY",0),vs(this,"offsetShearY",0),vs(this,"relative",!1),vs(this,"local",!1),t==null)throw new Error("name cannot be null.");this.name=t}};var vb=Object.defineProperty,Mb=(u,t,e)=>t in u?vb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Vu=(u,t,e)=>Mb(u,typeof t!="symbol"?t+"":t,e);let Nu=class{constructor(t){if(Vu(this,"name"),Vu(this,"attachments",new Array),t==null)throw new Error("name cannot be null.");this.name=t}addAttachment(t,e,s){if(s==null)throw new Error("attachment cannot be null.");const n=this.attachments;t>=n.length&&(n.length=t+1),n[t]||(n[t]={}),n[t][e]=s}getAttachment(t,e){const s=this.attachments[t];return s?s[e]:null}attachAll(t,e){let s=0;for(let n=0;n<t.slots.length;n++){const r=t.slots[n],c=r.getAttachment();if(c&&s<e.attachments.length){const h=e.attachments[s];for(const i in h){const a=h[i];if(c==a){const o=this.getAttachment(s,i);o!=null&&r.setAttachment(o);break}}}s++}}};var Eb=Object.defineProperty,Tb=(u,t,e)=>t in u?Eb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,qi=(u,t,e)=>Tb(u,typeof t!="symbol"?t+"":t,e);let Du=class{constructor(t){qi(this,"name"),qi(this,"intValue"),qi(this,"floatValue"),qi(this,"stringValue"),qi(this,"audioPath"),qi(this,"volume"),qi(this,"balance"),this.name=t}};var Ib=Object.defineProperty,Rb=(u,t,e)=>t in u?Ib(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Gi=(u,t,e)=>Rb(u,typeof t!="symbol"?t+"":t,e);let Lu=class Na{constructor(t){Gi(this,"attachmentLoader"),Gi(this,"scale",1),Gi(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new Yu,n=typeof t=="string"?JSON.parse(t):t,r=n.skeleton;if(r!=null&&(s.hash=r.hash,s.version=r.spine,s.width=r.width,s.height=r.height,s.fps=r.fps,s.imagesPath=r.images),n.bones)for(let c=0;c<n.bones.length;c++){const h=n.bones[c];let i=null;const a=this.getValue(h,"parent",null);if(a!=null&&(i=s.findBone(a),i==null))throw new Error(`Parent bone not found: ${a}`);const o=new _u(s.bones.length,h.name,i);o.length=this.getValue(h,"length",0)*e,o.x=this.getValue(h,"x",0)*e,o.y=this.getValue(h,"y",0)*e,o.rotation=this.getValue(h,"rotation",0),o.scaleX=this.getValue(h,"scaleX",1),o.scaleY=this.getValue(h,"scaleY",1),o.shearX=this.getValue(h,"shearX",0),o.shearY=this.getValue(h,"shearY",0),o.transformMode=Na.transformModeFromString(this.getValue(h,"transform","normal")),s.bones.push(o)}if(n.slots)for(let c=0;c<n.slots.length;c++){const h=n.slots[c],i=h.name,a=h.bone,o=s.findBone(a);if(o==null)throw new Error(`Slot bone not found: ${a}`);const d=new $u(s.slots.length,i,o),f=this.getValue(h,"color",null);f!=null&&d.color.setFromString(f);const m=this.getValue(h,"dark",null);m!=null&&(d.darkColor=new Cs(1,1,1,1),d.darkColor.setFromString(m)),d.attachmentName=this.getValue(h,"attachment",null),d.blendMode=Na.blendModeFromString(this.getValue(h,"blend","normal")),s.slots.push(d)}if(n.ik)for(let c=0;c<n.ik.length;c++){const h=n.ik[c],i=new Xu(h.name);i.order=this.getValue(h,"order",0);for(let o=0;o<h.bones.length;o++){const d=h.bones[o],f=s.findBone(d);if(f==null)throw new Error(`IK bone not found: ${d}`);i.bones.push(f)}const a=h.target;if(i.target=s.findBone(a),i.target==null)throw new Error(`IK target bone not found: ${a}`);i.bendDirection=this.getValue(h,"bendPositive",!0)?1:-1,i.mix=this.getValue(h,"mix",1),s.ikConstraints.push(i)}if(n.transform)for(let c=0;c<n.transform.length;c++){const h=n.transform[c],i=new Bu(h.name);i.order=this.getValue(h,"order",0);for(let o=0;o<h.bones.length;o++){const d=h.bones[o],f=s.findBone(d);if(f==null)throw new Error(`Transform constraint bone not found: ${d}`);i.bones.push(f)}const a=h.target;if(i.target=s.findBone(a),i.target==null)throw new Error(`Transform constraint target bone not found: ${a}`);i.local=this.getValue(h,"local",!1),i.relative=this.getValue(h,"relative",!1),i.offsetRotation=this.getValue(h,"rotation",0),i.offsetX=this.getValue(h,"x",0)*e,i.offsetY=this.getValue(h,"y",0)*e,i.offsetScaleX=this.getValue(h,"scaleX",0),i.offsetScaleY=this.getValue(h,"scaleY",0),i.offsetShearY=this.getValue(h,"shearY",0),i.rotateMix=this.getValue(h,"rotateMix",1),i.translateMix=this.getValue(h,"translateMix",1),i.scaleMix=this.getValue(h,"scaleMix",1),i.shearMix=this.getValue(h,"shearMix",1),s.transformConstraints.push(i)}if(n.path)for(let c=0;c<n.path.length;c++){const h=n.path[c],i=new Eu(h.name);i.order=this.getValue(h,"order",0);for(let o=0;o<h.bones.length;o++){const d=h.bones[o],f=s.findBone(d);if(f==null)throw new Error(`Transform constraint bone not found: ${d}`);i.bones.push(f)}const a=h.target;if(i.target=s.findSlot(a),i.target==null)throw new Error(`Path target slot not found: ${a}`);i.positionMode=Na.positionModeFromString(this.getValue(h,"positionMode","percent")),i.spacingMode=Na.spacingModeFromString(this.getValue(h,"spacingMode","length")),i.rotateMode=Na.rotateModeFromString(this.getValue(h,"rotateMode","tangent")),i.offsetRotation=this.getValue(h,"rotation",0),i.position=this.getValue(h,"position",0),i.positionMode==Ca.Fixed&&(i.position*=e),i.spacing=this.getValue(h,"spacing",0),(i.spacingMode==Mn.Length||i.spacingMode==Mn.Fixed)&&(i.spacing*=e),i.rotateMix=this.getValue(h,"rotateMix",1),i.translateMix=this.getValue(h,"translateMix",1),s.pathConstraints.push(i)}if(n.skins)for(const c in n.skins){const h=n.skins[c],i=new Nu(c);for(const a in h){const o=s.findSlotIndex(a);if(o==-1)throw new Error(`Slot not found: ${a}`);const d=h[a];for(const f in d){const m=this.readAttachment(d[f],i,o,f,s);m!=null&&i.addAttachment(o,f,m)}}s.skins.push(i),i.name=="default"&&(s.defaultSkin=i)}for(let c=0,h=this.linkedMeshes.length;c<h;c++){const i=this.linkedMeshes[c],a=i.skin==null?s.defaultSkin:s.findSkin(i.skin);if(a==null)throw new Error(`Skin not found: ${i.skin}`);const o=a.getAttachment(i.slotIndex,i.parent);if(o==null)throw new Error(`Parent mesh not found: ${i.parent}`);i.mesh.setParentMesh(o)}if(this.linkedMeshes.length=0,n.events)for(const c in n.events){const h=n.events[c],i=new Du(c);i.intValue=this.getValue(h,"int",0),i.floatValue=this.getValue(h,"float",0),i.stringValue=this.getValue(h,"string",""),i.audioPath=this.getValue(h,"audio",null),i.audioPath!=null&&(i.volume=this.getValue(h,"volume",1),i.balance=this.getValue(h,"balance",0)),s.events.push(i)}if(n.animations)for(const c in n.animations){const h=n.animations[c];this.readAnimation(h,c,s)}return s}readAttachment(t,e,s,n,r){const c=this.scale;switch(n=this.getValue(t,"name",n),this.getValue(t,"type","region")){case"region":{const i=this.getValue(t,"path",n),a=this.attachmentLoader.newRegionAttachment(e,n,i);if(a==null)return null;a.path=i,a.x=this.getValue(t,"x",0)*c,a.y=this.getValue(t,"y",0)*c,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*c,a.height=t.height*c;const o=this.getValue(t,"color",null);return o!=null&&a.color.setFromString(o),a}case"boundingbox":{const i=this.attachmentLoader.newBoundingBoxAttachment(e,n);if(i==null)return null;this.readVertices(t,i,t.vertexCount<<1);const a=this.getValue(t,"color",null);return a!=null&&i.color.setFromString(a),i}case"mesh":case"linkedmesh":{const i=this.getValue(t,"path",n),a=this.attachmentLoader.newMeshAttachment(e,n,i);if(a==null)return null;a.path=i;const o=this.getValue(t,"color",null);o!=null&&a.color.setFromString(o);const d=this.getValue(t,"parent",null);if(d!=null)return a.inheritDeform=this.getValue(t,"deform",!0),this.linkedMeshes.push(new Pb(a,this.getValue(t,"skin",null),s,d)),a;const f=t.uvs;return this.readVertices(t,a,f.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(f),a.hullLength=this.getValue(t,"hull",0)*2,a}case"path":{const i=this.attachmentLoader.newPathAttachment(e,n);if(i==null)return null;i.closed=this.getValue(t,"closed",!1),i.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,i,a<<1);const o=pt.newArray(a/3,0);for(let f=0;f<t.lengths.length;f++)o[f]=t.lengths[f]*c;i.lengths=o;const d=this.getValue(t,"color",null);return d!=null&&i.color.setFromString(d),i}case"point":{const i=this.attachmentLoader.newPointAttachment(e,n);if(i==null)return null;i.x=this.getValue(t,"x",0)*c,i.y=this.getValue(t,"y",0)*c,i.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return a!=null&&i.color.setFromString(a),i}case"clipping":{const i=this.attachmentLoader.newClippingAttachment(e,n);if(i==null)return null;const a=this.getValue(t,"end",null);if(a!=null){const f=r.findSlot(a);if(f==null)throw new Error(`Clipping end slot not found: ${a}`);i.endSlot=f}const o=t.vertexCount;this.readVertices(t,i,o<<1);const d=this.getValue(t,"color",null);return d!=null&&i.color.setFromString(d),i}}return null}readVertices(t,e,s){const n=this.scale;e.worldVerticesLength=s;const r=t.vertices;if(s==r.length){const i=pt.toFloatArray(r);if(n!=1)for(let a=0,o=r.length;a<o;a++)i[a]*=n;e.vertices=i;return}const c=new Array,h=new Array;for(let i=0,a=r.length;i<a;){const o=r[i++];h.push(o);for(let d=i+o*4;i<d;i+=4)h.push(r[i]),c.push(r[i+1]*n),c.push(r[i+2]*n),c.push(r[i+3])}e.bones=h,e.vertices=pt.toFloatArray(c)}readAnimation(t,e,s){const n=this.scale,r=new Array;let c=0;if(t.slots)for(const i in t.slots){const a=t.slots[i],o=s.findSlotIndex(i);if(o==-1)throw new Error(`Slot not found: ${i}`);for(const d in a){const f=a[d];if(d=="attachment"){const m=new Zo(f.length);m.slotIndex=o;let l=0;for(let g=0;g<f.length;g++){const p=f[g];m.setFrame(l++,p.time,p.name)}r.push(m),c=Math.max(c,m.frames[m.getFrameCount()-1])}else if(d=="color"){const m=new Ll(f.length);m.slotIndex=o;let l=0;for(let g=0;g<f.length;g++){const p=f[g],y=new Cs;y.setFromString(p.color||"ffffffff"),m.setFrame(l,p.time,y.r,y.g,y.b,y.a),this.readCurve(p,m,l),l++}r.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*Ll.ENTRIES])}else if(d=="twoColor"){const m=new Ol(f.length);m.slotIndex=o;let l=0;for(let g=0;g<f.length;g++){const p=f[g],y=new Cs,w=new Cs;y.setFromString(p.light),w.setFromString(p.dark),m.setFrame(l,p.time,y.r,y.g,y.b,y.a,w.r,w.g,w.b),this.readCurve(p,m,l),l++}r.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*Ol.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${d} (${i})`)}}if(t.bones)for(const i in t.bones){const a=t.bones[i],o=s.findBoneIndex(i);if(o==-1)throw new Error(`Bone not found: ${i}`);for(const d in a){const f=a[d];if(d==="rotate"){const m=new yn(f.length);m.boneIndex=o;let l=0;for(let g=0;g<f.length;g++){const p=f[g];m.setFrame(l,p.time,p.angle),this.readCurve(p,m,l),l++}r.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*yn.ENTRIES])}else if(d==="translate"||d==="scale"||d==="shear"){let m=null,l=1;d==="scale"?m=new lu(f.length):d==="shear"?m=new cu(f.length):(m=new Ja(f.length),l=n),m.boneIndex=o;let g=0;for(let p=0;p<f.length;p++){const y=f[p],w=this.getValue(y,"x",0),b=this.getValue(y,"y",0);m.setFrame(g,y.time,w*l,b*l),this.readCurve(y,m,g),g++}r.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*Ja.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${d} (${i})`)}}if(t.ik)for(const i in t.ik){const a=t.ik[i],o=s.findIkConstraint(i),d=new Wl(a.length);d.ikConstraintIndex=s.ikConstraints.indexOf(o);let f=0;for(let m=0;m<a.length;m++){const l=a[m];d.setFrame(f,l.time,this.getValue(l,"mix",1),this.getValue(l,"bendPositive",!0)?1:-1,this.getValue(l,"compress",!1),this.getValue(l,"stretch",!1)),this.readCurve(l,d,f),f++}r.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*Wl.ENTRIES])}if(t.transform)for(const i in t.transform){const a=t.transform[i],o=s.findTransformConstraint(i),d=new Ul(a.length);d.transformConstraintIndex=s.transformConstraints.indexOf(o);let f=0;for(let m=0;m<a.length;m++){const l=a[m];d.setFrame(f,l.time,this.getValue(l,"rotateMix",1),this.getValue(l,"translateMix",1),this.getValue(l,"scaleMix",1),this.getValue(l,"shearMix",1)),this.readCurve(l,d,f),f++}r.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*Ul.ENTRIES])}if(t.paths)for(const i in t.paths){const a=t.paths[i],o=s.findPathConstraintIndex(i);if(o==-1)throw new Error(`Path constraint not found: ${i}`);const d=s.pathConstraints[o];for(const f in a){const m=a[f];if(f==="position"||f==="spacing"){let l=null,g=1;f==="spacing"?(l=new fu(m.length),(d.spacingMode==Mn.Length||d.spacingMode==Mn.Fixed)&&(g=n)):(l=new Jo(m.length),d.positionMode==Ca.Fixed&&(g=n)),l.pathConstraintIndex=o;let p=0;for(let y=0;y<m.length;y++){const w=m[y];l.setFrame(p,w.time,this.getValue(w,f,0)*g),this.readCurve(w,l,p),p++}r.push(l),c=Math.max(c,l.frames[(l.getFrameCount()-1)*Jo.ENTRIES])}else if(f==="mix"){const l=new ql(m.length);l.pathConstraintIndex=o;let g=0;for(let p=0;p<m.length;p++){const y=m[p];l.setFrame(g,y.time,this.getValue(y,"rotateMix",1),this.getValue(y,"translateMix",1)),this.readCurve(y,l,g),g++}r.push(l),c=Math.max(c,l.frames[(l.getFrameCount()-1)*ql.ENTRIES])}}}if(t.deform)for(const i in t.deform){const a=t.deform[i],o=s.findSkin(i);if(o!=null)for(const d in a){const f=a[d],m=s.findSlotIndex(d);if(m==-1)throw new Error(`Slot not found: ${f.name}`);for(const l in f){const g=f[l],p=o.getAttachment(m,l);if(p==null)throw new Error(`Deform attachment not found: ${g.name}`);const y=p.bones!=null,w=p.vertices,b=y?w.length/3*2:w.length,x=new du(g.length);x.slotIndex=m,x.attachment=p;let S=0;for(let C=0;C<g.length;C++){const A=g[C];let v;const M=this.getValue(A,"vertices",null);if(M==null)v=y?pt.newFloatArray(b):w;else{v=pt.newFloatArray(b);const E=this.getValue(A,"offset",0);if(pt.arrayCopy(M,0,v,E,M.length),n!=1)for(let T=E,R=T+M.length;T<R;T++)v[T]*=n;if(!y)for(let T=0;T<b;T++)v[T]+=w[T]}x.setFrame(S,A.time,v),this.readCurve(A,x,S),S++}r.push(x),c=Math.max(c,x.frames[x.getFrameCount()-1])}}}let h=t.drawOrder;if(h==null&&(h=t.draworder),h!=null){const i=new Qo(h.length),a=s.slots.length;let o=0;for(let d=0;d<h.length;d++){const f=h[d];let m=null;const l=this.getValue(f,"offsets",null);if(l!=null){m=pt.newArray(a,-1);const g=pt.newArray(a-l.length,0);let p=0,y=0;for(let w=0;w<l.length;w++){const b=l[w],x=s.findSlotIndex(b.slot);if(x==-1)throw new Error(`Slot not found: ${b.slot}`);for(;p!=x;)g[y++]=p++;m[p+b.offset]=p++}for(;p<a;)g[y++]=p++;for(let w=a-1;w>=0;w--)m[w]==-1&&(m[w]=g[--y])}i.setFrame(o++,f.time,m)}r.push(i),c=Math.max(c,i.frames[i.getFrameCount()-1])}if(t.events){const i=new uu(t.events.length);let a=0;for(let o=0;o<t.events.length;o++){const d=t.events[o],f=s.findEvent(d.name);if(f==null)throw new Error(`Event not found: ${d.name}`);const m=new Fu(pt.toSinglePrecision(d.time),f);m.intValue=this.getValue(d,"int",f.intValue),m.floatValue=this.getValue(d,"float",f.floatValue),m.stringValue=this.getValue(d,"string",f.stringValue),m.data.audioPath!=null&&(m.volume=this.getValue(d,"volume",1),m.balance=this.getValue(d,"balance",0)),i.setFrame(a++,m)}r.push(i),c=Math.max(c,i.frames[i.getFrameCount()-1])}if(isNaN(c))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new $e(e,r,c))}readCurve(t,e,s){if(t.curve){if(t.curve==="stepped")e.setStepped(s);else if(Object.prototype.toString.call(t.curve)==="[object Array]"){const n=t.curve;e.setCurve(s,n[0],n[1],n[2],n[3])}}}getValue(t,e,s){return t[e]!==void 0?t[e]:s}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return G.BLEND_MODES.NORMAL;if(t=="additive")return G.BLEND_MODES.ADD;if(t=="multiply")return G.BLEND_MODES.MULTIPLY;if(t=="screen")return G.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return Ca.Fixed;if(t=="percent")return Ca.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return Mn.Length;if(t=="fixed")return Mn.Fixed;if(t=="percent")return Mn.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return Li.Tangent;if(t=="chain")return Li.Chain;if(t=="chainscale")return Li.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return nn.Normal;if(t=="onlytranslation")return nn.OnlyTranslation;if(t=="norotationorreflection")return nn.NoRotationOrReflection;if(t=="noscale")return nn.NoScale;if(t=="noscaleorreflection")return nn.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}},Pb=class{constructor(t,e,s,n){Gi(this,"parent"),Gi(this,"skin"),Gi(this,"slotIndex"),Gi(this,"mesh"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n}};var kb=Object.defineProperty,Fb=(u,t,e)=>t in u?kb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,is=(u,t,e)=>Fb(u,typeof t!="symbol"?t+"":t,e);let Yb=class{constructor(){is(this,"array",new Array)}add(t){const e=this.contains(t);return this.array[t|0]=t|0,!e}contains(t){return this.array[t|0]!=null}remove(t){this.array[t|0]=void 0}clear(){this.array.length=0}};const En=class Jg{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new Jg().setFromString(t)}};is(En,"WHITE",new En(1,1,1,1)),is(En,"RED",new En(1,0,0,1)),is(En,"GREEN",new En(0,1,0,1)),is(En,"BLUE",new En(0,0,1,1)),is(En,"MAGENTA",new En(1,0,1,1));let Ut=En;const Ws=class Oo{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*Oo.degRad)}static sinDeg(t){return Math.sin(t*Oo.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*Oo.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return Oo.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};is(Ws,"PI",3.1415927),is(Ws,"PI2",Ws.PI*2),is(Ws,"invPI2",1/Ws.PI2),is(Ws,"radiansToDegrees",180/Ws.PI),is(Ws,"radDeg",Ws.radiansToDegrees),is(Ws,"degreesToRadians",Ws.PI/180),is(Ws,"degRad",Ws.degreesToRadians);let J=Ws,$b=class{apply(t,e,s){return t+(e-t)*this.applyInternal(s)}},_b=class extends $b{constructor(t){super(),is(this,"power",2),this.power=t}applyInternal(t){return t<=.5?Math.pow(t*2,this.power)/2:Math.pow((t-1)*2,this.power)/(this.power%2==0?-2:2)+1}},Xb=class extends _b{applyInternal(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1}};const Ou=class Da{static arrayCopy(t,e,s,n,r){for(let c=e,h=n;c<e+r;c++,h++)s[h]=t[c]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:Da.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(Da.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(Da.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return Da.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return Da.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}};is(Ou,"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");let it=Ou,Wu=class{constructor(t){is(this,"items",new Array),is(this,"instantiator"),this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}},Bb=class{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}};var we=(u=>(u[u.Region=0]="Region",u[u.BoundingBox=1]="BoundingBox",u[u.Mesh=2]="Mesh",u[u.LinkedMesh=3]="LinkedMesh",u[u.Path=4]="Path",u[u.Point=5]="Point",u[u.Clipping=6]="Clipping",u))(we||{}),fe=(u=>(u[u.Normal=0]="Normal",u[u.OnlyTranslation=1]="OnlyTranslation",u[u.NoRotationOrReflection=2]="NoRotationOrReflection",u[u.NoScale=3]="NoScale",u[u.NoScaleOrReflection=4]="NoScaleOrReflection",u))(fe||{}),Uu=(u=>(u[u.none=0]="none",u[u.reset=1]="reset",u[u.update=2]="update",u[u.pose=3]="pose",u))(Uu||{}),Vb=Object.defineProperty,Nb=(u,t,e)=>t in u?Vb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ro=(u,t,e)=>Nb(u,typeof t!="symbol"?t+"":t,e);let qu=class{constructor(){ro(this,"texture"),ro(this,"size",null),ro(this,"names",null),ro(this,"values",null),ro(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}};var Gu=(u=>(u[u.UNKNOWN=0]="UNKNOWN",u[u.VER37=37]="VER37",u[u.VER38=38]="VER38",u[u.VER40=40]="VER40",u[u.VER41=41]="VER41",u[u.VER42=42]="VER42",u))(Gu||{});function Db(u){const t=u.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}const Lb={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var Ob=Object.defineProperty,Wb=(u,t,e)=>t in u?Ob(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,as=(u,t,e)=>Wb(u,typeof t!="symbol"?t+"":t,e);const ti=[0,0,0];let Ub=class extends zr.Sprite{constructor(){super(...arguments),as(this,"region",null),as(this,"attachment",null)}},qb=class extends Gr.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),as(this,"region",null),as(this,"attachment",null)}};const zu=class jg extends Lt.Container{constructor(t){if(super(),as(this,"tintRgb"),as(this,"spineData"),as(this,"skeleton"),as(this,"stateData"),as(this,"state"),as(this,"slotContainers"),as(this,"tempClipContainers"),as(this,"localDelayLimit"),as(this,"_autoUpdate"),as(this,"_visible"),as(this,"_debug"),as(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),c=this.newContainer();if(this.slotContainers.push(c),this.addChild(c),this.tempClipContainers.push(null),!!r)if(r.type===we.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,c.addChild(i)}else if(r.type===we.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,c.addChild(h)}else r.type===we.Clipping&&(this.createGraphics(n,r),c.addChild(n.clippingContainer),c.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?jg.prototype.autoUpdateTransform:Lt.Container.prototype.updateTransform)}get tint(){return G.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=G.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:Lb.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=Db(this.spineData.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===Gu.VER42&&Uu.update);const n=this.skeleton.slots,r=this.color;let c=null,h=null;r?(c=r.light,h=r.dark):c=this.tintRgb;for(let f=0,m=n.length;f<m;f++){const l=n[f],g=l.getAttachment(),p=this.slotContainers[f];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(l,g);let w=g.region;const b=g.color;switch(g!=null&&g.type){case we.Region:if(p.transform.setFromMatrix(l.bone.matrix),w=g.region,l.currentMesh&&(l.currentMesh.visible=!1,l.currentMesh=null,l.currentMeshId=void 0,l.currentMeshName=void 0),!w){l.currentSprite&&(l.currentSprite.renderable=!1);break}if(!l.currentSpriteName||l.currentSpriteName!==g.name){const C=g.name;if(l.currentSprite&&(l.currentSprite.visible=!1),l.sprites=l.sprites||{},l.sprites[C]!==void 0)l.sprites[C].visible=!0;else{const A=this.createSprite(l,g,C);p.addChild(A)}l.currentSprite=l.sprites[C],l.currentSpriteName=C}l.currentSprite.renderable=!0,l.hackRegion||this.setSpriteRegion(g,l.currentSprite,w),l.currentSprite.color?y=l.currentSprite.color:(ti[0]=c[0]*l.color.r*b.r,ti[1]=c[1]*l.color.g*b.g,ti[2]=c[2]*l.color.b*b.b,l.currentSprite.tint=G.utils.rgb2hex(ti)),l.currentSprite.blendMode=l.blendMode;break;case we.Mesh:if(l.currentSprite){l.currentSprite.visible=!1,l.currentSprite=null,l.currentSpriteName=void 0;const C=new G.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){l.currentMesh&&(l.currentMesh.renderable=!1);break}const S=g.id;if(l.currentMeshId===void 0||l.currentMeshId!==S){const C=S;if(l.currentMesh&&(l.currentMesh.visible=!1),l.meshes=l.meshes||{},l.meshes[C]!==void 0)l.meshes[C].visible=!0;else{const A=this.createMesh(l,g);p.addChild(A)}l.currentMesh=l.meshes[C],l.currentMeshName=g.name,l.currentMeshId=C}l.currentMesh.renderable=!0,g.computeWorldVerticesOld(l,l.currentMesh.vertices),l.currentMesh.color?y=l.currentMesh.color:(ti[0]=c[0]*l.color.r*b.r,ti[1]=c[1]*l.color.g*b.g,ti[2]=c[2]*l.color.b*b.b,l.currentMesh.tint=G.utils.rgb2hex(ti)),l.currentMesh.blendMode=l.blendMode,l.hackRegion||this.setMeshRegion(g,l.currentMesh,w);break;case we.Clipping:l.currentGraphics||(this.createGraphics(l,g),p.addChild(l.clippingContainer),p.addChild(l.currentGraphics)),this.updateGraphics(l,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let x=l.color.r*b.r,S=l.color.g*b.g,C=l.color.b*b.b;y.setLight(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C)),l.darkColor?(x=l.darkColor.r,S=l.darkColor.g,C=l.darkColor.b):(x=0,S=0,C=0),y.setDark(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C))}p.alpha=l.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let f=0,m=i.length;f<m;f++){const l=n[i[f].data.index],g=this.slotContainers[i[f].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),l.currentGraphics&&l.getAttachment())o=l.clippingContainer,a=l.getAttachment(),o.children.length=0,this.children[f]=g,a.endSlot===l.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[f];p||(p=this.tempClipContainers[f]=this.newContainer(),p.visible=!1),this.children[f]=p,g.parent=null,o.addChild(g),a.endSlot==l.data&&(o.renderable=!0,o=null,a=null)}else this.children[f]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*J.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}Lt.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,c=this.newSprite(r);return c.anchor.set(.5),n&&this.setSpriteRegion(e,c,e.region),t.sprites=t.sprites||{},t.sprites[s]=c,c}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),G.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new G.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let c=r.region;return e?(c=new qu,c.texture=e,c.size=s,n.hackRegion=c,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,c):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,c),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),c=this.skeleton.getAttachmentByName(t,e);c.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=c.region;return s?(a=new qu,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Lt.Container}newSprite(t){return new Ub(t)}newGraphics(){return new Ye.Graphics}newMesh(t,e,s,n,r){return new qb(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let c=0,h=this.skeleton.slots.length;c<h;c++){const i=this.skeleton.slots[c],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};as(zu,"clippingPolygon",[]);let Hu=zu;Object.defineProperty(Hu.prototype,"visible",{get(){return this._visible},set(u){u!==this._visible&&(this._visible=u,u&&(this.lastTime=0))}});var Gb=Object.defineProperty,zb=(u,t,e)=>t in u?Gb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ei=(u,t,e)=>zb(u,typeof t!="symbol"?t+"":t,e);let Zl=class{constructor(t){if(ei(this,"name"),ei(this,"type"),t==null)throw new Error("name cannot be null.");this.name=t}};const Ku=class tp extends Zl{constructor(t){super(t),ei(this,"id",(tp.nextID++&65535)<<11),ei(this,"bones"),ei(this,"vertices"),ei(this,"worldVerticesLength",0),ei(this,"deformAttachment",this)}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,s,n,r,c){s=r+(s>>1)*c;const h=t.bone.skeleton,i=t.deform;let a=this.vertices;const o=this.bones;if(o==null){i.length>0&&(a=i);const l=t.bone.matrix,g=l.tx,p=l.ty,y=l.a,w=l.c,b=l.b,x=l.d;for(let S=e,C=r;C<s;S+=2,C+=c){const A=a[S],v=a[S+1];n[C]=A*y+v*w+g,n[C+1]=A*b+v*x+p}return}let d=0,f=0;for(let l=0;l<e;l+=2){const g=o[d];d+=g+1,f+=g}const m=h.bones;if(i.length==0)for(let l=r,g=f*3;l<s;l+=c){let p=0,y=0,w=o[d++];for(w+=d;d<w;d++,g+=3){const b=m[o[d]].matrix,x=a[g],S=a[g+1],C=a[g+2];p+=(x*b.a+S*b.c+b.tx)*C,y+=(x*b.b+S*b.d+b.ty)*C}n[l]=p,n[l+1]=y}else{const l=i;for(let g=r,p=f*3,y=f<<1;g<s;g+=c){let w=0,b=0,x=o[d++];for(x+=d;d<x;d++,p+=3,y+=2){const S=m[o[d]].matrix,C=a[p]+l[y],A=a[p+1]+l[y+1],v=a[p+2];w+=(C*S.a+A*S.c+S.tx)*v,b+=(C*S.b+A*S.d+S.ty)*v}n[g]=w,n[g+1]=b}}}copyTo(t){this.bones!=null?(t.bones=new Array(this.bones.length),it.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices!=null?(t.vertices=it.newFloatArray(this.vertices.length),it.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)):t.vertices=null,t.worldVerticesLength=this.worldVerticesLength,t.deformAttachment=this.deformAttachment}};ei(Ku,"nextID",0);let zi=Ku;var Hb=Object.defineProperty,Kb=(u,t,e)=>t in u?Hb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ar=(u,t,e)=>Kb(u,typeof t!="symbol"?t+"":t,e);let Ql=class{constructor(t,e){if(Ar(this,"blendMode"),Ar(this,"data"),Ar(this,"bone"),Ar(this,"color"),Ar(this,"darkColor"),Ar(this,"attachment"),Ar(this,"attachmentTime"),Ar(this,"attachmentState"),Ar(this,"deform",new Array),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new Ut,this.darkColor=t.darkColor==null?null:new Ut,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}};var Zb=Object.defineProperty,Qb=(u,t,e)=>t in u?Zb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,mt=(u,t,e)=>Qb(u,typeof t!="symbol"?t+"":t,e);const Mt=class Ze extends Zl{constructor(t){super(t),mt(this,"type",we.Region),mt(this,"x",0),mt(this,"y",0),mt(this,"scaleX",1),mt(this,"scaleY",1),mt(this,"rotation",0),mt(this,"width",0),mt(this,"height",0),mt(this,"color",new Ut(1,1,1,1)),mt(this,"path"),mt(this,"rendererObject"),mt(this,"region"),mt(this,"offset",it.newFloatArray(8)),mt(this,"uvs",it.newFloatArray(8)),mt(this,"tempColor",new Ut(1,1,1,1))}updateOffset(){const t=this.width/this.region.originalWidth*this.scaleX,e=this.height/this.region.originalHeight*this.scaleY,s=-this.width/2*this.scaleX+this.region.offsetX*t,n=-this.height/2*this.scaleY+this.region.offsetY*e,r=s+this.region.width*t,c=n+this.region.height*e,h=this.rotation*Math.PI/180,i=Math.cos(h),a=Math.sin(h),o=s*i+this.x,d=s*a,f=n*i+this.y,m=n*a,l=r*i+this.x,g=r*a,p=c*i+this.y,y=c*a,w=this.offset;w[Ze.OX1]=o-m,w[Ze.OY1]=f+d,w[Ze.OX2]=o-y,w[Ze.OY2]=p+d,w[Ze.OX3]=l-y,w[Ze.OY3]=p+g,w[Ze.OX4]=l-m,w[Ze.OY4]=f+g}setRegion(t){this.region=t;const e=this.uvs;t.rotate?(e[2]=t.u,e[3]=t.v2,e[4]=t.u,e[5]=t.v,e[6]=t.u2,e[7]=t.v,e[0]=t.u2,e[1]=t.v2):(e[0]=t.u,e[1]=t.v2,e[2]=t.u,e[3]=t.v,e[4]=t.u2,e[5]=t.v,e[6]=t.u2,e[7]=t.v2)}computeWorldVertices(t,e,s,n){const r=this.offset,c=t instanceof Ql?t.bone.matrix:t.matrix,h=c.tx,i=c.ty,a=c.a,o=c.c,d=c.b,f=c.d;let m=0,l=0;m=r[Ze.OX1],l=r[Ze.OY1],e[s]=m*a+l*o+h,e[s+1]=m*d+l*f+i,s+=n,m=r[Ze.OX2],l=r[Ze.OY2],e[s]=m*a+l*o+h,e[s+1]=m*d+l*f+i,s+=n,m=r[Ze.OX3],l=r[Ze.OY3],e[s]=m*a+l*o+h,e[s+1]=m*d+l*f+i,s+=n,m=r[Ze.OX4],l=r[Ze.OY4],e[s]=m*a+l*o+h,e[s+1]=m*d+l*f+i}copy(){const t=new Ze(this.name);return t.region=this.region,t.rendererObject=this.rendererObject,t.path=this.path,t.x=this.x,t.y=this.y,t.scaleX=this.scaleX,t.scaleY=this.scaleY,t.rotation=this.rotation,t.width=this.width,t.height=this.height,it.arrayCopy(this.uvs,0,t.uvs,0,8),it.arrayCopy(this.offset,0,t.offset,0,8),t.color.setFromColor(this.color),t}};mt(Mt,"OX1",0),mt(Mt,"OY1",1),mt(Mt,"OX2",2),mt(Mt,"OY2",3),mt(Mt,"OX3",4),mt(Mt,"OY3",5),mt(Mt,"OX4",6),mt(Mt,"OY4",7),mt(Mt,"X1",0),mt(Mt,"Y1",1),mt(Mt,"C1R",2),mt(Mt,"C1G",3),mt(Mt,"C1B",4),mt(Mt,"C1A",5),mt(Mt,"U1",6),mt(Mt,"V1",7),mt(Mt,"X2",8),mt(Mt,"Y2",9),mt(Mt,"C2R",10),mt(Mt,"C2G",11),mt(Mt,"C2B",12),mt(Mt,"C2A",13),mt(Mt,"U2",14),mt(Mt,"V2",15),mt(Mt,"X3",16),mt(Mt,"Y3",17),mt(Mt,"C3R",18),mt(Mt,"C3G",19),mt(Mt,"C3B",20),mt(Mt,"C3A",21),mt(Mt,"U3",22),mt(Mt,"V3",23),mt(Mt,"X4",24),mt(Mt,"Y4",25),mt(Mt,"C4R",26),mt(Mt,"C4G",27),mt(Mt,"C4B",28),mt(Mt,"C4A",29),mt(Mt,"U4",30),mt(Mt,"V4",31);let Jl=Mt;var Jb=Object.defineProperty,jb=(u,t,e)=>t in u?Jb(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Hi=(u,t,e)=>jb(u,typeof t!="symbol"?t+"":t,e);const Zu=class ep{constructor(t){Hi(this,"centerX",0),Hi(this,"centerY",0),Hi(this,"radius",0),Hi(this,"angle",0),Hi(this,"worldX",0),Hi(this,"worldY",0),this.radius=t}begin(t){this.worldX=t.x+this.centerX,this.worldY=t.y+this.centerY}transform(t,e,s,n){const r=this.angle*J.degreesToRadians,c=t.x-this.worldX,h=t.y-this.worldY,i=Math.sqrt(c*c+h*h);if(i<this.radius){const a=ep.interpolation.apply(0,r,(this.radius-i)/this.radius),o=Math.cos(a),d=Math.sin(a);t.x=o*c-d*h+this.worldX,t.y=d*c+o*h+this.worldY}}end(){}};Hi(Zu,"interpolation",new Xb(2));let tx=Zu;var tt=(u=>(u[u.setup=0]="setup",u[u.first=1]="first",u[u.replace=2]="replace",u[u.add=3]="add",u))(tt||{}),Us=(u=>(u[u.mixIn=0]="mixIn",u[u.mixOut=1]="mixOut",u))(Us||{}),ex=Object.defineProperty,sx=(u,t,e)=>t in u?ex(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,H=(u,t,e)=>sx(u,typeof t!="symbol"?t+"":t,e);let ye=class{constructor(t,e,s){if(H(this,"name"),H(this,"timelines"),H(this,"timelineIds"),H(this,"duration"),t==null)throw new Error("name cannot be null.");if(e==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=e,this.timelineIds=[];for(let n=0;n<e.length;n++)this.timelineIds[e[n].getPropertyId()]=!0;this.duration=s}hasTimeline(t){return this.timelineIds[t]==!0}apply(t,e,s,n,r,c,h,i){if(t==null)throw new Error("skeleton cannot be null.");n&&this.duration!=0&&(s%=this.duration,e>0&&(e%=this.duration));const a=this.timelines;for(let o=0,d=a.length;o<d;o++)a[o].apply(t,e,s,r,c,h,i)}static binarySearch(t,e,s=1){let n=0,r=t.length/s-2;if(r==0)return s;let c=r>>>1;for(;;){if(t[(c+1)*s]<=e?n=c+1:r=c,n==r)return(n+1)*s;c=n+r>>>1}}static linearSearch(t,e,s){for(let n=0,r=t.length-s;n<=r;n+=s)if(t[n]>e)return n;return-1}};var Qu=(u=>(u[u.rotate=0]="rotate",u[u.translate=1]="translate",u[u.scale=2]="scale",u[u.shear=3]="shear",u[u.attachment=4]="attachment",u[u.color=5]="color",u[u.deform=6]="deform",u[u.event=7]="event",u[u.drawOrder=8]="drawOrder",u[u.ikConstraint=9]="ikConstraint",u[u.transformConstraint=10]="transformConstraint",u[u.pathConstraintPosition=11]="pathConstraintPosition",u[u.pathConstraintSpacing=12]="pathConstraintSpacing",u[u.pathConstraintMix=13]="pathConstraintMix",u[u.twoColor=14]="twoColor",u))(Qu||{});const io=class Pe{constructor(t){if(H(this,"curves"),t<=0)throw new Error(`frameCount must be > 0: ${t}`);this.curves=it.newFloatArray((t-1)*Pe.BEZIER_SIZE)}getFrameCount(){return this.curves.length/Pe.BEZIER_SIZE+1}setLinear(t){this.curves[t*Pe.BEZIER_SIZE]=Pe.LINEAR}setStepped(t){this.curves[t*Pe.BEZIER_SIZE]=Pe.STEPPED}getCurveType(t){const e=t*Pe.BEZIER_SIZE;if(e==this.curves.length)return Pe.LINEAR;const s=this.curves[e];return s==Pe.LINEAR?Pe.LINEAR:s==Pe.STEPPED?Pe.STEPPED:Pe.BEZIER}setCurve(t,e,s,n,r){const c=(-e*2+n)*.03,h=(-s*2+r)*.03,i=((e-n)*3+1)*.006,a=((s-r)*3+1)*.006;let o=c*2+i,d=h*2+a,f=e*.3+c+i*.16666667,m=s*.3+h+a*.16666667,l=t*Pe.BEZIER_SIZE;const g=this.curves;g[l++]=Pe.BEZIER;let p=f,y=m;for(let w=l+Pe.BEZIER_SIZE-1;l<w;l+=2)g[l]=p,g[l+1]=y,f+=o,m+=d,o+=i,d+=a,p+=f,y+=m}getCurvePercent(t,e){e=J.clamp(e,0,1);const s=this.curves;let n=t*Pe.BEZIER_SIZE;const r=s[n];if(r==Pe.LINEAR)return e;if(r==Pe.STEPPED)return 0;n++;let c=0;for(let i=n,a=n+Pe.BEZIER_SIZE-1;n<a;n+=2)if(c=s[n],c>=e){let o,d;return n==i?(o=0,d=0):(o=s[n-2],d=s[n-1]),d+(s[n+1]-d)*(e-o)/(c-o)}const h=s[n-1];return h+(1-h)*(e-c)/(1-c)}};H(io,"LINEAR",0),H(io,"STEPPED",1),H(io,"BEZIER",2),H(io,"BEZIER_SIZE",10*2-1);let sr=io;const ao=class Ei extends sr{constructor(t){super(t),H(this,"boneIndex"),H(this,"frames"),this.frames=it.newFloatArray(t<<1)}getPropertyId(){return 0+this.boneIndex}setFrame(t,e,s){t<<=1,this.frames[t]=e,this.frames[t+Ei.ROTATION]=s}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(s<i[0]){switch(c){case tt.setup:a.rotation=a.data.rotation;return;case tt.first:const g=a.data.rotation-a.rotation;a.rotation+=(g-(16384-(16384.499999999996-g/360|0))*360)*r}return}if(s>=i[i.length-Ei.ENTRIES]){let g=i[i.length+Ei.PREV_ROTATION];switch(c){case tt.setup:a.rotation=a.data.rotation+g*r;break;case tt.first:case tt.replace:g+=a.data.rotation-a.rotation,g-=(16384-(16384.499999999996-g/360|0))*360;case tt.add:a.rotation+=g*r}return}const o=ye.binarySearch(i,s,Ei.ENTRIES),d=i[o+Ei.PREV_ROTATION],f=i[o],m=this.getCurvePercent((o>>1)-1,1-(s-f)/(i[o+Ei.PREV_TIME]-f));let l=i[o+Ei.ROTATION]-d;switch(l=d+(l-(16384-(16384.499999999996-l/360|0))*360)*m,c){case tt.setup:a.rotation=a.data.rotation+(l-(16384-(16384.499999999996-l/360|0))*360)*r;break;case tt.first:case tt.replace:l+=a.data.rotation-a.rotation;case tt.add:a.rotation+=(l-(16384-(16384.499999999996-l/360|0))*360)*r}}};H(ao,"ENTRIES",2),H(ao,"PREV_TIME",-2),H(ao,"PREV_ROTATION",-1),H(ao,"ROTATION",1);let rn=ao;const Ki=class Bs extends sr{constructor(t){super(t),H(this,"boneIndex"),H(this,"frames"),this.frames=it.newFloatArray(t*Bs.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(t,e,s,n){t*=Bs.ENTRIES,this.frames[t]=e,this.frames[t+Bs.X]=s,this.frames[t+Bs.Y]=n}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(s<i[0]){switch(c){case tt.setup:a.x=a.data.x,a.y=a.data.y;return;case tt.first:a.x+=(a.data.x-a.x)*r,a.y+=(a.data.y-a.y)*r}return}let o=0,d=0;if(s>=i[i.length-Bs.ENTRIES])o=i[i.length+Bs.PREV_X],d=i[i.length+Bs.PREV_Y];else{const f=ye.binarySearch(i,s,Bs.ENTRIES);o=i[f+Bs.PREV_X],d=i[f+Bs.PREV_Y];const m=i[f],l=this.getCurvePercent(f/Bs.ENTRIES-1,1-(s-m)/(i[f+Bs.PREV_TIME]-m));o+=(i[f+Bs.X]-o)*l,d+=(i[f+Bs.Y]-d)*l}switch(c){case tt.setup:a.x=a.data.x+o*r,a.y=a.data.y+d*r;break;case tt.first:case tt.replace:a.x+=(a.data.x+o-a.x)*r,a.y+=(a.data.y+d-a.y)*r;break;case tt.add:a.x+=o*r,a.y+=d*r}}};H(Ki,"ENTRIES",3),H(Ki,"PREV_TIME",-3),H(Ki,"PREV_X",-2),H(Ki,"PREV_Y",-1),H(Ki,"X",1),H(Ki,"Y",2);let Zi=Ki,jl=class Zn extends Zi{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(s<i[0]){switch(c){case tt.setup:a.scaleX=a.data.scaleX,a.scaleY=a.data.scaleY;return;case tt.first:a.scaleX+=(a.data.scaleX-a.scaleX)*r,a.scaleY+=(a.data.scaleY-a.scaleY)*r}return}let o=0,d=0;if(s>=i[i.length-Zn.ENTRIES])o=i[i.length+Zn.PREV_X]*a.data.scaleX,d=i[i.length+Zn.PREV_Y]*a.data.scaleY;else{const f=ye.binarySearch(i,s,Zn.ENTRIES);o=i[f+Zn.PREV_X],d=i[f+Zn.PREV_Y];const m=i[f],l=this.getCurvePercent(f/Zn.ENTRIES-1,1-(s-m)/(i[f+Zn.PREV_TIME]-m));o=(o+(i[f+Zn.X]-o)*l)*a.data.scaleX,d=(d+(i[f+Zn.Y]-d)*l)*a.data.scaleY}if(r==1)c==tt.add?(a.scaleX+=o-a.data.scaleX,a.scaleY+=d-a.data.scaleY):(a.scaleX=o,a.scaleY=d);else{let f=0,m=0;if(h==Us.mixOut)switch(c){case tt.setup:f=a.data.scaleX,m=a.data.scaleY,a.scaleX=f+(Math.abs(o)*J.signum(f)-f)*r,a.scaleY=m+(Math.abs(d)*J.signum(m)-m)*r;break;case tt.first:case tt.replace:f=a.scaleX,m=a.scaleY,a.scaleX=f+(Math.abs(o)*J.signum(f)-f)*r,a.scaleY=m+(Math.abs(d)*J.signum(m)-m)*r;break;case tt.add:f=a.scaleX,m=a.scaleY,a.scaleX=f+(Math.abs(o)*J.signum(f)-a.data.scaleX)*r,a.scaleY=m+(Math.abs(d)*J.signum(m)-a.data.scaleY)*r}else switch(c){case tt.setup:f=Math.abs(a.data.scaleX)*J.signum(o),m=Math.abs(a.data.scaleY)*J.signum(d),a.scaleX=f+(o-f)*r,a.scaleY=m+(d-m)*r;break;case tt.first:case tt.replace:f=Math.abs(a.scaleX)*J.signum(o),m=Math.abs(a.scaleY)*J.signum(d),a.scaleX=f+(o-f)*r,a.scaleY=m+(d-m)*r;break;case tt.add:f=J.signum(o),m=J.signum(d),a.scaleX=Math.abs(a.scaleX)*f+(o-Math.abs(a.data.scaleX)*f)*r,a.scaleY=Math.abs(a.scaleY)*m+(d-Math.abs(a.data.scaleY)*m)*r}}}},tc=class Qn extends Zi{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(s<i[0]){switch(c){case tt.setup:a.shearX=a.data.shearX,a.shearY=a.data.shearY;return;case tt.first:a.shearX+=(a.data.shearX-a.shearX)*r,a.shearY+=(a.data.shearY-a.shearY)*r}return}let o=0,d=0;if(s>=i[i.length-Qn.ENTRIES])o=i[i.length+Qn.PREV_X],d=i[i.length+Qn.PREV_Y];else{const f=ye.binarySearch(i,s,Qn.ENTRIES);o=i[f+Qn.PREV_X],d=i[f+Qn.PREV_Y];const m=i[f],l=this.getCurvePercent(f/Qn.ENTRIES-1,1-(s-m)/(i[f+Qn.PREV_TIME]-m));o=o+(i[f+Qn.X]-o)*l,d=d+(i[f+Qn.Y]-d)*l}switch(c){case tt.setup:a.shearX=a.data.shearX+o*r,a.shearY=a.data.shearY+d*r;break;case tt.first:case tt.replace:a.shearX+=(a.data.shearX+o-a.shearX)*r,a.shearY+=(a.data.shearY+d-a.shearY)*r;break;case tt.add:a.shearX+=o*r,a.shearY+=d*r}}};const Tn=class ce extends sr{constructor(t){super(t),H(this,"slotIndex"),H(this,"frames"),this.frames=it.newFloatArray(t*ce.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(t,e,s,n,r,c){t*=ce.ENTRIES,this.frames[t]=e,this.frames[t+ce.R]=s,this.frames[t+ce.G]=n,this.frames[t+ce.B]=r,this.frames[t+ce.A]=c}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames;if(s<a[0]){switch(c){case tt.setup:i.color.setFromColor(i.data.color);return;case tt.first:const l=i.color,g=i.data.color;l.add((g.r-l.r)*r,(g.g-l.g)*r,(g.b-l.b)*r,(g.a-l.a)*r)}return}let o=0,d=0,f=0,m=0;if(s>=a[a.length-ce.ENTRIES]){const l=a.length;o=a[l+ce.PREV_R],d=a[l+ce.PREV_G],f=a[l+ce.PREV_B],m=a[l+ce.PREV_A]}else{const l=ye.binarySearch(a,s,ce.ENTRIES);o=a[l+ce.PREV_R],d=a[l+ce.PREV_G],f=a[l+ce.PREV_B],m=a[l+ce.PREV_A];const g=a[l],p=this.getCurvePercent(l/ce.ENTRIES-1,1-(s-g)/(a[l+ce.PREV_TIME]-g));o+=(a[l+ce.R]-o)*p,d+=(a[l+ce.G]-d)*p,f+=(a[l+ce.B]-f)*p,m+=(a[l+ce.A]-m)*p}if(r==1)i.color.set(o,d,f,m);else{const l=i.color;c==tt.setup&&l.setFromColor(i.data.color),l.add((o-l.r)*r,(d-l.g)*r,(f-l.b)*r,(m-l.a)*r)}}};H(Tn,"ENTRIES",5),H(Tn,"PREV_TIME",-5),H(Tn,"PREV_R",-4),H(Tn,"PREV_G",-3),H(Tn,"PREV_B",-2),H(Tn,"PREV_A",-1),H(Tn,"R",1),H(Tn,"G",2),H(Tn,"B",3),H(Tn,"A",4);let oo=Tn;const os=class Dt extends sr{constructor(t){super(t),H(this,"slotIndex"),H(this,"frames"),this.frames=it.newFloatArray(t*Dt.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(t,e,s,n,r,c,h,i,a){t*=Dt.ENTRIES,this.frames[t]=e,this.frames[t+Dt.R]=s,this.frames[t+Dt.G]=n,this.frames[t+Dt.B]=r,this.frames[t+Dt.A]=c,this.frames[t+Dt.R2]=h,this.frames[t+Dt.G2]=i,this.frames[t+Dt.B2]=a}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames;if(s<a[0]){switch(c){case tt.setup:i.color.setFromColor(i.data.color),i.darkColor.setFromColor(i.data.darkColor);return;case tt.first:const y=i.color,w=i.darkColor,b=i.data.color,x=i.data.darkColor;y.add((b.r-y.r)*r,(b.g-y.g)*r,(b.b-y.b)*r,(b.a-y.a)*r),w.add((x.r-w.r)*r,(x.g-w.g)*r,(x.b-w.b)*r,0)}return}let o=0,d=0,f=0,m=0,l=0,g=0,p=0;if(s>=a[a.length-Dt.ENTRIES]){const y=a.length;o=a[y+Dt.PREV_R],d=a[y+Dt.PREV_G],f=a[y+Dt.PREV_B],m=a[y+Dt.PREV_A],l=a[y+Dt.PREV_R2],g=a[y+Dt.PREV_G2],p=a[y+Dt.PREV_B2]}else{const y=ye.binarySearch(a,s,Dt.ENTRIES);o=a[y+Dt.PREV_R],d=a[y+Dt.PREV_G],f=a[y+Dt.PREV_B],m=a[y+Dt.PREV_A],l=a[y+Dt.PREV_R2],g=a[y+Dt.PREV_G2],p=a[y+Dt.PREV_B2];const w=a[y],b=this.getCurvePercent(y/Dt.ENTRIES-1,1-(s-w)/(a[y+Dt.PREV_TIME]-w));o+=(a[y+Dt.R]-o)*b,d+=(a[y+Dt.G]-d)*b,f+=(a[y+Dt.B]-f)*b,m+=(a[y+Dt.A]-m)*b,l+=(a[y+Dt.R2]-l)*b,g+=(a[y+Dt.G2]-g)*b,p+=(a[y+Dt.B2]-p)*b}if(r==1)i.color.set(o,d,f,m),i.darkColor.set(l,g,p,1);else{const y=i.color,w=i.darkColor;c==tt.setup&&(y.setFromColor(i.data.color),w.setFromColor(i.data.darkColor)),y.add((o-y.r)*r,(d-y.g)*r,(f-y.b)*r,(m-y.a)*r),w.add((l-w.r)*r,(g-w.g)*r,(p-w.b)*r,0)}}};H(os,"ENTRIES",8),H(os,"PREV_TIME",-8),H(os,"PREV_R",-7),H(os,"PREV_G",-6),H(os,"PREV_B",-5),H(os,"PREV_A",-4),H(os,"PREV_R2",-3),H(os,"PREV_G2",-2),H(os,"PREV_B2",-1),H(os,"R",1),H(os,"G",2),H(os,"B",3),H(os,"A",4),H(os,"R2",5),H(os,"G2",6),H(os,"B2",7);let lo=os,Qi=class{constructor(t){H(this,"slotIndex"),H(this,"frames"),H(this,"attachmentNames"),this.frames=it.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.attachmentNames[t]=s}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;if(h==Us.mixOut){c==tt.setup&&this.setAttachment(t,i,i.data.attachmentName);return}const a=this.frames;if(s<a[0]){(c==tt.setup||c==tt.first)&&this.setAttachment(t,i,i.data.attachmentName);return}let o=0;s>=a[a.length-1]?o=a.length-1:o=ye.binarySearch(a,s,1)-1;const d=this.attachmentNames[o];t.slots[this.slotIndex].setAttachment(d==null?null:t.getAttachment(this.slotIndex,d))}setAttachment(t,e,s){e.setAttachment(s==null?null:t.getAttachment(this.slotIndex,s))}},Ju=null,ec=class extends sr{constructor(t){super(t),H(this,"slotIndex"),H(this,"attachment"),H(this,"frames"),H(this,"frameVertices"),this.frames=it.newFloatArray(t),this.frameVertices=new Array(t),Ju==null&&(Ju=it.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,e,s){this.frames[t]=e,this.frameVertices[t]=s}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.getAttachment();if(!(a instanceof zi)||a.deformAttachment!=this.attachment)return;const o=i.deform;o.length==0&&(c=tt.setup);const d=this.frameVertices,f=d[0].length,m=this.frames;if(s<m[0]){const x=a;switch(c){case tt.setup:o.length=0;return;case tt.first:if(r==1){o.length=0;break}const S=it.setArraySize(o,f);if(x.bones==null){const C=x.vertices;for(let A=0;A<f;A++)S[A]+=(C[A]-S[A])*r}else{r=1-r;for(let C=0;C<f;C++)S[C]*=r}}return}const l=it.setArraySize(o,f);if(s>=m[m.length-1]){const x=d[m.length-1];if(r==1)if(c==tt.add){const S=a;if(S.bones==null){const C=S.vertices;for(let A=0;A<f;A++)l[A]+=x[A]-C[A]}else for(let C=0;C<f;C++)l[C]+=x[C]}else it.arrayCopy(x,0,l,0,f);else switch(c){case tt.setup:{const C=a;if(C.bones==null){const A=C.vertices;for(let v=0;v<f;v++){const M=A[v];l[v]=M+(x[v]-M)*r}}else for(let A=0;A<f;A++)l[A]=x[A]*r;break}case tt.first:case tt.replace:for(let C=0;C<f;C++)l[C]+=(x[C]-l[C])*r;break;case tt.add:const S=a;if(S.bones==null){const C=S.vertices;for(let A=0;A<f;A++)l[A]+=(x[A]-C[A])*r}else for(let C=0;C<f;C++)l[C]+=x[C]*r}return}const g=ye.binarySearch(m,s),p=d[g-1],y=d[g],w=m[g],b=this.getCurvePercent(g-1,1-(s-w)/(m[g-1]-w));if(r==1)if(c==tt.add){const x=a;if(x.bones==null){const S=x.vertices;for(let C=0;C<f;C++){const A=p[C];l[C]+=A+(y[C]-A)*b-S[C]}}else for(let S=0;S<f;S++){const C=p[S];l[S]+=C+(y[S]-C)*b}}else for(let x=0;x<f;x++){const S=p[x];l[x]=S+(y[x]-S)*b}else switch(c){case tt.setup:{const S=a;if(S.bones==null){const C=S.vertices;for(let A=0;A<f;A++){const v=p[A],M=C[A];l[A]=M+(v+(y[A]-v)*b-M)*r}}else for(let C=0;C<f;C++){const A=p[C];l[C]=(A+(y[C]-A)*b)*r}break}case tt.first:case tt.replace:for(let S=0;S<f;S++){const C=p[S];l[S]+=(C+(y[S]-C)*b-l[S])*r}break;case tt.add:const x=a;if(x.bones==null){const S=x.vertices;for(let C=0;C<f;C++){const A=p[C];l[C]+=(A+(y[C]-A)*b-S[C])*r}}else for(let S=0;S<f;S++){const C=p[S];l[S]+=(C+(y[S]-C)*b)*r}}}},tl=class{constructor(t){H(this,"frames"),H(this,"events"),this.frames=it.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,s,n,r,c,h){if(n==null)return;const i=this.frames,a=this.frames.length;if(e>s)this.apply(t,e,Number.MAX_VALUE,n,r,c,h),e=-1;else if(e>=i[a-1])return;if(s<i[0])return;let o=0;if(e<i[0])o=0;else{o=ye.binarySearch(i,e);const d=i[o];for(;o>0&&i[o-1]==d;)o--}for(;o<a&&s>=i[o];o++)n.push(this.events[o])}},Aa=class{constructor(t){H(this,"frames"),H(this,"drawOrders"),this.frames=it.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.drawOrders[t]=s}apply(t,e,s,n,r,c,h){const i=t.drawOrder,a=t.slots;if(h==Us.mixOut&&c==tt.setup){it.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const o=this.frames;if(s<o[0]){(c==tt.setup||c==tt.first)&&it.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let d=0;s>=o[o.length-1]?d=o.length-1:d=ye.binarySearch(o,s)-1;const f=this.drawOrders[d];if(f==null)it.arrayCopy(a,0,i,0,a.length);else for(let m=0,l=f.length;m<l;m++)i[m]=a[f[m]]}};const an=class Wt extends sr{constructor(t){super(t),H(this,"ikConstraintIndex"),H(this,"frames"),this.frames=it.newFloatArray(t*Wt.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(t,e,s,n,r,c,h){t*=Wt.ENTRIES,this.frames[t]=e,this.frames[t+Wt.MIX]=s,this.frames[t+Wt.SOFTNESS]=n,this.frames[t+Wt.BEND_DIRECTION]=r,this.frames[t+Wt.COMPRESS]=c?1:0,this.frames[t+Wt.STRETCH]=h?1:0}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.ikConstraints[this.ikConstraintIndex];if(!a.active)return;if(s<i[0]){switch(c){case tt.setup:a.mix=a.data.mix,a.softness=a.data.softness,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch;return;case tt.first:a.mix+=(a.data.mix-a.mix)*r,a.softness+=(a.data.softness-a.softness)*r,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch}return}if(s>=i[i.length-Wt.ENTRIES]){c==tt.setup?(a.mix=a.data.mix+(i[i.length+Wt.PREV_MIX]-a.data.mix)*r,a.softness=a.data.softness+(i[i.length+Wt.PREV_SOFTNESS]-a.data.softness)*r,h==Us.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=i[i.length+Wt.PREV_BEND_DIRECTION],a.compress=i[i.length+Wt.PREV_COMPRESS]!=0,a.stretch=i[i.length+Wt.PREV_STRETCH]!=0)):(a.mix+=(i[i.length+Wt.PREV_MIX]-a.mix)*r,a.softness+=(i[i.length+Wt.PREV_SOFTNESS]-a.softness)*r,h==Us.mixIn&&(a.bendDirection=i[i.length+Wt.PREV_BEND_DIRECTION],a.compress=i[i.length+Wt.PREV_COMPRESS]!=0,a.stretch=i[i.length+Wt.PREV_STRETCH]!=0));return}const o=ye.binarySearch(i,s,Wt.ENTRIES),d=i[o+Wt.PREV_MIX],f=i[o+Wt.PREV_SOFTNESS],m=i[o],l=this.getCurvePercent(o/Wt.ENTRIES-1,1-(s-m)/(i[o+Wt.PREV_TIME]-m));c==tt.setup?(a.mix=a.data.mix+(d+(i[o+Wt.MIX]-d)*l-a.data.mix)*r,a.softness=a.data.softness+(f+(i[o+Wt.SOFTNESS]-f)*l-a.data.softness)*r,h==Us.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=i[o+Wt.PREV_BEND_DIRECTION],a.compress=i[o+Wt.PREV_COMPRESS]!=0,a.stretch=i[o+Wt.PREV_STRETCH]!=0)):(a.mix+=(d+(i[o+Wt.MIX]-d)*l-a.mix)*r,a.softness+=(f+(i[o+Wt.SOFTNESS]-f)*l-a.softness)*r,h==Us.mixIn&&(a.bendDirection=i[o+Wt.PREV_BEND_DIRECTION],a.compress=i[o+Wt.PREV_COMPRESS]!=0,a.stretch=i[o+Wt.PREV_STRETCH]!=0))}};H(an,"ENTRIES",6),H(an,"PREV_TIME",-6),H(an,"PREV_MIX",-5),H(an,"PREV_SOFTNESS",-4),H(an,"PREV_BEND_DIRECTION",-3),H(an,"PREV_COMPRESS",-2),H(an,"PREV_STRETCH",-1),H(an,"MIX",1),H(an,"SOFTNESS",2),H(an,"BEND_DIRECTION",3),H(an,"COMPRESS",4),H(an,"STRETCH",5);let co=an;const In=class he extends sr{constructor(t){super(t),H(this,"transformConstraintIndex"),H(this,"frames"),this.frames=it.newFloatArray(t*he.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(t,e,s,n,r,c){t*=he.ENTRIES,this.frames[t]=e,this.frames[t+he.ROTATE]=s,this.frames[t+he.TRANSLATE]=n,this.frames[t+he.SCALE]=r,this.frames[t+he.SHEAR]=c}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.transformConstraints[this.transformConstraintIndex];if(!a.active)return;if(s<i[0]){const l=a.data;switch(c){case tt.setup:a.rotateMix=l.rotateMix,a.translateMix=l.translateMix,a.scaleMix=l.scaleMix,a.shearMix=l.shearMix;return;case tt.first:a.rotateMix+=(l.rotateMix-a.rotateMix)*r,a.translateMix+=(l.translateMix-a.translateMix)*r,a.scaleMix+=(l.scaleMix-a.scaleMix)*r,a.shearMix+=(l.shearMix-a.shearMix)*r}return}let o=0,d=0,f=0,m=0;if(s>=i[i.length-he.ENTRIES]){const l=i.length;o=i[l+he.PREV_ROTATE],d=i[l+he.PREV_TRANSLATE],f=i[l+he.PREV_SCALE],m=i[l+he.PREV_SHEAR]}else{const l=ye.binarySearch(i,s,he.ENTRIES);o=i[l+he.PREV_ROTATE],d=i[l+he.PREV_TRANSLATE],f=i[l+he.PREV_SCALE],m=i[l+he.PREV_SHEAR];const g=i[l],p=this.getCurvePercent(l/he.ENTRIES-1,1-(s-g)/(i[l+he.PREV_TIME]-g));o+=(i[l+he.ROTATE]-o)*p,d+=(i[l+he.TRANSLATE]-d)*p,f+=(i[l+he.SCALE]-f)*p,m+=(i[l+he.SHEAR]-m)*p}if(c==tt.setup){const l=a.data;a.rotateMix=l.rotateMix+(o-l.rotateMix)*r,a.translateMix=l.translateMix+(d-l.translateMix)*r,a.scaleMix=l.scaleMix+(f-l.scaleMix)*r,a.shearMix=l.shearMix+(m-l.shearMix)*r}else a.rotateMix+=(o-a.rotateMix)*r,a.translateMix+=(d-a.translateMix)*r,a.scaleMix+=(f-a.scaleMix)*r,a.shearMix+=(m-a.shearMix)*r}};H(In,"ENTRIES",5),H(In,"PREV_TIME",-5),H(In,"PREV_ROTATE",-4),H(In,"PREV_TRANSLATE",-3),H(In,"PREV_SCALE",-2),H(In,"PREV_SHEAR",-1),H(In,"ROTATE",1),H(In,"TRANSLATE",2),H(In,"SCALE",3),H(In,"SHEAR",4);let ho=In;const uo=class Jn extends sr{constructor(t){super(t),H(this,"pathConstraintIndex"),H(this,"frames"),this.frames=it.newFloatArray(t*Jn.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(t,e,s){t*=Jn.ENTRIES,this.frames[t]=e,this.frames[t+Jn.VALUE]=s}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(s<i[0]){switch(c){case tt.setup:a.position=a.data.position;return;case tt.first:a.position+=(a.data.position-a.position)*r}return}let o=0;if(s>=i[i.length-Jn.ENTRIES])o=i[i.length+Jn.PREV_VALUE];else{const d=ye.binarySearch(i,s,Jn.ENTRIES);o=i[d+Jn.PREV_VALUE];const f=i[d],m=this.getCurvePercent(d/Jn.ENTRIES-1,1-(s-f)/(i[d+Jn.PREV_TIME]-f));o+=(i[d+Jn.VALUE]-o)*m}c==tt.setup?a.position=a.data.position+(o-a.data.position)*r:a.position+=(o-a.position)*r}};H(uo,"ENTRIES",2),H(uo,"PREV_TIME",-2),H(uo,"PREV_VALUE",-1),H(uo,"VALUE",1);let va=uo,sc=class Ti extends va{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(s<i[0]){switch(c){case tt.setup:a.spacing=a.data.spacing;return;case tt.first:a.spacing+=(a.data.spacing-a.spacing)*r}return}let o=0;if(s>=i[i.length-Ti.ENTRIES])o=i[i.length+Ti.PREV_VALUE];else{const d=ye.binarySearch(i,s,Ti.ENTRIES);o=i[d+Ti.PREV_VALUE];const f=i[d],m=this.getCurvePercent(d/Ti.ENTRIES-1,1-(s-f)/(i[d+Ti.PREV_TIME]-f));o+=(i[d+Ti.VALUE]-o)*m}c==tt.setup?a.spacing=a.data.spacing+(o-a.data.spacing)*r:a.spacing+=(o-a.spacing)*r}};const Ji=class Vs extends sr{constructor(t){super(t),H(this,"pathConstraintIndex"),H(this,"frames"),this.frames=it.newFloatArray(t*Vs.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(t,e,s,n){t*=Vs.ENTRIES,this.frames[t]=e,this.frames[t+Vs.ROTATE]=s,this.frames[t+Vs.TRANSLATE]=n}apply(t,e,s,n,r,c,h){const i=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(s<i[0]){switch(c){case tt.setup:a.rotateMix=a.data.rotateMix,a.translateMix=a.data.translateMix;return;case tt.first:a.rotateMix+=(a.data.rotateMix-a.rotateMix)*r,a.translateMix+=(a.data.translateMix-a.translateMix)*r}return}let o=0,d=0;if(s>=i[i.length-Vs.ENTRIES])o=i[i.length+Vs.PREV_ROTATE],d=i[i.length+Vs.PREV_TRANSLATE];else{const f=ye.binarySearch(i,s,Vs.ENTRIES);o=i[f+Vs.PREV_ROTATE],d=i[f+Vs.PREV_TRANSLATE];const m=i[f],l=this.getCurvePercent(f/Vs.ENTRIES-1,1-(s-m)/(i[f+Vs.PREV_TIME]-m));o+=(i[f+Vs.ROTATE]-o)*l,d+=(i[f+Vs.TRANSLATE]-d)*l}c==tt.setup?(a.rotateMix=a.data.rotateMix+(o-a.data.rotateMix)*r,a.translateMix=a.data.translateMix+(d-a.data.translateMix)*r):(a.rotateMix+=(o-a.rotateMix)*r,a.translateMix+=(d-a.translateMix)*r)}};H(Ji,"ENTRIES",3),H(Ji,"PREV_TIME",-3),H(Ji,"PREV_ROTATE",-2),H(Ji,"PREV_TRANSLATE",-1),H(Ji,"ROTATE",1),H(Ji,"TRANSLATE",2);let fo=Ji;var nx=Object.defineProperty,rx=(u,t,e)=>t in u?nx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,at=(u,t,e)=>rx(u,typeof t!="symbol"?t+"":t,e);const pn=class de{constructor(t){at(this,"data"),at(this,"tracks",new Array),at(this,"timeScale",1),at(this,"unkeyedState",0),at(this,"events",new Array),at(this,"listeners",new Array),at(this,"queue",new sf(this)),at(this,"propertyIDs",new Yb),at(this,"animationsChanged",!1),at(this,"trackEntryPool",new Wu(()=>new tf)),at(this,"onComplete"),at(this,"onEvent"),at(this,"onStart"),at(this,"onEnd"),this.data=t}update(t){t*=this.timeScale;const e=this.tracks;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r==null)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let c=t*r.timeScale;if(r.delay>0){if(r.delay-=c,r.delay>0)continue;c=-r.delay,r.delay=0}let h=r.next;if(h!=null){const i=r.trackLast-h.delay;if(i>=0){for(h.delay=0,h.trackTime+=r.timeScale==0?0:(i/r.timeScale+t)*h.timeScale,r.trackTime+=c,this.setCurrent(s,h,!0);h.mixingFrom!=null;)h.mixTime+=t,h=h.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&r.mixingFrom==null){e[s]=null,this.queue.end(r),this.disposeNext(r);continue}if(r.mixingFrom!=null&&this.updateMixingFrom(r,t)){let i=r.mixingFrom;for(r.mixingFrom=null,i!=null&&(i.mixingTo=null);i!=null;)this.queue.end(i),i=i.mixingFrom}r.trackTime+=c}this.queue.drain()}updateMixingFrom(t,e){const s=t.mixingFrom;if(s==null)return!0;const n=this.updateMixingFrom(s,e);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?((s.totalAlpha==0||t.mixDuration==0)&&(t.mixingFrom=s.mixingFrom,s.mixingFrom!=null&&(s.mixingFrom.mixingTo=t),t.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=e*s.timeScale,t.mixTime+=e,!1)}apply(t){if(t==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,s=this.tracks;let n=!1;for(let h=0,i=s.length;h<i;h++){const a=s[h];if(a==null||a.delay>0)continue;n=!0;const o=h==0?tt.first:a.mixBlend;let d=a.alpha;a.mixingFrom!=null?d*=this.applyMixingFrom(a,t,o):a.trackTime>=a.trackEnd&&a.next==null&&(d=0);const f=a.animationLast,m=a.getAnimationTime(),l=a.animation.timelines.length,g=a.animation.timelines;if(h==0&&d==1||o==tt.add)for(let p=0;p<l;p++){it.webkit602BugfixHelper(d,o);const y=g[p];y instanceof Qi?this.applyAttachmentTimeline(y,t,m,o,!0):y.apply(t,f,m,e,d,o,Us.mixIn)}else{const p=a.timelineMode,y=a.timelinesRotation.length==0;y&&it.setArraySize(a.timelinesRotation,l<<1,null);const w=a.timelinesRotation;for(let b=0;b<l;b++){const x=g[b],S=p[b]==de.SUBSEQUENT?o:tt.setup;x instanceof rn?this.applyRotateTimeline(x,t,m,d,S,w,b<<1,y):x instanceof Qi?this.applyAttachmentTimeline(x,t,m,o,!0):(it.webkit602BugfixHelper(d,o),x.apply(t,f,m,e,d,S,Us.mixIn))}}this.queueEvents(a,m),e.length=0,a.nextAnimationLast=m,a.nextTrackLast=a.trackTime}const r=this.unkeyedState+de.SETUP,c=t.slots;for(let h=0,i=t.slots.length;h<i;h++){const a=c[h];if(a.attachmentState==r){const o=a.data.attachmentName;a.setAttachment(o==null?null:t.getAttachment(a.data.index,o))}}return this.unkeyedState+=2,this.queue.drain(),n}applyMixingFrom(t,e,s){const n=t.mixingFrom;n.mixingFrom!=null&&this.applyMixingFrom(n,e,s);let r=0;t.mixDuration==0?(r=1,s==tt.first&&(s=tt.setup)):(r=t.mixTime/t.mixDuration,r>1&&(r=1),s!=tt.first&&(s=n.mixBlend));const c=r<n.eventThreshold?this.events:null,h=r<n.attachmentThreshold,i=r<n.drawOrderThreshold,a=n.animationLast,o=n.getAnimationTime(),d=n.animation.timelines.length,f=n.animation.timelines,m=n.alpha*t.interruptAlpha,l=m*(1-r);if(s==tt.add)for(let g=0;g<d;g++)f[g].apply(e,a,o,c,l,s,Us.mixOut);else{const g=n.timelineMode,p=n.timelineHoldMix,y=n.timelinesRotation.length==0;y&&it.setArraySize(n.timelinesRotation,d<<1,null);const w=n.timelinesRotation;n.totalAlpha=0;for(let b=0;b<d;b++){const x=f[b];let S=Us.mixOut,C,A=0;switch(g[b]){case de.SUBSEQUENT:if(!i&&x instanceof Aa)continue;C=s,A=l;break;case de.FIRST:C=tt.setup,A=l;break;case de.HOLD_SUBSEQUENT:C=s,A=m;break;case de.HOLD_FIRST:C=tt.setup,A=m;break;default:C=tt.setup;const v=p[b];A=m*Math.max(0,1-v.mixTime/v.mixDuration);break}n.totalAlpha+=A,x instanceof rn?this.applyRotateTimeline(x,e,o,A,C,w,b<<1,y):x instanceof Qi?this.applyAttachmentTimeline(x,e,o,C,h):(it.webkit602BugfixHelper(A,s),i&&x instanceof Aa&&C==tt.setup&&(S=Us.mixIn),x.apply(e,a,o,c,A,C,S))}}return t.mixDuration>0&&this.queueEvents(n,o),this.events.length=0,n.nextAnimationLast=o,n.nextTrackLast=n.trackTime,r}applyAttachmentTimeline(t,e,s,n,r){const c=e.slots[t.slotIndex];if(!c.bone.active)return;const h=t.frames;if(s<h[0])(n==tt.setup||n==tt.first)&&this.setAttachment(e,c,c.data.attachmentName,r);else{let i;s>=h[h.length-1]?i=h.length-1:i=ye.binarySearch(h,s)-1,this.setAttachment(e,c,t.attachmentNames[i],r)}c.attachmentState<=this.unkeyedState&&(c.attachmentState=this.unkeyedState+de.SETUP)}setAttachment(t,e,s,n){e.setAttachment(s==null?null:t.getAttachment(e.data.index,s)),n&&(e.attachmentState=this.unkeyedState+de.CURRENT)}applyRotateTimeline(t,e,s,n,r,c,h,i){if(i&&(c[h]=0),n==1){t.apply(e,0,s,null,1,r,Us.mixIn);return}const a=t,o=a.frames,d=e.bones[a.boneIndex];if(!d.active)return;let f=0,m=0;if(s<o[0])switch(r){case tt.setup:d.rotation=d.data.rotation;default:return;case tt.first:f=d.rotation,m=d.data.rotation}else if(f=r==tt.setup?d.data.rotation:d.rotation,s>=o[o.length-rn.ENTRIES])m=d.data.rotation+o[o.length+rn.PREV_ROTATION];else{const p=ye.binarySearch(o,s,rn.ENTRIES),y=o[p+rn.PREV_ROTATION],w=o[p],b=a.getCurvePercent((p>>1)-1,1-(s-w)/(o[p+rn.PREV_TIME]-w));m=o[p+rn.ROTATION]-y,m-=(16384-(16384.499999999996-m/360|0))*360,m=y+m*b+d.data.rotation,m-=(16384-(16384.499999999996-m/360|0))*360}let l=0,g=m-f;if(g-=(16384-(16384.499999999996-g/360|0))*360,g==0)l=c[h];else{let p=0,y=0;i?(p=0,y=g):(p=c[h],y=c[h+1]);const w=g>0;let b=p>=0;J.signum(y)!=J.signum(g)&&Math.abs(y)<=90&&(Math.abs(p)>180&&(p+=360*J.signum(p)),b=w),l=g+p-p%360,b!=w&&(l+=360*J.signum(p)),c[h]=l}c[h+1]=g,f+=l*n,d.rotation=f-(16384-(16384.499999999996-f/360|0))*360}queueEvents(t,e){const s=t.animationStart,n=t.animationEnd,r=n-s,c=t.trackLast%r,h=this.events;let i=0;const a=h.length;for(;i<a;i++){const d=h[i];if(d.time<c)break;d.time>n||this.queue.event(t,d)}let o=!1;for(t.loop?o=r==0||c>t.trackTime%r:o=e>=n&&t.animationLast<n,o&&this.queue.complete(t);i<a;i++)h[i].time<s||this.queue.event(t,h[i])}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,s=this.tracks.length;e<s;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(e==null)return;this.queue.end(e),this.disposeNext(e);let s=e;for(;;){const n=s.mixingFrom;if(n==null)break;this.queue.end(n),s.mixingFrom=null,s.mixingTo=null,s=n}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,s){const n=this.expandToIndex(t);this.tracks[t]=e,n!=null&&(s&&this.queue.interrupt(n),e.mixingFrom=n,n.mixingTo=e,e.mixTime=0,n.mixingFrom!=null&&n.mixDuration>0&&(e.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,s){const n=this.data.skeletonData.findAnimation(e);if(n==null)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,n,s)}setAnimationWith(t,e,s){if(e==null)throw new Error("animation cannot be null.");let n=!0,r=this.expandToIndex(t);r!=null&&(r.nextTrackLast==-1?(this.tracks[t]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.disposeNext(r),r=r.mixingFrom,n=!1):this.disposeNext(r));const c=this.trackEntry(t,e,s,r);return this.setCurrent(t,c,n),this.queue.drain(),c}addAnimation(t,e,s,n){const r=this.data.skeletonData.findAnimation(e);if(r==null)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,r,s,n)}addAnimationWith(t,e,s,n){if(e==null)throw new Error("animation cannot be null.");let r=this.expandToIndex(t);if(r!=null)for(;r.next!=null;)r=r.next;const c=this.trackEntry(t,e,s,r);if(r==null)this.setCurrent(t,c,!0),this.queue.drain();else if(r.next=c,n<=0){const h=r.animationEnd-r.animationStart;h!=0?(r.loop?n+=h*(1+(r.trackTime/h|0)):n+=Math.max(h,r.trackTime),n-=this.data.getMix(r.animation,e)):n=r.trackTime}return c.delay=n,c}setEmptyAnimation(t,e){const s=this.setAnimationWith(t,de.emptyAnimation,!1);return s.mixDuration=e,s.trackEnd=e,s}addEmptyAnimation(t,e,s){s<=0&&(s-=e);const n=this.addAnimationWith(t,de.emptyAnimation,!1,s);return n.mixDuration=e,n.trackEnd=e,n}setEmptyAnimations(t){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,n=this.tracks.length;s<n;s++){const r=this.tracks[s];r!=null&&this.setEmptyAnimation(r.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(it.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,s,n){const r=this.trackEntryPool.obtain();return r.trackIndex=t,r.animation=e,r.loop=s,r.holdPrevious=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=e.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.interruptAlpha=1,r.mixTime=0,r.mixDuration=n==null?0:this.data.getMix(n.animation,e),r.mixBlend=tt.replace,r}disposeNext(t){let e=t.next;for(;e!=null;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let t=0,e=this.tracks.length;t<e;t++){let s=this.tracks[t];if(s!=null){for(;s.mixingFrom!=null;)s=s.mixingFrom;do(s.mixingFrom==null||s.mixBlend!=tt.add)&&this.computeHold(s),s=s.mixingTo;while(s!=null)}}}computeHold(t){const e=t.mixingTo,s=t.animation.timelines,n=t.animation.timelines.length,r=it.setArraySize(t.timelineMode,n);t.timelineHoldMix.length=0;const c=it.setArraySize(t.timelineHoldMix,n),h=this.propertyIDs;if(e!=null&&e.holdPrevious){for(let i=0;i<n;i++)r[i]=h.add(s[i].getPropertyId())?de.HOLD_FIRST:de.HOLD_SUBSEQUENT;return}t:for(let i=0;i<n;i++){const a=s[i],o=a.getPropertyId();if(!h.add(o))r[i]=de.SUBSEQUENT;else if(e==null||a instanceof Qi||a instanceof Aa||a instanceof tl||!e.animation.hasTimeline(o))r[i]=de.FIRST;else{for(let d=e.mixingTo;d!=null;d=d.mixingTo)if(!d.animation.hasTimeline(o)){if(t.mixDuration>0){r[i]=de.HOLD_MIX,c[i]=d;continue t}break}r[i]=de.HOLD_FIRST}}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(t==null)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,e,s){de.deprecatedWarning1||(de.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,e,s)}addAnimationByName(t,e,s,n){de.deprecatedWarning2||(de.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,e,s,n)}hasAnimation(t){return this.data.skeletonData.findAnimation(t)!==null}hasAnimationByName(t){return de.deprecatedWarning3||(de.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};at(pn,"emptyAnimation",new ye("<empty>",[],0)),at(pn,"SUBSEQUENT",0),at(pn,"FIRST",1),at(pn,"HOLD_SUBSEQUENT",2),at(pn,"HOLD_FIRST",3),at(pn,"HOLD_MIX",4),at(pn,"SETUP",1),at(pn,"CURRENT",2),at(pn,"deprecatedWarning1",!1),at(pn,"deprecatedWarning2",!1),at(pn,"deprecatedWarning3",!1);let ju=pn;const nc=class Lr{constructor(){at(this,"animation"),at(this,"next"),at(this,"mixingFrom"),at(this,"mixingTo"),at(this,"listener"),at(this,"trackIndex"),at(this,"loop"),at(this,"holdPrevious"),at(this,"eventThreshold"),at(this,"attachmentThreshold"),at(this,"drawOrderThreshold"),at(this,"animationStart"),at(this,"animationEnd"),at(this,"animationLast"),at(this,"nextAnimationLast"),at(this,"delay"),at(this,"trackTime"),at(this,"trackLast"),at(this,"nextTrackLast"),at(this,"trackEnd"),at(this,"timeScale"),at(this,"alpha"),at(this,"mixTime"),at(this,"mixDuration"),at(this,"interruptAlpha"),at(this,"totalAlpha"),at(this,"mixBlend",tt.replace),at(this,"timelineMode",new Array),at(this,"timelineHoldMix",new Array),at(this,"timelinesRotation",new Array),at(this,"onComplete"),at(this,"onEvent"),at(this,"onStart"),at(this,"onEnd")}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return Lr.deprecatedWarning1||(Lr.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){Lr.deprecatedWarning1||(Lr.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return Lr.deprecatedWarning2||(Lr.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){Lr.deprecatedWarning2||(Lr.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};at(nc,"deprecatedWarning1",!1),at(nc,"deprecatedWarning2",!1);let tf=nc;const ef=class $d{constructor(t){at(this,"objects",[]),at(this,"drainDisabled",!1),at(this,"animState"),this.animState=t}start(t){this.objects.push(0),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(1),this.objects.push(t)}end(t){this.objects.push(2),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(3),this.objects.push(t)}complete(t){this.objects.push(4),this.objects.push(t)}event(t,e){this.objects.push(5),this.objects.push(t),this.objects.push(e)}deprecateStuff(){return $d.deprecatedWarning1||($d.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let s=0;s<t.length;s+=2){const n=t[s],r=t[s+1];switch(n){case 0:r.listener!=null&&r.listener.start&&r.listener.start(r);for(let i=0;i<e.length;i++)e[i].start&&e[i].start(r);r.onStart&&this.deprecateStuff()&&r.onStart(r.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(r.trackIndex);break;case 1:r.listener!=null&&r.listener.interrupt&&r.listener.interrupt(r);for(let i=0;i<e.length;i++)e[i].interrupt&&e[i].interrupt(r);break;case 2:r.listener!=null&&r.listener.end&&r.listener.end(r);for(let i=0;i<e.length;i++)e[i].end&&e[i].end(r);r.onEnd&&this.deprecateStuff()&&r.onEnd(r.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(r.trackIndex);case 3:r.listener!=null&&r.listener.dispose&&r.listener.dispose(r);for(let i=0;i<e.length;i++)e[i].dispose&&e[i].dispose(r);this.animState.trackEntryPool.free(r);break;case 4:r.listener!=null&&r.listener.complete&&r.listener.complete(r);for(let i=0;i<e.length;i++)e[i].complete&&e[i].complete(r);const c=J.toInt(r.loopsCount());r.onComplete&&this.deprecateStuff()&&r.onComplete(r.trackIndex,c),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(r.trackIndex,c);break;case 5:const h=t[s+++2];r.listener!=null&&r.listener.event&&r.listener.event(r,h);for(let i=0;i<e.length;i++)e[i].event&&e[i].event(r,h);r.onEvent&&this.deprecateStuff()&&r.onEvent(r.trackIndex,h),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(r.trackIndex,h);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};at(ef,"deprecatedWarning1",!1);let sf=ef;var nf=(u=>(u[u.start=0]="start",u[u.interrupt=1]="interrupt",u[u.end=2]="end",u[u.dispose=3]="dispose",u[u.complete=4]="complete",u[u.event=5]="event",u))(nf||{});let ix=class{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}};var ax=Object.defineProperty,ox=(u,t,e)=>t in u?ax(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,el=(u,t,e)=>ox(u,typeof t!="symbol"?t+"":t,e);const rf=class _d{constructor(t){if(el(this,"skeletonData"),el(this,"animationToMixTime",{}),el(this,"defaultMix",0),t==null)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,s){const n=this.skeletonData.findAnimation(t);if(n==null)throw new Error(`Animation not found: ${t}`);const r=this.skeletonData.findAnimation(e);if(r==null)throw new Error(`Animation not found: ${e}`);this.setMixWith(n,r,s)}setMixByName(t,e,s){_d.deprecatedWarning1||(_d.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(t,e,s)}setMixWith(t,e,s){if(t==null)throw new Error("from cannot be null.");if(e==null)throw new Error("to cannot be null.");const n=`${t.name}.${e.name}`;this.animationToMixTime[n]=s}getMix(t,e){const s=`${t.name}.${e.name}`,n=this.animationToMixTime[s];return n===void 0?this.defaultMix:n}};el(rf,"deprecatedWarning1",!1);let af=rf;var lx=Object.defineProperty,cx=(u,t,e)=>t in u?lx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,of=(u,t,e)=>cx(u,typeof t!="symbol"?t+"":t,e);let lf=class sp extends zi{constructor(t){super(t),of(this,"type",we.BoundingBox),of(this,"color",new Ut(1,1,1,1))}copy(){const t=new sp(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}};var hx=Object.defineProperty,dx=(u,t,e)=>t in u?hx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,rc=(u,t,e)=>dx(u,typeof t!="symbol"?t+"":t,e);let cf=class np extends zi{constructor(t){super(t),rc(this,"type",we.Clipping),rc(this,"endSlot"),rc(this,"color",new Ut(.2275,.2275,.8078,1))}copy(){const t=new np(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}};var ux=Object.defineProperty,fx=(u,t,e)=>t in u?ux(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,bn=(u,t,e)=>fx(u,typeof t!="symbol"?t+"":t,e);let sl=class Xd extends zi{constructor(t){super(t),bn(this,"type",we.Mesh),bn(this,"region"),bn(this,"path"),bn(this,"regionUVs"),bn(this,"triangles"),bn(this,"color",new Ut(1,1,1,1)),bn(this,"width"),bn(this,"height"),bn(this,"hullLength"),bn(this,"edges"),bn(this,"parentMesh"),bn(this,"tempColor",new Ut(0,0,0,0))}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh!=null)return this.newLinkedMesh();const t=new Xd(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),it.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),it.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges!=null&&(t.edges=new Array(this.edges.length),it.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new Xd(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh!=null?this.parentMesh:this),t}};var mx=Object.defineProperty,gx=(u,t,e)=>t in u?mx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,mo=(u,t,e)=>gx(u,typeof t!="symbol"?t+"":t,e);let go=class rp extends zi{constructor(t){super(t),mo(this,"type",we.Path),mo(this,"lengths"),mo(this,"closed",!1),mo(this,"constantSpeed",!1),mo(this,"color",new Ut(1,1,1,1))}copy(){const t=new rp(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),it.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}};var px=Object.defineProperty,bx=(u,t,e)=>t in u?px(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,po=(u,t,e)=>bx(u,typeof t!="symbol"?t+"":t,e);let hf=class ip extends zi{constructor(t){super(t),po(this,"type",we.Point),po(this,"x"),po(this,"y"),po(this,"rotation"),po(this,"color",new Ut(.38,.94,0,1))}computeWorldPosition(t,e){const s=t.matrix;return e.x=this.x*s.a+this.y*s.c+t.worldX,e.y=this.x*s.b+this.y*s.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,s=J.cosDeg(this.rotation),n=J.sinDeg(this.rotation),r=s*e.a+n*e.c,c=s*e.b+n*e.d;return Math.atan2(c,r)*J.radDeg}copy(){const t=new ip(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}};var xx=Object.defineProperty,wx=(u,t,e)=>t in u?xx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,yx=(u,t,e)=>wx(u,typeof t!="symbol"?t+"":t,e);let ic=class{constructor(t){yx(this,"atlas"),this.atlas=t}newRegionAttachment(t,e,s){const n=this.atlas.findRegion(s);if(n==null)throw new Error(`Region not found in atlas: ${s} (region attachment: ${e})`);const r=new Jl(e);return r.region=n,r}newMeshAttachment(t,e,s){const n=this.atlas.findRegion(s);if(n==null)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${e})`);const r=new sl(e);return r.region=n,r}newBoundingBoxAttachment(t,e){return new lf(e)}newPathAttachment(t,e){return new go(e)}newPointAttachment(t,e){return new hf(e)}newClippingAttachment(t,e){return new cf(e)}};var nr=(u=>(u[u.Fixed=0]="Fixed",u[u.Percent=1]="Percent",u))(nr||{}),rr=(u=>(u[u.Tangent=0]="Tangent",u[u.Chain=1]="Chain",u[u.ChainScale=2]="ChainScale",u))(rr||{});let nl=class{constructor(t,e,s){this.name=t,this.order=e,this.skinRequired=s}};var Sx=Object.defineProperty,Cx=(u,t,e)=>t in u?Sx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ir=(u,t,e)=>Cx(u,typeof t!="symbol"?t+"":t,e);let ac=class extends nl{constructor(t){super(t,0,!1),ir(this,"bones",new Array),ir(this,"target"),ir(this,"positionMode"),ir(this,"spacingMode"),ir(this,"rotateMode"),ir(this,"offsetRotation"),ir(this,"position"),ir(this,"spacing"),ir(this,"rotateMix"),ir(this,"translateMix")}};var Oe=(u=>(u[u.Length=0]="Length",u[u.Fixed=1]="Fixed",u[u.Percent=2]="Percent",u))(Oe||{}),Ax=Object.defineProperty,vx=(u,t,e)=>t in u?Ax(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,We=(u,t,e)=>vx(u,typeof t!="symbol"?t+"":t,e);const bo=class Sa{constructor(t,e){if(We(this,"data"),We(this,"bones"),We(this,"target"),We(this,"position",0),We(this,"spacing",0),We(this,"rotateMix",0),We(this,"translateMix",0),We(this,"spaces",new Array),We(this,"positions",new Array),We(this,"world",new Array),We(this,"curves",new Array),We(this,"lengths",new Array),We(this,"segments",new Array),We(this,"active",!1),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let s=0,n=t.bones.length;s<n;s++)this.bones.push(e.findBone(t.bones[s].name));this.target=e.findSlot(t.target.name),this.position=t.position,this.spacing=t.spacing,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix}isActive(){return this.active}apply(){this.update()}update(){const t=this.target.getAttachment();if(!(t instanceof go))return;const e=this.rotateMix,s=this.translateMix,n=s>0,r=e>0;if(!n&&!r)return;const c=this.data,h=c.spacingMode,i=h==Oe.Length,a=c.rotateMode,o=a==rr.Tangent,d=a==rr.ChainScale,f=this.bones.length,m=o?f:f+1,l=this.bones,g=it.setArraySize(this.spaces,m);let p=null;const y=this.spacing;if(d||i){d&&(p=it.setArraySize(this.lengths,f));for(let A=0,v=m-1;A<v;){const M=l[A],E=M.data.length;if(E<Sa.epsilon)d&&(p[A]=0),g[++A]=0;else{const T=E*M.matrix.a,R=E*M.matrix.b,k=Math.sqrt(T*T+R*R);d&&(p[A]=k),g[++A]=(i?E+y:y)*k/E}}}else for(let A=1;A<m;A++)g[A]=y;const w=this.computeWorldPositions(t,m,o,c.positionMode==nr.Percent,h==Oe.Percent);let b=w[0],x=w[1],S=c.offsetRotation,C=!1;if(S==0)C=a==rr.Chain;else{C=!1;const A=this.target.bone.matrix;S*=A.a*A.d-A.b*A.c>0?J.degRad:-J.degRad}for(let A=0,v=3;A<f;A++,v+=3){const M=l[A],E=M.matrix;E.tx+=(b-E.tx)*s,E.ty+=(x-E.ty)*s;const T=w[v],R=w[v+1],k=T-b,I=R-x;if(d){const P=p[A];if(P!=0){const F=(Math.sqrt(k*k+I*I)/P-1)*e+1;E.a*=F,E.b*=F}}if(b=T,x=R,r){const P=E.a,F=E.c,X=E.b,W=E.d;let Y=0,_=0,O=0;if(o&&(o?Y=w[v-1]:g[A+1]==0?Y=w[v+2]:Y=Math.atan2(I,k)),Y-=Math.atan2(X,P),C){_=Math.cos(Y),O=Math.sin(Y);const z=M.data.length;b+=(z*(_*P-O*X)-k)*e,x+=(z*(O*P+_*X)-I)*e}else Y+=S;Y>J.PI?Y-=J.PI2:Y<-J.PI&&(Y+=J.PI2),Y*=e,_=Math.cos(Y),O=Math.sin(Y),E.a=_*P-O*X,E.c=_*F-O*W,E.b=O*P+_*X,E.d=O*F+_*W}M.appliedValid=!1}}computeWorldPositions(t,e,s,n,r){const c=this.target;let h=this.position;const i=this.spaces,a=it.setArraySize(this.positions,e*3+2);let o=null;const d=t.closed;let f=t.worldVerticesLength,m=f/6,l=Sa.NONE;if(!t.constantSpeed){const Y=t.lengths;m-=d?1:2;const _=Y[m];if(n&&(h*=_),r)for(let O=0;O<e;O++)i[O]*=_;o=it.setArraySize(this.world,8);for(let O=0,z=0,$=0;O<e;O++,z+=3){const N=i[O];h+=N;let V=h;if(d)V%=_,V<0&&(V+=_),$=0;else if(V<0){l!=Sa.BEFORE&&(l=Sa.BEFORE,t.computeWorldVertices(c,2,4,o,0,2)),this.addBeforePosition(V,o,0,a,z);continue}else if(V>_){l!=Sa.AFTER&&(l=Sa.AFTER,t.computeWorldVertices(c,f-6,4,o,0,2)),this.addAfterPosition(V-_,o,0,a,z);continue}for(;;$++){const rt=Y[$];if(!(V>rt)){if($==0)V/=rt;else{const gt=Y[$-1];V=(V-gt)/(rt-gt)}break}}$!=l&&(l=$,d&&$==m?(t.computeWorldVertices(c,f-4,4,o,0,2),t.computeWorldVertices(c,0,4,o,4,2)):t.computeWorldVertices(c,$*6+2,8,o,0,2)),this.addCurvePosition(V,o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7],a,z,s||O>0&&N==0)}return a}d?(f+=2,o=it.setArraySize(this.world,f),t.computeWorldVertices(c,2,f-4,o,0,2),t.computeWorldVertices(c,0,2,o,f-4,2),o[f-2]=o[0],o[f-1]=o[1]):(m--,f-=4,o=it.setArraySize(this.world,f),t.computeWorldVertices(c,2,f,o,0,2));const g=it.setArraySize(this.curves,m);let p=0,y=o[0],w=o[1],b=0,x=0,S=0,C=0,A=0,v=0,M=0,E=0,T=0,R=0,k=0,I=0,P=0,F=0;for(let Y=0,_=2;Y<m;Y++,_+=6)b=o[_],x=o[_+1],S=o[_+2],C=o[_+3],A=o[_+4],v=o[_+5],M=(y-b*2+S)*.1875,E=(w-x*2+C)*.1875,T=((b-S)*3-y+A)*.09375,R=((x-C)*3-w+v)*.09375,k=M*2+T,I=E*2+R,P=(b-y)*.75+M+T*.16666667,F=(x-w)*.75+E+R*.16666667,p+=Math.sqrt(P*P+F*F),P+=k,F+=I,k+=T,I+=R,p+=Math.sqrt(P*P+F*F),P+=k,F+=I,p+=Math.sqrt(P*P+F*F),P+=k+T,F+=I+R,p+=Math.sqrt(P*P+F*F),g[Y]=p,y=A,w=v;if(n&&(h*=p),r)for(let Y=0;Y<e;Y++)i[Y]*=p;const X=this.segments;let W=0;for(let Y=0,_=0,O=0,z=0;Y<e;Y++,_+=3){const $=i[Y];h+=$;let N=h;if(d)N%=p,N<0&&(N+=p),O=0;else if(N<0){this.addBeforePosition(N,o,0,a,_);continue}else if(N>p){this.addAfterPosition(N-p,o,f-4,a,_);continue}for(;;O++){const V=g[O];if(!(N>V)){if(O==0)N/=V;else{const rt=g[O-1];N=(N-rt)/(V-rt)}break}}if(O!=l){l=O;let V=O*6;for(y=o[V],w=o[V+1],b=o[V+2],x=o[V+3],S=o[V+4],C=o[V+5],A=o[V+6],v=o[V+7],M=(y-b*2+S)*.03,E=(w-x*2+C)*.03,T=((b-S)*3-y+A)*.006,R=((x-C)*3-w+v)*.006,k=M*2+T,I=E*2+R,P=(b-y)*.3+M+T*.16666667,F=(x-w)*.3+E+R*.16666667,W=Math.sqrt(P*P+F*F),X[0]=W,V=1;V<8;V++)P+=k,F+=I,k+=T,I+=R,W+=Math.sqrt(P*P+F*F),X[V]=W;P+=k,F+=I,W+=Math.sqrt(P*P+F*F),X[8]=W,P+=k+T,F+=I+R,W+=Math.sqrt(P*P+F*F),X[9]=W,z=0}for(N*=W;;z++){const V=X[z];if(!(N>V)){if(z==0)N/=V;else{const rt=X[z-1];N=z+(N-rt)/(V-rt)}break}}this.addCurvePosition(N*.1,y,w,b,x,S,C,A,v,a,_,s||Y>0&&$==0)}return a}addBeforePosition(t,e,s,n,r){const c=e[s],h=e[s+1],i=e[s+2]-c,a=e[s+3]-h,o=Math.atan2(a,i);n[r]=c+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addAfterPosition(t,e,s,n,r){const c=e[s+2],h=e[s+3],i=c-e[s],a=h-e[s+1],o=Math.atan2(a,i);n[r]=c+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addCurvePosition(t,e,s,n,r,c,h,i,a,o,d,f){(t==0||isNaN(t))&&(t=1e-4);const m=t*t,l=m*t,g=1-t,p=g*g,y=p*g,w=g*t,b=w*3,x=g*b,S=b*t,C=e*y+n*x+c*S+i*l,A=s*y+r*x+h*S+a*l;o[d]=C,o[d+1]=A,f&&(o[d+2]=Math.atan2(A-(s*p+r*w*2+h*m),C-(e*p+n*w*2+c*m)))}};We(bo,"NONE",-1),We(bo,"BEFORE",-2),We(bo,"AFTER",-3),We(bo,"epsilon",1e-5);let df=bo;var Mx=Object.defineProperty,Ex=(u,t,e)=>t in u?Mx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,me=(u,t,e)=>Ex(u,typeof t!="symbol"?t+"":t,e);let oc=class{constructor(t,e,s){if(me(this,"matrix",new G.Matrix),me(this,"data"),me(this,"skeleton"),me(this,"parent"),me(this,"children",new Array),me(this,"x",0),me(this,"y",0),me(this,"rotation",0),me(this,"scaleX",0),me(this,"scaleY",0),me(this,"shearX",0),me(this,"shearY",0),me(this,"ax",0),me(this,"ay",0),me(this,"arotation",0),me(this,"ascaleX",0),me(this,"ascaleY",0),me(this,"ashearX",0),me(this,"ashearY",0),me(this,"appliedValid",!1),me(this,"sorted",!1),me(this,"active",!1),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=s,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,s,n,r,c,h){this.ax=t,this.ay=e,this.arotation=s,this.ascaleX=n,this.ascaleY=r,this.ashearX=c,this.ashearY=h,this.appliedValid=!0;const i=this.parent,a=this.matrix,o=this.skeleton.scaleX,d=-this.skeleton.scaleY;if(i==null){const p=this.skeleton,y=s+90+h;a.a=J.cosDeg(s+c)*n*o,a.c=J.cosDeg(y)*r*o,a.b=J.sinDeg(s+c)*n*d,a.d=J.sinDeg(y)*r*d,a.tx=t*o+p.x,a.ty=e*d+p.y;return}let f=i.matrix.a,m=i.matrix.c,l=i.matrix.b,g=i.matrix.d;switch(a.tx=f*t+m*e+i.matrix.tx,a.ty=l*t+g*e+i.matrix.ty,this.data.transformMode){case fe.Normal:{const p=s+90+h,y=J.cosDeg(s+c)*n,w=J.cosDeg(p)*r,b=J.sinDeg(s+c)*n,x=J.sinDeg(p)*r;a.a=f*y+m*b,a.c=f*w+m*x,a.b=l*y+g*b,a.d=l*w+g*x;return}case fe.OnlyTranslation:{const p=s+90+h;a.a=J.cosDeg(s+c)*n,a.c=J.cosDeg(p)*r,a.b=J.sinDeg(s+c)*n,a.d=J.sinDeg(p)*r;break}case fe.NoRotationOrReflection:{let p=f*f+l*l,y=0;p>1e-4?(p=Math.abs(f*g-m*l)/p,f/=this.skeleton.scaleX,l/=this.skeleton.scaleY,m=l*p,g=f*p,y=Math.atan2(l,f)*J.radDeg):(f=0,l=0,y=90-Math.atan2(g,m)*J.radDeg);const w=s+c-y,b=s+h-y+90,x=J.cosDeg(w)*n,S=J.cosDeg(b)*r,C=J.sinDeg(w)*n,A=J.sinDeg(b)*r;a.a=f*x-m*C,a.c=f*S-m*A,a.b=l*x+g*C,a.d=l*S+g*A;break}case fe.NoScale:case fe.NoScaleOrReflection:{const p=J.cosDeg(s),y=J.sinDeg(s);let w=(f*p+m*y)/o,b=(l*p+g*y)/d,x=Math.sqrt(w*w+b*b);x>1e-5&&(x=1/x),w*=x,b*=x,x=Math.sqrt(w*w+b*b),this.data.transformMode==fe.NoScale&&f*g-m*l<0!=(this.skeleton.scaleX<0!=this.skeleton.scaleY>0)&&(x=-x);const S=Math.PI/2+Math.atan2(b,w),C=Math.cos(S)*x,A=Math.sin(S)*x,v=J.cosDeg(c)*n,M=J.cosDeg(90+h)*r,E=J.sinDeg(c)*n,T=J.sinDeg(90+h)*r;a.a=w*v+C*E,a.c=w*M+C*T,a.b=b*v+A*E,a.d=b*M+A*T;break}}a.a*=o,a.c*=o,a.b*=d,a.d*=d}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*J.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*J.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,e=this.matrix;if(t==null){this.ax=e.tx,this.ay=e.ty,this.arotation=Math.atan2(e.b,e.a)*J.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*J.radDeg;return}const s=t.matrix,n=1/(s.a*s.d-s.b*s.c),r=e.tx-s.tx,c=e.ty-s.ty;this.ax=r*s.d*n-c*s.c*n,this.ay=c*s.a*n-r*s.b*n;const h=n*s.d,i=n*s.a,a=n*s.c,o=n*s.b,d=h*e.a-a*e.b,f=h*e.c-a*e.d,m=i*e.b-o*e.a,l=i*e.d-o*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(d*d+m*m),this.ascaleX>1e-4){const g=d*l-f*m;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(d*f+m*l,g)*J.radDeg,this.arotation=Math.atan2(m,d)*J.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(f*f+l*l),this.ashearY=0,this.arotation=90-Math.atan2(l,f)*J.radDeg}worldToLocal(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,c=e.d,h=1/(s*c-n*r),i=t.x-e.tx,a=t.y-e.ty;return t.x=i*c*h-a*n*h,t.y=a*s*h-i*r*h,t}localToWorld(t){const e=this.matrix,s=t.x,n=t.y;return t.x=s*e.a+n*e.c+e.tx,t.y=s*e.b+n*e.d+e.ty,t}worldToLocalRotation(t){const e=J.sinDeg(t),s=J.cosDeg(t),n=this.matrix;return Math.atan2(n.a*e-n.b*s,n.d*s-n.c*e)*J.radDeg}localToWorldRotation(t){const e=J.sinDeg(t),s=J.cosDeg(t),n=this.matrix;return Math.atan2(s*n.b+e*n.d,s*n.a+e*n.c)*J.radDeg}rotateWorld(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,c=e.d,h=J.cosDeg(t),i=J.sinDeg(t);e.a=h*s-i*r,e.c=h*n-i*c,e.b=i*s+h*r,e.d=i*n+h*c,this.appliedValid=!1}};var Tx=Object.defineProperty,Ix=(u,t,e)=>t in u?Tx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,vr=(u,t,e)=>Ix(u,typeof t!="symbol"?t+"":t,e);let uf=class{constructor(t,e){if(vr(this,"data"),vr(this,"bones"),vr(this,"target"),vr(this,"bendDirection",0),vr(this,"compress",!1),vr(this,"stretch",!1),vr(this,"mix",1),vr(this,"softness",0),vr(this,"active",!1),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(e.findBone(t.bones[s].name));this.target=e.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix);break}}apply1(t,e,s,n,r,c,h){t.appliedValid||t.updateAppliedTransform();const i=t.parent.matrix,a=i.a;let o=i.c;const d=i.b;let f=i.d,m=-t.ashearX-t.arotation,l=0,g=0;switch(t.data.transformMode){case fe.OnlyTranslation:l=e-t.worldX,g=s-t.worldY;break;case fe.NoRotationOrReflection:const w=Math.abs(a*f-o*d)/(a*a+d*d),b=a/t.skeleton.scaleX,x=d/t.skeleton.scaleY;o=-x*w*t.skeleton.scaleX,f=b*w*t.skeleton.scaleY,m+=Math.atan2(x,b)*J.radDeg;default:const S=e-i.tx,C=s-i.ty,A=a*f-o*d;l=(S*f-C*o)/A-t.ax,g=(C*a-S*d)/A-t.ay}m+=Math.atan2(g,l)*J.radDeg,t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let p=t.ascaleX,y=t.ascaleY;if(n||r){switch(t.data.transformMode){case fe.NoScale:case fe.NoScaleOrReflection:l=e-t.worldX,g=s-t.worldY}const w=t.data.length*p,b=Math.sqrt(l*l+g*g);if(n&&b<w||r&&b>w&&w>1e-4){const x=(b/w-1)*h+1;p*=x,c&&(y*=x)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*h,p,y,t.ashearX,t.ashearY)}apply2(t,e,s,n,r,c,h,i){if(i==0){e.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),e.appliedValid||e.updateAppliedTransform();const a=t.ax,o=t.ay;let d=t.ascaleX,f=d,m=t.ascaleY,l=e.ascaleX;const g=t.matrix;let p=0,y=0,w=0;d<0?(d=-d,p=180,w=-1):(p=0,w=1),m<0&&(m=-m,w=-w),l<0?(l=-l,y=180):y=0;const b=e.ax;let x=0,S=0,C=0,A=g.a,v=g.c,M=g.b,E=g.d;const T=Math.abs(d-m)<=1e-4;T?(x=e.ay,S=A*b+v*x+g.tx,C=M*b+E*x+g.ty):(x=0,S=A*b+g.tx,C=M*b+g.ty);const R=t.parent.matrix;A=R.a,v=R.c,M=R.b,E=R.d;const k=1/(A*E-v*M);let I=S-R.tx,P=C-R.ty;const F=(I*E-P*v)*k-a,X=(P*A-I*M)*k-o,W=Math.sqrt(F*F+X*X);let Y=e.data.length*l,_,O;if(W<1e-4){this.apply1(t,s,n,!1,c,!1,i),e.updateWorldTransformWith(b,x,0,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY);return}I=s-R.tx,P=n-R.ty;let z=(I*E-P*v)*k-a,$=(P*A-I*M)*k-o,N=z*z+$*$;if(h!=0){h*=d*(l+1)/2;const gt=Math.sqrt(N),yt=gt-W-Y*d+h;if(yt>0){let lt=Math.min(1,yt/(h*2))-1;lt=(yt-h*(1-lt*lt))/gt,z-=lt*z,$-=lt*$,N=z*z+$*$}}t:if(T){Y*=d;let gt=(N-W*W-Y*Y)/(2*W*Y);gt<-1?gt=-1:gt>1&&(gt=1,c&&(f*=(Math.sqrt(N)/(W+Y)-1)*i+1)),O=Math.acos(gt)*r,A=W+Y*gt,v=Y*Math.sin(O),_=Math.atan2($*A-z*v,z*A+$*v)}else{A=d*Y,v=m*Y;const gt=A*A,yt=v*v,lt=Math.atan2($,z);M=yt*W*W+gt*N-gt*yt;const At=-2*yt*W,Ot=yt-gt;if(E=At*At-4*Ot*M,E>=0){let Fe=Math.sqrt(E);At<0&&(Fe=-Fe),Fe=-(At+Fe)/2;const He=Fe/Ot,Qt=M/Fe,$s=Math.abs(He)<Math.abs(Qt)?He:Qt;if($s*$s<=N){P=Math.sqrt(N-$s*$s)*r,_=lt-Math.atan2(P,$s),O=Math.atan2(P/m,($s-W)/d);break t}}let ie=J.PI,bs=W-A,xs=bs*bs,Le=0,ze=0,ws=W+A,ys=ws*ws,ae=0;M=-A*W/(gt-yt),M>=-1&&M<=1&&(M=Math.acos(M),I=A*Math.cos(M)+W,P=v*Math.sin(M),E=I*I+P*P,E<xs&&(ie=M,xs=E,bs=I,Le=P),E>ys&&(ze=M,ys=E,ws=I,ae=P)),N<=(xs+ys)/2?(_=lt-Math.atan2(Le*r,bs),O=ie*r):(_=lt-Math.atan2(ae*r,ws),O=ze*r)}const V=Math.atan2(x,b)*w;let rt=t.arotation;_=(_-V)*J.radDeg+p-rt,_>180?_-=360:_<-180&&(_+=360),t.updateWorldTransformWith(a,o,rt+_*i,f,t.ascaleY,0,0),rt=e.arotation,O=((O+V)*J.radDeg-e.ashearX)*w+y-rt,O>180?O-=360:O<-180&&(O+=360),e.updateWorldTransformWith(b,x,rt+O*i,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}};var Rx=Object.defineProperty,Px=(u,t,e)=>t in u?Rx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Mr=(u,t,e)=>Px(u,typeof t!="symbol"?t+"":t,e);let ff=class{constructor(t,e){if(Mr(this,"data"),Mr(this,"bones"),Mr(this,"target"),Mr(this,"rotateMix",0),Mr(this,"translateMix",0),Mr(this,"scaleMix",0),Mr(this,"shearMix",0),Mr(this,"temp",new Bb),Mr(this,"active",!1),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(e.findBone(t.bones[s].name));this.target=e.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target,c=r.matrix,h=c.a,i=c.c,a=c.b,o=c.d,d=h*o-i*a>0?J.degRad:-J.degRad,f=this.data.offsetRotation*d,m=this.data.offsetShearY*d,l=this.bones;for(let g=0,p=l.length;g<p;g++){const y=l[g];let w=!1;const b=y.matrix;if(t!=0){const x=b.a,S=b.c,C=b.b,A=b.d;let v=Math.atan2(a,h)-Math.atan2(C,x)+f;v>J.PI?v-=J.PI2:v<-J.PI&&(v+=J.PI2),v*=t;const M=Math.cos(v),E=Math.sin(v);b.a=M*x-E*C,b.c=M*S-E*A,b.b=E*x+M*C,b.d=E*S+M*A,w=!0}if(e!=0){const x=this.temp;r.localToWorld(x.set(this.data.offsetX,this.data.offsetY)),b.tx+=(x.x-b.tx)*e,b.ty+=(x.y-b.ty)*e,w=!0}if(s>0){let x=Math.sqrt(b.a*b.a+b.b*b.b),S=Math.sqrt(h*h+a*a);x>1e-5&&(x=(x+(S-x+this.data.offsetScaleX)*s)/x),b.a*=x,b.b*=x,x=Math.sqrt(b.c*b.c+b.d*b.d),S=Math.sqrt(i*i+o*o),x>1e-5&&(x=(x+(S-x+this.data.offsetScaleY)*s)/x),b.c*=x,b.d*=x,w=!0}if(n>0){const x=b.c,S=b.d,C=Math.atan2(S,x);let A=Math.atan2(o,i)-Math.atan2(a,h)-(C-Math.atan2(b.b,b.a));A>J.PI?A-=J.PI2:A<-J.PI&&(A+=J.PI2),A=C+(A+m)*n;const v=Math.sqrt(x*x+S*S);b.c=Math.cos(A)*v,b.d=Math.sin(A)*v,w=!0}w&&(y.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target,c=r.matrix,h=c.a,i=c.c,a=c.b,o=c.d,d=h*o-i*a>0?J.degRad:-J.degRad,f=this.data.offsetRotation*d,m=this.data.offsetShearY*d,l=this.bones;for(let g=0,p=l.length;g<p;g++){const y=l[g];let w=!1;const b=y.matrix;if(t!=0){const x=b.a,S=b.c,C=b.b,A=b.d;let v=Math.atan2(a,h)+f;v>J.PI?v-=J.PI2:v<-J.PI&&(v+=J.PI2),v*=t;const M=Math.cos(v),E=Math.sin(v);b.a=M*x-E*C,b.c=M*S-E*A,b.b=E*x+M*C,b.d=E*S+M*A,w=!0}if(e!=0){const x=this.temp;r.localToWorld(x.set(this.data.offsetX,this.data.offsetY)),b.tx+=x.x*e,b.ty+=x.y*e,w=!0}if(s>0){let x=(Math.sqrt(h*h+a*a)-1+this.data.offsetScaleX)*s+1;b.a*=x,b.b*=x,x=(Math.sqrt(i*i+o*o)-1+this.data.offsetScaleY)*s+1,b.c*=x,b.d*=x,w=!0}if(n>0){let x=Math.atan2(o,i)-Math.atan2(a,h);x>J.PI?x-=J.PI2:x<-J.PI&&(x+=J.PI2);const S=b.c,C=b.d;x=Math.atan2(C,S)+(x-J.PI/2+m)*n;const A=Math.sqrt(S*S+C*C);b.c=Math.cos(x)*A,b.d=Math.sin(x)*A,w=!0}w&&(y.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target;r.appliedValid||r.updateAppliedTransform();const c=this.bones;for(let h=0,i=c.length;h<i;h++){const a=c[h];a.appliedValid||a.updateAppliedTransform();let o=a.arotation;if(t!=0){let p=r.arotation-o+this.data.offsetRotation;p-=(16384-(16384.499999999996-p/360|0))*360,o+=p*t}let d=a.ax,f=a.ay;e!=0&&(d+=(r.ax-d+this.data.offsetX)*e,f+=(r.ay-f+this.data.offsetY)*e);let m=a.ascaleX,l=a.ascaleY;s>0&&(m>1e-5&&(m=(m+(r.ascaleX-m+this.data.offsetScaleX)*s)/m),l>1e-5&&(l=(l+(r.ascaleY-l+this.data.offsetScaleY)*s)/l));const g=a.ashearY;if(n>0){let p=r.ashearY-g+this.data.offsetShearY;p-=(16384-(16384.499999999996-p/360|0))*360,a.shearY+=p*n}a.updateWorldTransformWith(d,f,o,m,l,a.ashearX,g)}}applyRelativeLocal(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target;r.appliedValid||r.updateAppliedTransform();const c=this.bones;for(let h=0,i=c.length;h<i;h++){const a=c[h];a.appliedValid||a.updateAppliedTransform();let o=a.arotation;t!=0&&(o+=(r.arotation+this.data.offsetRotation)*t);let d=a.ax,f=a.ay;e!=0&&(d+=(r.ax+this.data.offsetX)*e,f+=(r.ay+this.data.offsetY)*e);let m=a.ascaleX,l=a.ascaleY;s>0&&(m>1e-5&&(m*=(r.ascaleX-1+this.data.offsetScaleX)*s+1),l>1e-5&&(l*=(r.ascaleY-1+this.data.offsetScaleY)*s+1));let g=a.ashearY;n>0&&(g+=(r.ashearY+this.data.offsetShearY)*n),a.updateWorldTransformWith(d,f,o,m,l,a.ashearX,g)}}};var kx=Object.defineProperty,Fx=(u,t,e)=>t in u?kx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ls=(u,t,e)=>Fx(u,typeof t!="symbol"?t+"":t,e);const mf=class Wo{constructor(t){if(ls(this,"data"),ls(this,"bones"),ls(this,"slots"),ls(this,"drawOrder"),ls(this,"ikConstraints"),ls(this,"transformConstraints"),ls(this,"pathConstraints"),ls(this,"_updateCache",new Array),ls(this,"updateCacheReset",new Array),ls(this,"skin"),ls(this,"color"),ls(this,"time",0),ls(this,"scaleX",1),ls(this,"scaleY",1),ls(this,"x",0),ls(this,"y",0),t==null)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const s=t.bones[e];let n;if(s.parent==null)n=new oc(s,this,null);else{const r=this.bones[s.parent.index];n=new oc(s,this,r),r.children.push(n)}this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const s=t.slots[e],n=this.bones[s.boneData.index],r=new Ql(s,n);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const s=t.ikConstraints[e];this.ikConstraints.push(new uf(s,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const s=t.transformConstraints[e];this.transformConstraints.push(new ff(s,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const s=t.pathConstraints[e];this.pathConstraints.push(new df(s,this))}this.color=new Ut(1,1,1,1),this.updateCache()}updateCache(){const t=this._updateCache;t.length=0,this.updateCacheReset.length=0;const e=this.bones;for(let o=0,d=e.length;o<d;o++){const f=e[o];f.sorted=f.data.skinRequired,f.active=!f.sorted}if(this.skin!=null){const o=this.skin.bones;for(let d=0,f=this.skin.bones.length;d<f;d++){let m=this.bones[o[d].index];do m.sorted=!1,m.active=!0,m=m.parent;while(m!=null)}}const s=this.ikConstraints,n=this.transformConstraints,r=this.pathConstraints,c=s.length,h=n.length,i=r.length,a=c+h+i;t:for(let o=0;o<a;o++){for(let d=0;d<c;d++){const f=s[d];if(f.data.order==o){this.sortIkConstraint(f);continue t}}for(let d=0;d<h;d++){const f=n[d];if(f.data.order==o){this.sortTransformConstraint(f);continue t}}for(let d=0;d<i;d++){const f=r[d];if(f.data.order==o){this.sortPathConstraint(f);continue t}}}for(let o=0,d=e.length;o<d;o++)this.sortBone(e[o])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin!=null&&it.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target;this.sortBone(e);const s=t.bones,n=s[0];if(this.sortBone(n),s.length>1){const r=s[s.length-1];this._updateCache.indexOf(r)>-1||this.updateCacheReset.push(r)}this._updateCache.push(t),this.sortReset(n.children),s[s.length-1].sorted=!0}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||this.skin!=null&&it.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target,s=e.data.index,n=e.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,s,n),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,n);for(let i=0,a=this.data.skins.length;i<a;i++)this.sortPathConstraintAttachment(this.data.skins[i],s,n);const r=e.getAttachment();r instanceof go&&this.sortPathConstraintAttachmentWith(r,n);const c=t.bones,h=c.length;for(let i=0;i<h;i++)this.sortBone(c[i]);this._updateCache.push(t);for(let i=0;i<h;i++)this.sortReset(c[i].children);for(let i=0;i<h;i++)c[i].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin!=null&&it.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);const e=t.bones,s=e.length;if(t.data.local)for(let n=0;n<s;n++){const r=e[n];this.sortBone(r.parent),this._updateCache.indexOf(r)>-1||this.updateCacheReset.push(r)}else for(let n=0;n<s;n++)this.sortBone(e[n]);this._updateCache.push(t);for(let n=0;n<s;n++)this.sortReset(e[n].children);for(let n=0;n<s;n++)e[n].sorted=!0}sortPathConstraintAttachment(t,e,s){const n=t.attachments[e];if(n)for(const r in n)this.sortPathConstraintAttachmentWith(n[r],s)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof go))return;const s=t.bones;if(s==null)this.sortBone(e);else{const n=this.bones;let r=0;for(;r<s.length;){const c=s[r++];for(let h=r+c;r<h;r++){const i=s[r];this.sortBone(n[i])}}}}sortBone(t){if(t.sorted)return;const e=t.parent;e!=null&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,s=t.length;e<s;e++){const n=t[e];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(){const t=this.updateCacheReset;for(let s=0,n=t.length;s<n;s++){const r=t[s];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY,r.appliedValid=!0}const e=this._updateCache;for(let s=0,n=e.length;s<n;s++)e[s].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let r=0,c=t.length;r<c;r++)t[r].setToSetupPose();const e=this.ikConstraints;for(let r=0,c=e.length;r<c;r++){const h=e[r];h.mix=h.data.mix,h.softness=h.data.softness,h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch}const s=this.transformConstraints;for(let r=0,c=s.length;r<c;r++){const h=s[r],i=h.data;h.rotateMix=i.rotateMix,h.translateMix=i.translateMix,h.scaleMix=i.scaleMix,h.shearMix=i.shearMix}const n=this.pathConstraints;for(let r=0,c=n.length;r<c;r++){const h=n[r],i=h.data;h.position=i.position,h.spacing=i.spacing,h.rotateMix=i.rotateMix,h.translateMix=i.translateMix}}setSlotsToSetupPose(){const t=this.slots;it.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,s=t.length;e<s;e++)t[e].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(e==null)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(t!=null)if(this.skin!=null)t.attachAll(this,this.skin);else{const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s],c=r.data.attachmentName;if(c!=null){const h=t.getAttachment(s,c);h!=null&&r.setAttachment(h)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){return this.getAttachment(this.data.findSlotIndex(t),e)}getAttachment(t,e){if(e==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const s=this.skin.getAttachment(t,e);if(s!=null)return s}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(t==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,r=s.length;n<r;n++){const c=s[n];if(c.data.name==t){let h=null;if(e!=null&&(h=this.getAttachment(n,e),h==null))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);c.setAttachment(h);return}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}getBounds(t,e,s=new Array(2)){if(t==null)throw new Error("offset cannot be null.");if(e==null)throw new Error("size cannot be null.");const n=this.drawOrder;let r=Number.POSITIVE_INFINITY,c=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY,i=Number.NEGATIVE_INFINITY;for(let a=0,o=n.length;a<o;a++){const d=n[a];if(!d.bone.active)continue;let f=0,m=null;const l=d.getAttachment();if(l instanceof Jl)f=8,m=it.setArraySize(s,f,0),l.computeWorldVertices(d.bone,m,0,2);else if(l instanceof sl){const g=l;f=g.worldVerticesLength,m=it.setArraySize(s,f,0),g.computeWorldVertices(d,0,f,m,0,2)}if(m!=null)for(let g=0,p=m.length;g<p;g+=2){const y=m[g],w=m[g+1];r=Math.min(r,y),c=Math.min(c,w),h=Math.max(h,y),i=Math.max(i,w)}}t.set(r,c),e.set(h-r,i-c)}update(t){this.time+=t}get flipX(){return this.scaleX==-1}set flipX(t){Wo.deprecatedWarning1||(Wo.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return this.scaleY==-1}set flipY(t){Wo.deprecatedWarning1||(Wo.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};ls(mf,"deprecatedWarning1",!1);let gf=mf;var Yx=Object.defineProperty,$x=(u,t,e)=>t in u?Yx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ji=(u,t,e)=>$x(u,typeof t!="symbol"?t+"":t,e);let lc=class{constructor(t,e){if(ji(this,"data"),ji(this,"intValue"),ji(this,"floatValue"),ji(this,"stringValue"),ji(this,"time"),ji(this,"volume"),ji(this,"balance"),e==null)throw new Error("data cannot be null.");this.time=t,this.data=e}};var _x=Object.defineProperty,Xx=(u,t,e)=>t in u?_x(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,_e=(u,t,e)=>Xx(u,typeof t!="symbol"?t+"":t,e);let cc=class{constructor(){_e(this,"name"),_e(this,"bones",new Array),_e(this,"slots",new Array),_e(this,"skins",new Array),_e(this,"defaultSkin"),_e(this,"events",new Array),_e(this,"animations",new Array),_e(this,"ikConstraints",new Array),_e(this,"transformConstraints",new Array),_e(this,"pathConstraints",new Array),_e(this,"x"),_e(this,"y"),_e(this,"width"),_e(this,"height"),_e(this,"version"),_e(this,"hash"),_e(this,"fps",0),_e(this,"imagesPath"),_e(this,"audioPath")}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const e=this.skins;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const e=this.events;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const e=this.animations;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}};var Bx=Object.defineProperty,Vx=(u,t,e)=>t in u?Bx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ta=(u,t,e)=>Vx(u,typeof t!="symbol"?t+"":t,e);let hc=class{constructor(t,e,s){if(ta(this,"index"),ta(this,"name"),ta(this,"boneData"),ta(this,"color",new Ut(1,1,1,1)),ta(this,"darkColor"),ta(this,"attachmentName"),ta(this,"blendMode"),t<0)throw new Error("index must be >= 0.");if(e==null)throw new Error("name cannot be null.");if(s==null)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=s}};var Nx=Object.defineProperty,Dx=(u,t,e)=>t in u?Nx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,qs=(u,t,e)=>Dx(u,typeof t!="symbol"?t+"":t,e);let dc=class{constructor(t,e,s){if(qs(this,"index"),qs(this,"name"),qs(this,"parent"),qs(this,"length"),qs(this,"x",0),qs(this,"y",0),qs(this,"rotation",0),qs(this,"scaleX",1),qs(this,"scaleY",1),qs(this,"shearX",0),qs(this,"shearY",0),qs(this,"transformMode",fe.Normal),qs(this,"skinRequired",!1),qs(this,"color",new Ut),t<0)throw new Error("index must be >= 0.");if(e==null)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=s}};var Lx=Object.defineProperty,Ox=(u,t,e)=>t in u?Lx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,si=(u,t,e)=>Ox(u,typeof t!="symbol"?t+"":t,e);let uc=class extends nl{constructor(t){super(t,0,!1),si(this,"bones",new Array),si(this,"target"),si(this,"bendDirection",1),si(this,"compress",!1),si(this,"stretch",!1),si(this,"uniform",!1),si(this,"mix",1),si(this,"softness",0)}};var Wx=Object.defineProperty,Ux=(u,t,e)=>t in u?Wx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Gs=(u,t,e)=>Ux(u,typeof t!="symbol"?t+"":t,e);let fc=class extends nl{constructor(t){super(t,0,!1),Gs(this,"bones",new Array),Gs(this,"target"),Gs(this,"rotateMix",0),Gs(this,"translateMix",0),Gs(this,"scaleMix",0),Gs(this,"shearMix",0),Gs(this,"offsetRotation",0),Gs(this,"offsetX",0),Gs(this,"offsetY",0),Gs(this,"offsetScaleX",0),Gs(this,"offsetScaleY",0),Gs(this,"offsetShearY",0),Gs(this,"relative",!1),Gs(this,"local",!1)}};var qx=Object.defineProperty,Gx=(u,t,e)=>t in u?qx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,rl=(u,t,e)=>Gx(u,typeof t!="symbol"?t+"":t,e);let mc=class{constructor(t,e,s){this.slotIndex=t,this.name=e,this.attachment=s}},il=class{constructor(t){if(rl(this,"name"),rl(this,"attachments",new Array),rl(this,"bones",Array()),rl(this,"constraints",new Array),t==null)throw new Error("name cannot be null.");this.name=t}setAttachment(t,e,s){if(s==null)throw new Error("attachment cannot be null.");const n=this.attachments;t>=n.length&&(n.length=t+1),n[t]||(n[t]={}),n[t][e]=s}addSkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];this.setAttachment(n.slotIndex,n.name,n.attachment)}}copySkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];n.attachment!=null&&(n.attachment instanceof sl?(n.attachment=n.attachment.newLinkedMesh(),this.setAttachment(n.slotIndex,n.name,n.attachment)):(n.attachment=n.attachment.copy(),this.setAttachment(n.slotIndex,n.name,n.attachment)))}}getAttachment(t,e){const s=this.attachments[t];return s?s[e]:null}removeAttachment(t,e){const s=this.attachments[t];s&&(s[e]=null)}getAttachments(){const t=new Array;for(let e=0;e<this.attachments.length;e++){const s=this.attachments[e];if(s)for(const n in s){const r=s[n];r&&t.push(new mc(e,n,r))}}return t}getAttachmentsForSlot(t,e){const s=this.attachments[t];if(s)for(const n in s){const r=s[n];r&&e.push(new mc(t,n,r))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,e){let s=0;for(let n=0;n<t.slots.length;n++){const r=t.slots[n],c=r.getAttachment();if(c&&s<e.attachments.length){const h=e.attachments[s];for(const i in h){const a=h[i];if(c==a){const o=this.getAttachment(s,i);o!=null&&r.setAttachment(o);break}}}s++}}};var zx=Object.defineProperty,Hx=(u,t,e)=>t in u?zx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ea=(u,t,e)=>Hx(u,typeof t!="symbol"?t+"":t,e);let gc=class{constructor(t){ea(this,"name"),ea(this,"intValue"),ea(this,"floatValue"),ea(this,"stringValue"),ea(this,"audioPath"),ea(this,"volume"),ea(this,"balance"),this.name=t}},Kx=class{constructor(t,e=new Array,s=0,n=new DataView(t.buffer)){this.strings=e,this.index=s,this.buffer=n}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),s=e&127;return e&128&&(e=this.readByte(),s|=(e&127)<<7,e&128&&(e=this.readByte(),s|=(e&127)<<14,e&128&&(e=this.readByte(),s|=(e&127)<<21,e&128&&(e=this.readByte(),s|=(e&127)<<28)))),t?s:s>>>1^-(s&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let s=0;s<t;){const n=this.readUnsignedByte();switch(n>>4){case 12:case 13:e+=String.fromCharCode((n&31)<<6|this.readByte()&63),s+=2;break;case 14:e+=String.fromCharCode((n&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),s+=3;break;default:e+=String.fromCharCode(n),s++}}return e}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}};var Zx=Object.defineProperty,Qx=(u,t,e)=>t in u?Zx(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,te=(u,t,e)=>Qx(u,typeof t!="symbol"?t+"":t,e);const ke=class xe{constructor(t){te(this,"attachmentLoader"),te(this,"scale",1),te(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new cc;s.name="";const n=new Kx(t);s.hash=n.readString(),s.version=n.readString(),s.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),s.x=n.readFloat(),s.y=n.readFloat(),s.width=n.readFloat(),s.height=n.readFloat();const r=n.readBoolean();r&&(s.fps=n.readFloat(),s.imagesPath=n.readString(),s.audioPath=n.readString());let c=0;c=n.readInt(!0);for(let i=0;i<c;i++)n.strings.push(n.readString());c=n.readInt(!0);for(let i=0;i<c;i++){const a=n.readString(),o=i==0?null:s.bones[n.readInt(!0)],d=new dc(i,a,o);d.rotation=n.readFloat(),d.x=n.readFloat()*e,d.y=n.readFloat()*e,d.scaleX=n.readFloat(),d.scaleY=n.readFloat(),d.shearX=n.readFloat(),d.shearY=n.readFloat(),d.length=n.readFloat()*e,d.transformMode=xe.TransformModeValues[n.readInt(!0)],d.skinRequired=n.readBoolean(),r&&Ut.rgba8888ToColor(d.color,n.readInt32()),s.bones.push(d)}c=n.readInt(!0);for(let i=0;i<c;i++){const a=n.readString(),o=s.bones[n.readInt(!0)],d=new hc(i,a,o);Ut.rgba8888ToColor(d.color,n.readInt32());const f=n.readInt32();f!=-1&&Ut.rgb888ToColor(d.darkColor=new Ut,f),d.attachmentName=n.readStringRef(),d.blendMode=xe.BlendModeValues[n.readInt(!0)],s.slots.push(d)}c=n.readInt(!0);for(let i=0,a;i<c;i++){const o=new uc(n.readString());o.order=n.readInt(!0),o.skinRequired=n.readBoolean(),a=n.readInt(!0);for(let d=0;d<a;d++)o.bones.push(s.bones[n.readInt(!0)]);o.target=s.bones[n.readInt(!0)],o.mix=n.readFloat(),o.softness=n.readFloat()*e,o.bendDirection=n.readByte(),o.compress=n.readBoolean(),o.stretch=n.readBoolean(),o.uniform=n.readBoolean(),s.ikConstraints.push(o)}c=n.readInt(!0);for(let i=0,a;i<c;i++){const o=new fc(n.readString());o.order=n.readInt(!0),o.skinRequired=n.readBoolean(),a=n.readInt(!0);for(let d=0;d<a;d++)o.bones.push(s.bones[n.readInt(!0)]);o.target=s.bones[n.readInt(!0)],o.local=n.readBoolean(),o.relative=n.readBoolean(),o.offsetRotation=n.readFloat(),o.offsetX=n.readFloat()*e,o.offsetY=n.readFloat()*e,o.offsetScaleX=n.readFloat(),o.offsetScaleY=n.readFloat(),o.offsetShearY=n.readFloat(),o.rotateMix=n.readFloat(),o.translateMix=n.readFloat(),o.scaleMix=n.readFloat(),o.shearMix=n.readFloat(),s.transformConstraints.push(o)}c=n.readInt(!0);for(let i=0,a;i<c;i++){const o=new ac(n.readString());o.order=n.readInt(!0),o.skinRequired=n.readBoolean(),a=n.readInt(!0);for(let d=0;d<a;d++)o.bones.push(s.bones[n.readInt(!0)]);o.target=s.slots[n.readInt(!0)],o.positionMode=xe.PositionModeValues[n.readInt(!0)],o.spacingMode=xe.SpacingModeValues[n.readInt(!0)],o.rotateMode=xe.RotateModeValues[n.readInt(!0)],o.offsetRotation=n.readFloat(),o.position=n.readFloat(),o.positionMode==nr.Fixed&&(o.position*=e),o.spacing=n.readFloat(),(o.spacingMode==Oe.Length||o.spacingMode==Oe.Fixed)&&(o.spacing*=e),o.rotateMix=n.readFloat(),o.translateMix=n.readFloat(),s.pathConstraints.push(o)}const h=this.readSkin(n,s,!0,r);h!=null&&(s.defaultSkin=h,s.skins.push(h));{let i=s.skins.length;for(it.setArraySize(s.skins,c=i+n.readInt(!0));i<c;i++)s.skins[i]=this.readSkin(n,s,!1,r)}c=this.linkedMeshes.length;for(let i=0;i<c;i++){const a=this.linkedMeshes[i],o=a.skin==null?s.defaultSkin:s.findSkin(a.skin);if(o==null)throw new Error(`Skin not found: ${a.skin}`);const d=o.getAttachment(a.slotIndex,a.parent);if(d==null)throw new Error(`Parent mesh not found: ${a.parent}`);a.mesh.deformAttachment=a.inheritDeform?d:a.mesh,a.mesh.setParentMesh(d)}this.linkedMeshes.length=0,c=n.readInt(!0);for(let i=0;i<c;i++){const a=new gc(n.readStringRef());a.intValue=n.readInt(!1),a.floatValue=n.readFloat(),a.stringValue=n.readString(),a.audioPath=n.readString(),a.audioPath!=null&&(a.volume=n.readFloat(),a.balance=n.readFloat()),s.events.push(a)}c=n.readInt(!0);for(let i=0;i<c;i++)s.animations.push(this.readAnimation(n,n.readString(),s));return s}readSkin(t,e,s,n){let r=null,c=0;if(s){if(c=t.readInt(!0),c==0)return null;r=new il("default")}else{r=new il(t.readStringRef()),r.bones.length=t.readInt(!0);for(let h=0,i=r.bones.length;h<i;h++)r.bones[h]=e.bones[t.readInt(!0)];for(let h=0,i=t.readInt(!0);h<i;h++)r.constraints.push(e.ikConstraints[t.readInt(!0)]);for(let h=0,i=t.readInt(!0);h<i;h++)r.constraints.push(e.transformConstraints[t.readInt(!0)]);for(let h=0,i=t.readInt(!0);h<i;h++)r.constraints.push(e.pathConstraints[t.readInt(!0)]);c=t.readInt(!0)}for(let h=0;h<c;h++){const i=t.readInt(!0);for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readStringRef(),f=this.readAttachment(t,e,r,i,d,n);f!=null&&r.setAttachment(i,d,f)}}return r}readAttachment(t,e,s,n,r,c){const h=this.scale;let i=t.readStringRef();i==null&&(i=r);const a=t.readByte();switch(xe.AttachmentTypeValues[a]){case we.Region:{let d=t.readStringRef();const f=t.readFloat(),m=t.readFloat(),l=t.readFloat(),g=t.readFloat(),p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),b=t.readInt32();d==null&&(d=i);const x=this.attachmentLoader.newRegionAttachment(s,i,d);return x==null?null:(x.path=d,x.x=m*h,x.y=l*h,x.scaleX=g,x.scaleY=p,x.rotation=f,x.width=y*h,x.height=w*h,Ut.rgba8888ToColor(x.color,b),x)}case we.BoundingBox:{const d=t.readInt(!0),f=this.readVertices(t,d),m=c?t.readInt32():0,l=this.attachmentLoader.newBoundingBoxAttachment(s,i);return l==null?null:(l.worldVerticesLength=d<<1,l.vertices=f.vertices,l.bones=f.bones,c&&Ut.rgba8888ToColor(l.color,m),l)}case we.Mesh:{let d=t.readStringRef();const f=t.readInt32(),m=t.readInt(!0),l=this.readFloatArray(t,m<<1,1),g=this.readShortArray(t),p=this.readVertices(t,m),y=t.readInt(!0);let w=null,b=0,x=0;c&&(w=this.readShortArray(t),b=t.readFloat(),x=t.readFloat()),d==null&&(d=i);const S=this.attachmentLoader.newMeshAttachment(s,i,d);return S==null?null:(S.path=d,Ut.rgba8888ToColor(S.color,f),S.bones=p.bones,S.vertices=p.vertices,S.worldVerticesLength=m<<1,S.triangles=g,S.regionUVs=new Float32Array(l),S.hullLength=y<<1,c&&(S.edges=w,S.width=b*h,S.height=x*h),S)}case we.LinkedMesh:{let d=t.readStringRef();const f=t.readInt32(),m=t.readStringRef(),l=t.readStringRef(),g=t.readBoolean();let p=0,y=0;c&&(p=t.readFloat(),y=t.readFloat()),d==null&&(d=i);const w=this.attachmentLoader.newMeshAttachment(s,i,d);return w==null?null:(w.path=d,Ut.rgba8888ToColor(w.color,f),c&&(w.width=p*h,w.height=y*h),this.linkedMeshes.push(new Jx(w,m,n,l,g)),w)}case we.Path:{const d=t.readBoolean(),f=t.readBoolean(),m=t.readInt(!0),l=this.readVertices(t,m),g=it.newArray(m/3,0);for(let w=0,b=g.length;w<b;w++)g[w]=t.readFloat()*h;const p=c?t.readInt32():0,y=this.attachmentLoader.newPathAttachment(s,i);return y==null?null:(y.closed=d,y.constantSpeed=f,y.worldVerticesLength=m<<1,y.vertices=l.vertices,y.bones=l.bones,y.lengths=g,c&&Ut.rgba8888ToColor(y.color,p),y)}case we.Point:{const d=t.readFloat(),f=t.readFloat(),m=t.readFloat(),l=c?t.readInt32():0,g=this.attachmentLoader.newPointAttachment(s,i);return g==null?null:(g.x=f*h,g.y=m*h,g.rotation=d,c&&Ut.rgba8888ToColor(g.color,l),g)}case we.Clipping:{const d=t.readInt(!0),f=t.readInt(!0),m=this.readVertices(t,f),l=c?t.readInt32():0,g=this.attachmentLoader.newClippingAttachment(s,i);return g==null?null:(g.endSlot=e.slots[d],g.worldVerticesLength=f<<1,g.vertices=m.vertices,g.bones=m.bones,c&&Ut.rgba8888ToColor(g.color,l),g)}}return null}readVertices(t,e){const s=e<<1,n=new jx,r=this.scale;if(!t.readBoolean())return n.vertices=this.readFloatArray(t,s,r),n;const c=new Array,h=new Array;for(let i=0;i<e;i++){const a=t.readInt(!0);h.push(a);for(let o=0;o<a;o++)h.push(t.readInt(!0)),c.push(t.readFloat()*r),c.push(t.readFloat()*r),c.push(t.readFloat())}return n.vertices=it.toFloatArray(c),n.bones=h,n}readFloatArray(t,e,s){const n=new Array(e);if(s==1)for(let r=0;r<e;r++)n[r]=t.readFloat();else for(let r=0;r<e;r++)n[r]=t.readFloat()*s;return n}readShortArray(t){const e=t.readInt(!0),s=new Array(e);for(let n=0;n<e;n++)s[n]=t.readShort();return s}readAnimation(t,e,s){const n=new Array,r=this.scale;let c=0;const h=new Ut,i=new Ut;for(let d=0,f=t.readInt(!0);d<f;d++){const m=t.readInt(!0);for(let l=0,g=t.readInt(!0);l<g;l++){const p=t.readByte(),y=t.readInt(!0);switch(p){case xe.SLOT_ATTACHMENT:{const w=new Qi(y);w.slotIndex=m;for(let b=0;b<y;b++)w.setFrame(b,t.readFloat(),t.readStringRef());n.push(w),c=Math.max(c,w.frames[y-1]);break}case xe.SLOT_COLOR:{const w=new oo(y);w.slotIndex=m;for(let b=0;b<y;b++){const x=t.readFloat();Ut.rgba8888ToColor(h,t.readInt32()),w.setFrame(b,x,h.r,h.g,h.b,h.a),b<y-1&&this.readCurve(t,b,w)}n.push(w),c=Math.max(c,w.frames[(y-1)*oo.ENTRIES]);break}case xe.SLOT_TWO_COLOR:{const w=new lo(y);w.slotIndex=m;for(let b=0;b<y;b++){const x=t.readFloat();Ut.rgba8888ToColor(h,t.readInt32()),Ut.rgb888ToColor(i,t.readInt32()),w.setFrame(b,x,h.r,h.g,h.b,h.a,i.r,i.g,i.b),b<y-1&&this.readCurve(t,b,w)}n.push(w),c=Math.max(c,w.frames[(y-1)*lo.ENTRIES]);break}}}}for(let d=0,f=t.readInt(!0);d<f;d++){const m=t.readInt(!0);for(let l=0,g=t.readInt(!0);l<g;l++){const p=t.readByte(),y=t.readInt(!0);switch(p){case xe.BONE_ROTATE:{const w=new rn(y);w.boneIndex=m;for(let b=0;b<y;b++)w.setFrame(b,t.readFloat(),t.readFloat()),b<y-1&&this.readCurve(t,b,w);n.push(w),c=Math.max(c,w.frames[(y-1)*rn.ENTRIES]);break}case xe.BONE_TRANSLATE:case xe.BONE_SCALE:case xe.BONE_SHEAR:{let w,b=1;p==xe.BONE_SCALE?w=new jl(y):p==xe.BONE_SHEAR?w=new tc(y):(w=new Zi(y),b=r),w.boneIndex=m;for(let x=0;x<y;x++)w.setFrame(x,t.readFloat(),t.readFloat()*b,t.readFloat()*b),x<y-1&&this.readCurve(t,x,w);n.push(w),c=Math.max(c,w.frames[(y-1)*Zi.ENTRIES]);break}}}}for(let d=0,f=t.readInt(!0);d<f;d++){const m=t.readInt(!0),l=t.readInt(!0),g=new co(l);g.ikConstraintIndex=m;for(let p=0;p<l;p++)g.setFrame(p,t.readFloat(),t.readFloat(),t.readFloat()*r,t.readByte(),t.readBoolean(),t.readBoolean()),p<l-1&&this.readCurve(t,p,g);n.push(g),c=Math.max(c,g.frames[(l-1)*co.ENTRIES])}for(let d=0,f=t.readInt(!0);d<f;d++){const m=t.readInt(!0),l=t.readInt(!0),g=new ho(l);g.transformConstraintIndex=m;for(let p=0;p<l;p++)g.setFrame(p,t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat()),p<l-1&&this.readCurve(t,p,g);n.push(g),c=Math.max(c,g.frames[(l-1)*ho.ENTRIES])}for(let d=0,f=t.readInt(!0);d<f;d++){const m=t.readInt(!0),l=s.pathConstraints[m];for(let g=0,p=t.readInt(!0);g<p;g++){const y=t.readByte(),w=t.readInt(!0);switch(y){case xe.PATH_POSITION:case xe.PATH_SPACING:{let b,x=1;y==xe.PATH_SPACING?(b=new sc(w),(l.spacingMode==Oe.Length||l.spacingMode==Oe.Fixed)&&(x=r)):(b=new va(w),l.positionMode==nr.Fixed&&(x=r)),b.pathConstraintIndex=m;for(let S=0;S<w;S++)b.setFrame(S,t.readFloat(),t.readFloat()*x),S<w-1&&this.readCurve(t,S,b);n.push(b),c=Math.max(c,b.frames[(w-1)*va.ENTRIES]);break}case xe.PATH_MIX:{const b=new fo(w);b.pathConstraintIndex=m;for(let x=0;x<w;x++)b.setFrame(x,t.readFloat(),t.readFloat(),t.readFloat()),x<w-1&&this.readCurve(t,x,b);n.push(b),c=Math.max(c,b.frames[(w-1)*fo.ENTRIES]);break}}}}for(let d=0,f=t.readInt(!0);d<f;d++){const m=s.skins[t.readInt(!0)];for(let l=0,g=t.readInt(!0);l<g;l++){const p=t.readInt(!0);for(let y=0,w=t.readInt(!0);y<w;y++){const b=m.getAttachment(p,t.readStringRef()),x=b.bones!=null,S=b.vertices,C=x?S.length/3*2:S.length,A=t.readInt(!0),v=new ec(A);v.slotIndex=p,v.attachment=b;for(let M=0;M<A;M++){const E=t.readFloat();let T,R=t.readInt(!0);if(R==0)T=x?it.newFloatArray(C):S;else{T=it.newFloatArray(C);const k=t.readInt(!0);if(R+=k,r==1)for(let I=k;I<R;I++)T[I]=t.readFloat();else for(let I=k;I<R;I++)T[I]=t.readFloat()*r;if(!x)for(let I=0,P=T.length;I<P;I++)T[I]+=S[I]}v.setFrame(M,E,T),M<A-1&&this.readCurve(t,M,v)}n.push(v),c=Math.max(c,v.frames[A-1])}}}const a=t.readInt(!0);if(a>0){const d=new Aa(a),f=s.slots.length;for(let m=0;m<a;m++){const l=t.readFloat(),g=t.readInt(!0),p=it.newArray(f,0);for(let x=f-1;x>=0;x--)p[x]=-1;const y=it.newArray(f-g,0);let w=0,b=0;for(let x=0;x<g;x++){const S=t.readInt(!0);for(;w!=S;)y[b++]=w++;p[w+t.readInt(!0)]=w++}for(;w<f;)y[b++]=w++;for(let x=f-1;x>=0;x--)p[x]==-1&&(p[x]=y[--b]);d.setFrame(m,l,p)}n.push(d),c=Math.max(c,d.frames[a-1])}const o=t.readInt(!0);if(o>0){const d=new tl(o);for(let f=0;f<o;f++){const m=t.readFloat(),l=s.events[t.readInt(!0)],g=new lc(m,l);g.intValue=t.readInt(!1),g.floatValue=t.readFloat(),g.stringValue=t.readBoolean()?t.readString():l.stringValue,g.data.audioPath!=null&&(g.volume=t.readFloat(),g.balance=t.readFloat()),d.setFrame(f,g)}n.push(d),c=Math.max(c,d.frames[o-1])}return new ye(e,n,c)}readCurve(t,e,s){switch(t.readByte()){case xe.CURVE_STEPPED:s.setStepped(e);break;case xe.CURVE_BEZIER:this.setCurve(s,e,t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat());break}}setCurve(t,e,s,n,r,c){t.setCurve(e,s,n,r,c)}};te(ke,"AttachmentTypeValues",[0,1,2,3,4,5,6]),te(ke,"TransformModeValues",[fe.Normal,fe.OnlyTranslation,fe.NoRotationOrReflection,fe.NoScale,fe.NoScaleOrReflection]),te(ke,"PositionModeValues",[nr.Fixed,nr.Percent]),te(ke,"SpacingModeValues",[Oe.Length,Oe.Fixed,Oe.Percent]),te(ke,"RotateModeValues",[rr.Tangent,rr.Chain,rr.ChainScale]),te(ke,"BlendModeValues",[G.BLEND_MODES.NORMAL,G.BLEND_MODES.ADD,G.BLEND_MODES.MULTIPLY,G.BLEND_MODES.SCREEN]),te(ke,"BONE_ROTATE",0),te(ke,"BONE_TRANSLATE",1),te(ke,"BONE_SCALE",2),te(ke,"BONE_SHEAR",3),te(ke,"SLOT_ATTACHMENT",0),te(ke,"SLOT_COLOR",1),te(ke,"SLOT_TWO_COLOR",2),te(ke,"PATH_POSITION",0),te(ke,"PATH_SPACING",1),te(ke,"PATH_MIX",2),te(ke,"CURVE_LINEAR",0),te(ke,"CURVE_STEPPED",1),te(ke,"CURVE_BEZIER",2);let pf=ke,Jx=class{constructor(t,e,s,n,r){te(this,"parent"),te(this,"skin"),te(this,"slotIndex"),te(this,"mesh"),te(this,"inheritDeform"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritDeform=r}},jx=class{constructor(t=null,e=null){this.bones=t,this.vertices=e}};var t1=Object.defineProperty,e1=(u,t,e)=>t in u?t1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ni=(u,t,e)=>e1(u,typeof t!="symbol"?t+"":t,e);let bf=class La{constructor(t){ni(this,"attachmentLoader"),ni(this,"scale",1),ni(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new cc,n=typeof t=="string"?JSON.parse(t):t,r=n.skeleton;if(r!=null){if(s.hash=r.hash,s.version=r.spine,s.version.substr(0,3)!=="3.8"){const c=`Spine 3.8 loader cant load version ${r.spine}. Please configure your pixi-spine bundle`;console.error(c)}s.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),s.x=r.x,s.y=r.y,s.width=r.width,s.height=r.height,s.fps=r.fps,s.imagesPath=r.images}if(n.bones)for(let c=0;c<n.bones.length;c++){const h=n.bones[c];let i=null;const a=this.getValue(h,"parent",null);if(a!=null&&(i=s.findBone(a),i==null))throw new Error(`Parent bone not found: ${a}`);const o=new dc(s.bones.length,h.name,i);o.length=this.getValue(h,"length",0)*e,o.x=this.getValue(h,"x",0)*e,o.y=this.getValue(h,"y",0)*e,o.rotation=this.getValue(h,"rotation",0),o.scaleX=this.getValue(h,"scaleX",1),o.scaleY=this.getValue(h,"scaleY",1),o.shearX=this.getValue(h,"shearX",0),o.shearY=this.getValue(h,"shearY",0),o.transformMode=La.transformModeFromString(this.getValue(h,"transform","normal")),o.skinRequired=this.getValue(h,"skin",!1),s.bones.push(o)}if(n.slots)for(let c=0;c<n.slots.length;c++){const h=n.slots[c],i=h.name,a=h.bone,o=s.findBone(a);if(o==null)throw new Error(`Slot bone not found: ${a}`);const d=new hc(s.slots.length,i,o),f=this.getValue(h,"color",null);f!=null&&d.color.setFromString(f);const m=this.getValue(h,"dark",null);m!=null&&(d.darkColor=new Ut(1,1,1,1),d.darkColor.setFromString(m)),d.attachmentName=this.getValue(h,"attachment",null),d.blendMode=La.blendModeFromString(this.getValue(h,"blend","normal")),s.slots.push(d)}if(n.ik)for(let c=0;c<n.ik.length;c++){const h=n.ik[c],i=new uc(h.name);i.order=this.getValue(h,"order",0),i.skinRequired=this.getValue(h,"skin",!1);for(let o=0;o<h.bones.length;o++){const d=h.bones[o],f=s.findBone(d);if(f==null)throw new Error(`IK bone not found: ${d}`);i.bones.push(f)}const a=h.target;if(i.target=s.findBone(a),i.target==null)throw new Error(`IK target bone not found: ${a}`);i.mix=this.getValue(h,"mix",1),i.softness=this.getValue(h,"softness",0)*e,i.bendDirection=this.getValue(h,"bendPositive",!0)?1:-1,i.compress=this.getValue(h,"compress",!1),i.stretch=this.getValue(h,"stretch",!1),i.uniform=this.getValue(h,"uniform",!1),s.ikConstraints.push(i)}if(n.transform)for(let c=0;c<n.transform.length;c++){const h=n.transform[c],i=new fc(h.name);i.order=this.getValue(h,"order",0),i.skinRequired=this.getValue(h,"skin",!1);for(let o=0;o<h.bones.length;o++){const d=h.bones[o],f=s.findBone(d);if(f==null)throw new Error(`Transform constraint bone not found: ${d}`);i.bones.push(f)}const a=h.target;if(i.target=s.findBone(a),i.target==null)throw new Error(`Transform constraint target bone not found: ${a}`);i.local=this.getValue(h,"local",!1),i.relative=this.getValue(h,"relative",!1),i.offsetRotation=this.getValue(h,"rotation",0),i.offsetX=this.getValue(h,"x",0)*e,i.offsetY=this.getValue(h,"y",0)*e,i.offsetScaleX=this.getValue(h,"scaleX",0),i.offsetScaleY=this.getValue(h,"scaleY",0),i.offsetShearY=this.getValue(h,"shearY",0),i.rotateMix=this.getValue(h,"rotateMix",1),i.translateMix=this.getValue(h,"translateMix",1),i.scaleMix=this.getValue(h,"scaleMix",1),i.shearMix=this.getValue(h,"shearMix",1),s.transformConstraints.push(i)}if(n.path)for(let c=0;c<n.path.length;c++){const h=n.path[c],i=new ac(h.name);i.order=this.getValue(h,"order",0),i.skinRequired=this.getValue(h,"skin",!1);for(let o=0;o<h.bones.length;o++){const d=h.bones[o],f=s.findBone(d);if(f==null)throw new Error(`Transform constraint bone not found: ${d}`);i.bones.push(f)}const a=h.target;if(i.target=s.findSlot(a),i.target==null)throw new Error(`Path target slot not found: ${a}`);i.positionMode=La.positionModeFromString(this.getValue(h,"positionMode","percent")),i.spacingMode=La.spacingModeFromString(this.getValue(h,"spacingMode","length")),i.rotateMode=La.rotateModeFromString(this.getValue(h,"rotateMode","tangent")),i.offsetRotation=this.getValue(h,"rotation",0),i.position=this.getValue(h,"position",0),i.positionMode==nr.Fixed&&(i.position*=e),i.spacing=this.getValue(h,"spacing",0),(i.spacingMode==Oe.Length||i.spacingMode==Oe.Fixed)&&(i.spacing*=e),i.rotateMix=this.getValue(h,"rotateMix",1),i.translateMix=this.getValue(h,"translateMix",1),s.pathConstraints.push(i)}if(n.skins)for(let c=0;c<n.skins.length;c++){const h=n.skins[c],i=new il(h.name);if(h.bones)for(let a=0;a<h.bones.length;a++){const o=s.findBone(h.bones[a]);if(o==null)throw new Error(`Skin bone not found: ${h.bones[c]}`);i.bones.push(o)}if(h.ik)for(let a=0;a<h.ik.length;a++){const o=s.findIkConstraint(h.ik[a]);if(o==null)throw new Error(`Skin IK constraint not found: ${h.ik[c]}`);i.constraints.push(o)}if(h.transform)for(let a=0;a<h.transform.length;a++){const o=s.findTransformConstraint(h.transform[a]);if(o==null)throw new Error(`Skin transform constraint not found: ${h.transform[c]}`);i.constraints.push(o)}if(h.path)for(let a=0;a<h.path.length;a++){const o=s.findPathConstraint(h.path[a]);if(o==null)throw new Error(`Skin path constraint not found: ${h.path[c]}`);i.constraints.push(o)}for(const a in h.attachments){const o=s.findSlot(a);if(o==null)throw new Error(`Slot not found: ${a}`);const d=h.attachments[a];for(const f in d){const m=this.readAttachment(d[f],i,o.index,f,s);m!=null&&i.setAttachment(o.index,f,m)}}s.skins.push(i),i.name=="default"&&(s.defaultSkin=i)}for(let c=0,h=this.linkedMeshes.length;c<h;c++){const i=this.linkedMeshes[c],a=i.skin==null?s.defaultSkin:s.findSkin(i.skin);if(a==null)throw new Error(`Skin not found: ${i.skin}`);const o=a.getAttachment(i.slotIndex,i.parent);if(o==null)throw new Error(`Parent mesh not found: ${i.parent}`);i.mesh.deformAttachment=i.inheritDeform?o:i.mesh,i.mesh.setParentMesh(o)}if(this.linkedMeshes.length=0,n.events)for(const c in n.events){const h=n.events[c],i=new gc(c);i.intValue=this.getValue(h,"int",0),i.floatValue=this.getValue(h,"float",0),i.stringValue=this.getValue(h,"string",""),i.audioPath=this.getValue(h,"audio",null),i.audioPath!=null&&(i.volume=this.getValue(h,"volume",1),i.balance=this.getValue(h,"balance",0)),s.events.push(i)}if(n.animations)for(const c in n.animations){const h=n.animations[c];this.readAnimation(h,c,s)}return s}readAttachment(t,e,s,n,r){const c=this.scale;switch(n=this.getValue(t,"name",n),this.getValue(t,"type","region")){case"region":{const i=this.getValue(t,"path",n),a=this.attachmentLoader.newRegionAttachment(e,n,i);if(a==null)return null;a.path=i,a.x=this.getValue(t,"x",0)*c,a.y=this.getValue(t,"y",0)*c,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*c,a.height=t.height*c;const o=this.getValue(t,"color",null);return o!=null&&a.color.setFromString(o),a}case"boundingbox":{const i=this.attachmentLoader.newBoundingBoxAttachment(e,n);if(i==null)return null;this.readVertices(t,i,t.vertexCount<<1);const a=this.getValue(t,"color",null);return a!=null&&i.color.setFromString(a),i}case"mesh":case"linkedmesh":{const i=this.getValue(t,"path",n),a=this.attachmentLoader.newMeshAttachment(e,n,i);if(a==null)return null;a.path=i;const o=this.getValue(t,"color",null);o!=null&&a.color.setFromString(o),a.width=this.getValue(t,"width",0)*c,a.height=this.getValue(t,"height",0)*c;const d=this.getValue(t,"parent",null);if(d!=null)return this.linkedMeshes.push(new s1(a,this.getValue(t,"skin",null),s,d,this.getValue(t,"deform",!0))),a;const f=t.uvs;return this.readVertices(t,a,f.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(f),a.edges=this.getValue(t,"edges",null),a.hullLength=this.getValue(t,"hull",0)*2,a}case"path":{const i=this.attachmentLoader.newPathAttachment(e,n);if(i==null)return null;i.closed=this.getValue(t,"closed",!1),i.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,i,a<<1);const o=it.newArray(a/3,0);for(let f=0;f<t.lengths.length;f++)o[f]=t.lengths[f]*c;i.lengths=o;const d=this.getValue(t,"color",null);return d!=null&&i.color.setFromString(d),i}case"point":{const i=this.attachmentLoader.newPointAttachment(e,n);if(i==null)return null;i.x=this.getValue(t,"x",0)*c,i.y=this.getValue(t,"y",0)*c,i.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return a!=null&&i.color.setFromString(a),i}case"clipping":{const i=this.attachmentLoader.newClippingAttachment(e,n);if(i==null)return null;const a=this.getValue(t,"end",null);if(a!=null){const f=r.findSlot(a);if(f==null)throw new Error(`Clipping end slot not found: ${a}`);i.endSlot=f}const o=t.vertexCount;this.readVertices(t,i,o<<1);const d=this.getValue(t,"color",null);return d!=null&&i.color.setFromString(d),i}}return null}readVertices(t,e,s){const n=this.scale;e.worldVerticesLength=s;const r=t.vertices;if(s==r.length){const i=it.toFloatArray(r);if(n!=1)for(let a=0,o=r.length;a<o;a++)i[a]*=n;e.vertices=i;return}const c=new Array,h=new Array;for(let i=0,a=r.length;i<a;){const o=r[i++];h.push(o);for(let d=i+o*4;i<d;i+=4)h.push(r[i]),c.push(r[i+1]*n),c.push(r[i+2]*n),c.push(r[i+3])}e.bones=h,e.vertices=it.toFloatArray(c)}readAnimation(t,e,s){const n=this.scale,r=new Array;let c=0;if(t.slots)for(const i in t.slots){const a=t.slots[i],o=s.findSlotIndex(i);if(o==-1)throw new Error(`Slot not found: ${i}`);for(const d in a){const f=a[d];if(d=="attachment"){const m=new Qi(f.length);m.slotIndex=o;let l=0;for(let g=0;g<f.length;g++){const p=f[g];m.setFrame(l++,this.getValue(p,"time",0),p.name)}r.push(m),c=Math.max(c,m.frames[m.getFrameCount()-1])}else if(d=="color"){const m=new oo(f.length);m.slotIndex=o;let l=0;for(let g=0;g<f.length;g++){const p=f[g],y=new Ut;y.setFromString(p.color||"ffffffff"),m.setFrame(l,this.getValue(p,"time",0),y.r,y.g,y.b,y.a),this.readCurve(p,m,l),l++}r.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*oo.ENTRIES])}else if(d=="twoColor"){const m=new lo(f.length);m.slotIndex=o;let l=0;for(let g=0;g<f.length;g++){const p=f[g],y=new Ut,w=new Ut;y.setFromString(p.light),w.setFromString(p.dark),m.setFrame(l,this.getValue(p,"time",0),y.r,y.g,y.b,y.a,w.r,w.g,w.b),this.readCurve(p,m,l),l++}r.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*lo.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${d} (${i})`)}}if(t.bones)for(const i in t.bones){const a=t.bones[i],o=s.findBoneIndex(i);if(o==-1)throw new Error(`Bone not found: ${i}`);for(const d in a){const f=a[d];if(d==="rotate"){const m=new rn(f.length);m.boneIndex=o;let l=0;for(let g=0;g<f.length;g++){const p=f[g];m.setFrame(l,this.getValue(p,"time",0),this.getValue(p,"angle",0)),this.readCurve(p,m,l),l++}r.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*rn.ENTRIES])}else if(d==="translate"||d==="scale"||d==="shear"){let m=null,l=1,g=0;d==="scale"?(m=new jl(f.length),g=1):d==="shear"?m=new tc(f.length):(m=new Zi(f.length),l=n),m.boneIndex=o;let p=0;for(let y=0;y<f.length;y++){const w=f[y],b=this.getValue(w,"x",g),x=this.getValue(w,"y",g);m.setFrame(p,this.getValue(w,"time",0),b*l,x*l),this.readCurve(w,m,p),p++}r.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*Zi.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${d} (${i})`)}}if(t.ik)for(const i in t.ik){const a=t.ik[i],o=s.findIkConstraint(i),d=new co(a.length);d.ikConstraintIndex=s.ikConstraints.indexOf(o);let f=0;for(let m=0;m<a.length;m++){const l=a[m];d.setFrame(f,this.getValue(l,"time",0),this.getValue(l,"mix",1),this.getValue(l,"softness",0)*n,this.getValue(l,"bendPositive",!0)?1:-1,this.getValue(l,"compress",!1),this.getValue(l,"stretch",!1)),this.readCurve(l,d,f),f++}r.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*co.ENTRIES])}if(t.transform)for(const i in t.transform){const a=t.transform[i],o=s.findTransformConstraint(i),d=new ho(a.length);d.transformConstraintIndex=s.transformConstraints.indexOf(o);let f=0;for(let m=0;m<a.length;m++){const l=a[m];d.setFrame(f,this.getValue(l,"time",0),this.getValue(l,"rotateMix",1),this.getValue(l,"translateMix",1),this.getValue(l,"scaleMix",1),this.getValue(l,"shearMix",1)),this.readCurve(l,d,f),f++}r.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*ho.ENTRIES])}if(t.path)for(const i in t.path){const a=t.path[i],o=s.findPathConstraintIndex(i);if(o==-1)throw new Error(`Path constraint not found: ${i}`);const d=s.pathConstraints[o];for(const f in a){const m=a[f];if(f==="position"||f==="spacing"){let l=null,g=1;f==="spacing"?(l=new sc(m.length),(d.spacingMode==Oe.Length||d.spacingMode==Oe.Fixed)&&(g=n)):(l=new va(m.length),d.positionMode==nr.Fixed&&(g=n)),l.pathConstraintIndex=o;let p=0;for(let y=0;y<m.length;y++){const w=m[y];l.setFrame(p,this.getValue(w,"time",0),this.getValue(w,f,0)*g),this.readCurve(w,l,p),p++}r.push(l),c=Math.max(c,l.frames[(l.getFrameCount()-1)*va.ENTRIES])}else if(f==="mix"){const l=new fo(m.length);l.pathConstraintIndex=o;let g=0;for(let p=0;p<m.length;p++){const y=m[p];l.setFrame(g,this.getValue(y,"time",0),this.getValue(y,"rotateMix",1),this.getValue(y,"translateMix",1)),this.readCurve(y,l,g),g++}r.push(l),c=Math.max(c,l.frames[(l.getFrameCount()-1)*fo.ENTRIES])}}}if(t.deform)for(const i in t.deform){const a=t.deform[i],o=s.findSkin(i);if(o!=null)for(const d in a){const f=a[d],m=s.findSlotIndex(d);if(m==-1)throw new Error(`Slot not found: ${f.name}`);for(const l in f){const g=f[l],p=o.getAttachment(m,l);if(p==null)throw new Error(`Deform attachment not found: ${g.name}`);const y=p.bones!=null,w=p.vertices,b=y?w.length/3*2:w.length,x=new ec(g.length);x.slotIndex=m,x.attachment=p;let S=0;for(let C=0;C<g.length;C++){const A=g[C];let v;const M=this.getValue(A,"vertices",null);if(M==null)v=y?it.newFloatArray(b):w;else{v=it.newFloatArray(b);const E=this.getValue(A,"offset",0);if(it.arrayCopy(M,0,v,E,M.length),n!=1)for(let T=E,R=T+M.length;T<R;T++)v[T]*=n;if(!y)for(let T=0;T<b;T++)v[T]+=w[T]}x.setFrame(S,this.getValue(A,"time",0),v),this.readCurve(A,x,S),S++}r.push(x),c=Math.max(c,x.frames[x.getFrameCount()-1])}}}let h=t.drawOrder;if(h==null&&(h=t.draworder),h!=null){const i=new Aa(h.length),a=s.slots.length;let o=0;for(let d=0;d<h.length;d++){const f=h[d];let m=null;const l=this.getValue(f,"offsets",null);if(l!=null){m=it.newArray(a,-1);const g=it.newArray(a-l.length,0);let p=0,y=0;for(let w=0;w<l.length;w++){const b=l[w],x=s.findSlotIndex(b.slot);if(x==-1)throw new Error(`Slot not found: ${b.slot}`);for(;p!=x;)g[y++]=p++;m[p+b.offset]=p++}for(;p<a;)g[y++]=p++;for(let w=a-1;w>=0;w--)m[w]==-1&&(m[w]=g[--y])}i.setFrame(o++,this.getValue(f,"time",0),m)}r.push(i),c=Math.max(c,i.frames[i.getFrameCount()-1])}if(t.events){const i=new tl(t.events.length);let a=0;for(let o=0;o<t.events.length;o++){const d=t.events[o],f=s.findEvent(d.name);if(f==null)throw new Error(`Event not found: ${d.name}`);const m=new lc(it.toSinglePrecision(this.getValue(d,"time",0)),f);m.intValue=this.getValue(d,"int",f.intValue),m.floatValue=this.getValue(d,"float",f.floatValue),m.stringValue=this.getValue(d,"string",f.stringValue),m.data.audioPath!=null&&(m.volume=this.getValue(d,"volume",1),m.balance=this.getValue(d,"balance",0)),i.setFrame(a++,m)}r.push(i),c=Math.max(c,i.frames[i.getFrameCount()-1])}if(isNaN(c))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new ye(e,r,c))}readCurve(t,e,s){if(t.hasOwnProperty("curve"))if(t.curve==="stepped")e.setStepped(s);else{const n=t.curve;e.setCurve(s,n,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,e,s){return t[e]!==void 0?t[e]:s}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return G.BLEND_MODES.NORMAL;if(t=="additive")return G.BLEND_MODES.ADD;if(t=="multiply")return G.BLEND_MODES.MULTIPLY;if(t=="screen")return G.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return nr.Fixed;if(t=="percent")return nr.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return Oe.Length;if(t=="fixed")return Oe.Fixed;if(t=="percent")return Oe.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return rr.Tangent;if(t=="chain")return rr.Chain;if(t=="chainscale")return rr.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return fe.Normal;if(t=="onlytranslation")return fe.OnlyTranslation;if(t=="norotationorreflection")return fe.NoRotationOrReflection;if(t=="noscale")return fe.NoScale;if(t=="noscaleorreflection")return fe.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}},s1=class{constructor(t,e,s,n,r){ni(this,"parent"),ni(this,"skin"),ni(this,"slotIndex"),ni(this,"mesh"),ni(this,"inheritDeform"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritDeform=r}};var n1=Object.defineProperty,r1=(u,t,e)=>t in u?n1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,cs=(u,t,e)=>r1(u,typeof t!="symbol"?t+"":t,e);let xf=class{constructor(){cs(this,"entries",{}),cs(this,"size",0)}add(t){const e=this.entries[t];return this.entries[t]=!0,e?!1:(this.size++,!0)}addAll(t){const e=this.size;for(let s=0,n=t.length;s<n;s++)this.add(t[s]);return e!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}};const Rn=class ap{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new ap().setFromString(t)}};cs(Rn,"WHITE",new Rn(1,1,1,1)),cs(Rn,"RED",new Rn(1,0,0,1)),cs(Rn,"GREEN",new Rn(0,1,0,1)),cs(Rn,"BLUE",new Rn(0,0,1,1)),cs(Rn,"MAGENTA",new Rn(1,0,1,1));let kt=Rn;const zs=class Uo{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*Uo.degRad)}static sinDeg(t){return Math.sin(t*Uo.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*Uo.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return Uo.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};cs(zs,"PI",3.1415927),cs(zs,"PI2",zs.PI*2),cs(zs,"invPI2",1/zs.PI2),cs(zs,"radiansToDegrees",180/zs.PI),cs(zs,"radDeg",zs.radiansToDegrees),cs(zs,"degreesToRadians",zs.PI/180),cs(zs,"degRad",zs.degreesToRadians);let Z=zs;const wf=class Oa{static arrayCopy(t,e,s,n,r){for(let c=e,h=n;c<e+r;c++,h++)s[h]=t[c]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:Oa.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(Oa.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(Oa.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return Oa.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return Oa.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}};cs(wf,"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");let ct=wf,yf=class{constructor(t){cs(this,"items",new Array),cs(this,"instantiator"),this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}},pc=class{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}};var Se=(u=>(u[u.Region=0]="Region",u[u.BoundingBox=1]="BoundingBox",u[u.Mesh=2]="Mesh",u[u.LinkedMesh=3]="LinkedMesh",u[u.Path=4]="Path",u[u.Point=5]="Point",u[u.Clipping=6]="Clipping",u))(Se||{}),on=(u=>(u[u.Normal=0]="Normal",u[u.OnlyTranslation=1]="OnlyTranslation",u[u.NoRotationOrReflection=2]="NoRotationOrReflection",u[u.NoScale=3]="NoScale",u[u.NoScaleOrReflection=4]="NoScaleOrReflection",u))(on||{}),Sf=(u=>(u[u.none=0]="none",u[u.reset=1]="reset",u[u.update=2]="update",u[u.pose=3]="pose",u))(Sf||{}),i1=Object.defineProperty,a1=(u,t,e)=>t in u?i1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,xo=(u,t,e)=>a1(u,typeof t!="symbol"?t+"":t,e);let Cf=class{constructor(){xo(this,"texture"),xo(this,"size",null),xo(this,"names",null),xo(this,"values",null),xo(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}};var Af=(u=>(u[u.UNKNOWN=0]="UNKNOWN",u[u.VER37=37]="VER37",u[u.VER38=38]="VER38",u[u.VER40=40]="VER40",u[u.VER41=41]="VER41",u[u.VER42=42]="VER42",u))(Af||{});function o1(u){const t=u.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}const l1={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var c1=Object.defineProperty,h1=(u,t,e)=>t in u?c1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,hs=(u,t,e)=>h1(u,typeof t!="symbol"?t+"":t,e);const ri=[0,0,0];let d1=class extends zr.Sprite{constructor(){super(...arguments),hs(this,"region",null),hs(this,"attachment",null)}},u1=class extends Gr.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),hs(this,"region",null),hs(this,"attachment",null)}};const vf=class op extends Lt.Container{constructor(t){if(super(),hs(this,"tintRgb"),hs(this,"spineData"),hs(this,"skeleton"),hs(this,"stateData"),hs(this,"state"),hs(this,"slotContainers"),hs(this,"tempClipContainers"),hs(this,"localDelayLimit"),hs(this,"_autoUpdate"),hs(this,"_visible"),hs(this,"_debug"),hs(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),c=this.newContainer();if(this.slotContainers.push(c),this.addChild(c),this.tempClipContainers.push(null),!!r)if(r.type===Se.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,c.addChild(i)}else if(r.type===Se.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,c.addChild(h)}else r.type===Se.Clipping&&(this.createGraphics(n,r),c.addChild(n.clippingContainer),c.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?op.prototype.autoUpdateTransform:Lt.Container.prototype.updateTransform)}get tint(){return G.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=G.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:l1.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=o1(this.spineData.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===Af.VER42&&Sf.update);const n=this.skeleton.slots,r=this.color;let c=null,h=null;r?(c=r.light,h=r.dark):c=this.tintRgb;for(let f=0,m=n.length;f<m;f++){const l=n[f],g=l.getAttachment(),p=this.slotContainers[f];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(l,g);let w=g.region;const b=g.color;switch(g!=null&&g.type){case Se.Region:if(p.transform.setFromMatrix(l.bone.matrix),w=g.region,l.currentMesh&&(l.currentMesh.visible=!1,l.currentMesh=null,l.currentMeshId=void 0,l.currentMeshName=void 0),!w){l.currentSprite&&(l.currentSprite.renderable=!1);break}if(!l.currentSpriteName||l.currentSpriteName!==g.name){const C=g.name;if(l.currentSprite&&(l.currentSprite.visible=!1),l.sprites=l.sprites||{},l.sprites[C]!==void 0)l.sprites[C].visible=!0;else{const A=this.createSprite(l,g,C);p.addChild(A)}l.currentSprite=l.sprites[C],l.currentSpriteName=C}l.currentSprite.renderable=!0,l.hackRegion||this.setSpriteRegion(g,l.currentSprite,w),l.currentSprite.color?y=l.currentSprite.color:(ri[0]=c[0]*l.color.r*b.r,ri[1]=c[1]*l.color.g*b.g,ri[2]=c[2]*l.color.b*b.b,l.currentSprite.tint=G.utils.rgb2hex(ri)),l.currentSprite.blendMode=l.blendMode;break;case Se.Mesh:if(l.currentSprite){l.currentSprite.visible=!1,l.currentSprite=null,l.currentSpriteName=void 0;const C=new G.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){l.currentMesh&&(l.currentMesh.renderable=!1);break}const S=g.id;if(l.currentMeshId===void 0||l.currentMeshId!==S){const C=S;if(l.currentMesh&&(l.currentMesh.visible=!1),l.meshes=l.meshes||{},l.meshes[C]!==void 0)l.meshes[C].visible=!0;else{const A=this.createMesh(l,g);p.addChild(A)}l.currentMesh=l.meshes[C],l.currentMeshName=g.name,l.currentMeshId=C}l.currentMesh.renderable=!0,g.computeWorldVerticesOld(l,l.currentMesh.vertices),l.currentMesh.color?y=l.currentMesh.color:(ri[0]=c[0]*l.color.r*b.r,ri[1]=c[1]*l.color.g*b.g,ri[2]=c[2]*l.color.b*b.b,l.currentMesh.tint=G.utils.rgb2hex(ri)),l.currentMesh.blendMode=l.blendMode,l.hackRegion||this.setMeshRegion(g,l.currentMesh,w);break;case Se.Clipping:l.currentGraphics||(this.createGraphics(l,g),p.addChild(l.clippingContainer),p.addChild(l.currentGraphics)),this.updateGraphics(l,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let x=l.color.r*b.r,S=l.color.g*b.g,C=l.color.b*b.b;y.setLight(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C)),l.darkColor?(x=l.darkColor.r,S=l.darkColor.g,C=l.darkColor.b):(x=0,S=0,C=0),y.setDark(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C))}p.alpha=l.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let f=0,m=i.length;f<m;f++){const l=n[i[f].data.index],g=this.slotContainers[i[f].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),l.currentGraphics&&l.getAttachment())o=l.clippingContainer,a=l.getAttachment(),o.children.length=0,this.children[f]=g,a.endSlot===l.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[f];p||(p=this.tempClipContainers[f]=this.newContainer(),p.visible=!1),this.children[f]=p,g.parent=null,o.addChild(g),a.endSlot==l.data&&(o.renderable=!0,o=null,a=null)}else this.children[f]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*Z.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}Lt.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,c=this.newSprite(r);return c.anchor.set(.5),n&&this.setSpriteRegion(e,c,e.region),t.sprites=t.sprites||{},t.sprites[s]=c,c}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),G.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new G.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let c=r.region;return e?(c=new Cf,c.texture=e,c.size=s,n.hackRegion=c,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,c):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,c),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),c=this.skeleton.getAttachmentByName(t,e);c.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=c.region;return s?(a=new Cf,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Lt.Container}newSprite(t){return new d1(t)}newGraphics(){return new Ye.Graphics}newMesh(t,e,s,n,r){return new u1(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let c=0,h=this.skeleton.slots.length;c<h;c++){const i=this.skeleton.slots[c],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};hs(vf,"clippingPolygon",[]);let Mf=vf;Object.defineProperty(Mf.prototype,"visible",{get(){return this._visible},set(u){u!==this._visible&&(this._visible=u,u&&(this.lastTime=0))}});var f1=Object.defineProperty,m1=(u,t,e)=>t in u?f1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ii=(u,t,e)=>m1(u,typeof t!="symbol"?t+"":t,e);let bc=class{constructor(t){if(ii(this,"name"),ii(this,"type"),!t)throw new Error("name cannot be null.");this.name=t}};const Ef=class lp extends bc{constructor(t){super(t),ii(this,"id",lp.nextID++),ii(this,"bones",null),ii(this,"vertices",[]),ii(this,"worldVerticesLength",0),ii(this,"timelineAttachment",this)}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,s,n,r,c){s=r+(s>>1)*c;const h=t.bone.skeleton,i=t.deform;let a=this.vertices;const o=this.bones;if(!o){i.length>0&&(a=i);const l=t.bone.matrix,g=l.tx,p=l.ty,y=l.a,w=l.c,b=l.b,x=l.d;for(let S=e,C=r;C<s;S+=2,C+=c){const A=a[S],v=a[S+1];n[C]=A*y+v*w+g,n[C+1]=A*b+v*x+p}return}let d=0,f=0;for(let l=0;l<e;l+=2){const g=o[d];d+=g+1,f+=g}const m=h.bones;if(i.length==0)for(let l=r,g=f*3;l<s;l+=c){let p=0,y=0,w=o[d++];for(w+=d;d<w;d++,g+=3){const b=m[o[d]].matrix,x=a[g],S=a[g+1],C=a[g+2];p+=(x*b.a+S*b.c+b.tx)*C,y+=(x*b.b+S*b.d+b.ty)*C}n[l]=p,n[l+1]=y}else{const l=i;for(let g=r,p=f*3,y=f<<1;g<s;g+=c){let w=0,b=0,x=o[d++];for(x+=d;d<x;d++,p+=3,y+=2){const S=m[o[d]].matrix,C=a[p]+l[y],A=a[p+1]+l[y+1],v=a[p+2];w+=(C*S.a+A*S.c+S.tx)*v,b+=(C*S.b+A*S.d+S.ty)*v}n[g]=w,n[g+1]=b}}}copyTo(t){this.bones?(t.bones=new Array(this.bones.length),ct.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices&&(t.vertices=ct.newFloatArray(this.vertices.length),ct.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)),t.worldVerticesLength=this.worldVerticesLength,t.timelineAttachment=this.timelineAttachment}};ii(Ef,"nextID",0);let ar=Ef;var g1=Object.defineProperty,p1=(u,t,e)=>t in u?g1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,bt=(u,t,e)=>p1(u,typeof t!="symbol"?t+"":t,e);const qt=class cp extends bc{constructor(t,e){super(t),bt(this,"type",Se.Region),bt(this,"x",0),bt(this,"y",0),bt(this,"scaleX",1),bt(this,"scaleY",1),bt(this,"rotation",0),bt(this,"width",0),bt(this,"height",0),bt(this,"color",new kt(1,1,1,1)),bt(this,"path"),bt(this,"rendererObject",null),bt(this,"region",null),bt(this,"sequence",null),bt(this,"offset",ct.newFloatArray(8)),bt(this,"uvs",ct.newFloatArray(8)),bt(this,"tempColor",new kt(1,1,1,1)),this.path=e}updateRegion(){if(!this.region)throw new Error("Region not set.");const t=this.region,e=this.width/this.region.originalWidth*this.scaleX,s=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*e,r=-this.height/2*this.scaleY+this.region.offsetY*s,c=n+this.region.width*e,h=r+this.region.height*s,i=this.rotation*Math.PI/180,a=Math.cos(i),o=Math.sin(i),d=this.x,f=this.y,m=n*a+d,l=n*o,g=r*a+f,p=r*o,y=c*a+d,w=c*o,b=h*a+f,x=h*o,S=this.offset;S[0]=m-p,S[1]=g+l,S[2]=m-x,S[3]=b+l,S[4]=y-x,S[5]=b+w,S[6]=y-p,S[7]=g+w;const C=this.uvs;t.degrees==90?(C[2]=t.u,C[3]=t.v2,C[4]=t.u,C[5]=t.v,C[6]=t.u2,C[7]=t.v,C[0]=t.u2,C[1]=t.v2):(C[0]=t.u,C[1]=t.v2,C[2]=t.u,C[3]=t.v,C[4]=t.u2,C[5]=t.v,C[6]=t.u2,C[7]=t.v2)}computeWorldVertices(t,e,s,n){this.sequence!=null&&this.sequence.apply(t,this);const r=t.bone,c=this.offset,h=r.matrix,i=h.tx,a=h.ty,o=h.a,d=h.c,f=h.b,m=h.d;let l=0,g=0;l=c[0],g=c[1],e[s]=l*o+g*d+i,e[s+1]=l*f+g*m+a,s+=n,l=c[2],g=c[3],e[s]=l*o+g*d+i,e[s+1]=l*f+g*m+a,s+=n,l=c[4],g=c[5],e[s]=l*o+g*d+i,e[s+1]=l*f+g*m+a,s+=n,l=c[6],g=c[7],e[s]=l*o+g*d+i,e[s+1]=l*f+g*m+a}copy(){const t=new cp(this.name,this.path);return t.region=this.region,t.rendererObject=this.rendererObject,t.x=this.x,t.y=this.y,t.scaleX=this.scaleX,t.scaleY=this.scaleY,t.rotation=this.rotation,t.width=this.width,t.height=this.height,ct.arrayCopy(this.uvs,0,t.uvs,0,8),ct.arrayCopy(this.offset,0,t.offset,0,8),t.color.setFromColor(this.color),t.sequence=this.sequence!=null?this.sequence.copy():null,t}};bt(qt,"X1",0),bt(qt,"Y1",1),bt(qt,"C1R",2),bt(qt,"C1G",3),bt(qt,"C1B",4),bt(qt,"C1A",5),bt(qt,"U1",6),bt(qt,"V1",7),bt(qt,"X2",8),bt(qt,"Y2",9),bt(qt,"C2R",10),bt(qt,"C2G",11),bt(qt,"C2B",12),bt(qt,"C2A",13),bt(qt,"U2",14),bt(qt,"V2",15),bt(qt,"X3",16),bt(qt,"Y3",17),bt(qt,"C3R",18),bt(qt,"C3G",19),bt(qt,"C3B",20),bt(qt,"C3A",21),bt(qt,"U3",22),bt(qt,"V3",23),bt(qt,"X4",24),bt(qt,"Y4",25),bt(qt,"C4R",26),bt(qt,"C4G",27),bt(qt,"C4B",28),bt(qt,"C4A",29),bt(qt,"U4",30),bt(qt,"V4",31);let xc=qt;var b1=Object.defineProperty,x1=(u,t,e)=>t in u?b1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ma=(u,t,e)=>x1(u,typeof t!="symbol"?t+"":t,e);const Tf=class kl{constructor(t){Ma(this,"id",kl.nextID()),Ma(this,"regions"),Ma(this,"start",0),Ma(this,"digits",0),Ma(this,"setupIndex",0),this.regions=new Array(t)}copy(){const t=new kl(this.regions.length);return ct.arrayCopy(this.regions,0,t.regions,0,this.regions.length),t.start=this.start,t.digits=this.digits,t.setupIndex=this.setupIndex,t}apply(t,e){let s=t.sequenceIndex;s==-1&&(s=this.setupIndex),s>=this.regions.length&&(s=this.regions.length-1);const n=this.regions[s];e.region!=n&&(e.region=n)}getPath(t,e){let s=t;const n=(this.start+e).toString();for(let r=this.digits-n.length;r>0;r--)s+="0";return s+=n,s}static nextID(){return kl._nextID++}};Ma(Tf,"_nextID",0);let wc=Tf;var or=(u=>(u[u.hold=0]="hold",u[u.once=1]="once",u[u.loop=2]="loop",u[u.pingpong=3]="pingpong",u[u.onceReverse=4]="onceReverse",u[u.loopReverse=5]="loopReverse",u[u.pingpongReverse=6]="pingpongReverse",u))(or||{});const yc=[0,1,2,3,4,5,6];var U=(u=>(u[u.setup=0]="setup",u[u.first=1]="first",u[u.replace=2]="replace",u[u.add=3]="add",u))(U||{}),Hs=(u=>(u[u.mixIn=0]="mixIn",u[u.mixOut=1]="mixOut",u))(Hs||{}),w1=Object.defineProperty,y1=(u,t,e)=>t in u?w1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Et=(u,t,e)=>y1(u,typeof t!="symbol"?t+"":t,e);let al=class{constructor(t,e,s){if(Et(this,"name"),Et(this,"timelines",[]),Et(this,"timelineIds",new xf),Et(this,"duration"),!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(e),this.duration=s}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(let e=0;e<t.length;e++)this.timelineIds.addAll(t[e].getPropertyIds())}hasTimeline(t){for(let e=0;e<t.length;e++)if(this.timelineIds.contains(t[e]))return!0;return!1}apply(t,e,s,n,r,c,h,i){if(!t)throw new Error("skeleton cannot be null.");n&&this.duration!=0&&(s%=this.duration,e>0&&(e%=this.duration));const a=this.timelines;for(let o=0,d=a.length;o<d;o++)a[o].apply(t,e,s,r,c,h,i)}};const Ht={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,rgb:7,alpha:8,rgb2:9,attachment:10,deform:11,event:12,drawOrder:13,ikConstraint:14,transformConstraint:15,pathConstraintPosition:16,pathConstraintSpacing:17,pathConstraintMix:18,sequence:19};let ge=class{constructor(t,e){Et(this,"propertyIds"),Et(this,"frames"),this.propertyIds=e,this.frames=ct.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,e){const s=t.length;for(let n=1;n<s;n++)if(t[n]>e)return n-1;return s-1}static search(t,e,s){const n=t.length;for(let r=s;r<n;r+=s)if(t[r]>e)return r-s;return n-s}},Pn=class extends ge{constructor(t,e,s){super(t,s),Et(this,"curves"),this.curves=ct.newFloatArray(t+e*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const e=this.getFrameCount()+t*18;if(this.curves.length>e){const s=ct.newFloatArray(e);ct.arrayCopy(this.curves,0,s,0,e),this.curves=s}}setBezier(t,e,s,n,r,c,h,i,a,o,d){const f=this.curves;let m=this.getFrameCount()+t*18;s==0&&(f[e]=2+m);const l=(n-c*2+i)*.03,g=(r-h*2+a)*.03,p=((c-i)*3-n+o)*.006,y=((h-a)*3-r+d)*.006;let w=l*2+p,b=g*2+y,x=(c-n)*.3+l+p*.16666667,S=(h-r)*.3+g+y*.16666667,C=n+x,A=r+S;for(let v=m+18;m<v;m+=2)f[m]=C,f[m+1]=A,x+=w,S+=b,w+=p,b+=y,C+=x,A+=S}getBezierValue(t,e,s,n){const r=this.curves;if(r[n]>t){const a=this.frames[e],o=this.frames[e+s];return o+(t-a)/(r[n]-a)*(r[n+1]-o)}const c=n+18;for(n+=2;n<c;n+=2)if(r[n]>=t){const a=r[n-2],o=r[n-1];return o+(t-a)/(r[n]-a)*(r[n+1]-o)}e+=this.getFrameEntries();const h=r[c-2],i=r[c-1];return i+(t-h)/(this.frames[e]-h)*(this.frames[e+s]-i)}},kn=class extends Pn{constructor(t,e,s){super(t,e,[s])}getFrameEntries(){return 2}setFrame(t,e,s){t<<=1,this.frames[t]=e,this.frames[t+1]=s}getCurveValue(t){const e=this.frames;let s=e.length-2;for(let r=2;r<=s;r+=2)if(e[r]>t){s=r-2;break}const n=this.curves[s>>1];switch(n){case 0:const r=e[s],c=e[s+1];return c+(t-r)/(e[s+2]-r)*(e[s+2+1]-c);case 1:return e[s+1]}return this.getBezierValue(t,s,1,n-2)}},ol=class extends Pn{constructor(t,e,s,n){super(t,e,[s,n])}getFrameEntries(){return 3}setFrame(t,e,s,n){t*=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n}},wo=class extends kn{constructor(t,e,s){super(t,e,`${Ht.rotate}|${s}`),Et(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case U.setup:i.rotation=i.data.rotation;return;case U.first:i.rotation+=(i.data.rotation-i.rotation)*r}return}let o=this.getCurveValue(s);switch(c){case U.setup:i.rotation=i.data.rotation+o*r;break;case U.first:case U.replace:o+=i.data.rotation-i.rotation;case U.add:i.rotation+=o*r}}},Sc=class extends ol{constructor(t,e,s){super(t,e,`${Ht.x}|${s}`,`${Ht.y}|${s}`),Et(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case U.setup:i.x=i.data.x,i.y=i.data.y;return;case U.first:i.x+=(i.data.x-i.x)*r,i.y+=(i.data.y-i.y)*r}return}let o=0,d=0;const f=ge.search(a,s,3),m=this.curves[f/3];switch(m){case 0:const l=a[f];o=a[f+1],d=a[f+2];const g=(s-l)/(a[f+3]-l);o+=(a[f+3+1]-o)*g,d+=(a[f+3+2]-d)*g;break;case 1:o=a[f+1],d=a[f+2];break;default:o=this.getBezierValue(s,f,1,m-2),d=this.getBezierValue(s,f,2,m+18-2)}switch(c){case U.setup:i.x=i.data.x+o*r,i.y=i.data.y+d*r;break;case U.first:case U.replace:i.x+=(i.data.x+o-i.x)*r,i.y+=(i.data.y+d-i.y)*r;break;case U.add:i.x+=o*r,i.y+=d*r}}},Cc=class extends kn{constructor(t,e,s){super(t,e,`${Ht.x}|${s}`),Et(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case U.setup:i.x=i.data.x;return;case U.first:i.x+=(i.data.x-i.x)*r}return}const o=this.getCurveValue(s);switch(c){case U.setup:i.x=i.data.x+o*r;break;case U.first:case U.replace:i.x+=(i.data.x+o-i.x)*r;break;case U.add:i.x+=o*r}}},Ac=class extends kn{constructor(t,e,s){super(t,e,`${Ht.y}|${s}`),Et(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case U.setup:i.y=i.data.y;return;case U.first:i.y+=(i.data.y-i.y)*r}return}const o=this.getCurveValue(s);switch(c){case U.setup:i.y=i.data.y+o*r;break;case U.first:case U.replace:i.y+=(i.data.y+o-i.y)*r;break;case U.add:i.y+=o*r}}},vc=class extends ol{constructor(t,e,s){super(t,e,`${Ht.scaleX}|${s}`,`${Ht.scaleY}|${s}`),Et(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case U.setup:i.scaleX=i.data.scaleX,i.scaleY=i.data.scaleY;return;case U.first:i.scaleX+=(i.data.scaleX-i.scaleX)*r,i.scaleY+=(i.data.scaleY-i.scaleY)*r}return}let o,d;const f=ge.search(a,s,3),m=this.curves[f/3];switch(m){case 0:const l=a[f];o=a[f+1],d=a[f+2];const g=(s-l)/(a[f+3]-l);o+=(a[f+3+1]-o)*g,d+=(a[f+3+2]-d)*g;break;case 1:o=a[f+1],d=a[f+2];break;default:o=this.getBezierValue(s,f,1,m-2),d=this.getBezierValue(s,f,2,m+18-2)}if(o*=i.data.scaleX,d*=i.data.scaleY,r==1)c==U.add?(i.scaleX+=o-i.data.scaleX,i.scaleY+=d-i.data.scaleY):(i.scaleX=o,i.scaleY=d);else{let l=0,g=0;if(h==Hs.mixOut)switch(c){case U.setup:l=i.data.scaleX,g=i.data.scaleY,i.scaleX=l+(Math.abs(o)*Z.signum(l)-l)*r,i.scaleY=g+(Math.abs(d)*Z.signum(g)-g)*r;break;case U.first:case U.replace:l=i.scaleX,g=i.scaleY,i.scaleX=l+(Math.abs(o)*Z.signum(l)-l)*r,i.scaleY=g+(Math.abs(d)*Z.signum(g)-g)*r;break;case U.add:i.scaleX+=(o-i.data.scaleX)*r,i.scaleY+=(d-i.data.scaleY)*r}else switch(c){case U.setup:l=Math.abs(i.data.scaleX)*Z.signum(o),g=Math.abs(i.data.scaleY)*Z.signum(d),i.scaleX=l+(o-l)*r,i.scaleY=g+(d-g)*r;break;case U.first:case U.replace:l=Math.abs(i.scaleX)*Z.signum(o),g=Math.abs(i.scaleY)*Z.signum(d),i.scaleX=l+(o-l)*r,i.scaleY=g+(d-g)*r;break;case U.add:i.scaleX+=(o-i.data.scaleX)*r,i.scaleY+=(d-i.data.scaleY)*r}}}},Mc=class extends kn{constructor(t,e,s){super(t,e,`${Ht.scaleX}|${s}`),Et(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case U.setup:i.scaleX=i.data.scaleX;return;case U.first:i.scaleX+=(i.data.scaleX-i.scaleX)*r}return}const o=this.getCurveValue(s)*i.data.scaleX;if(r==1)c==U.add?i.scaleX+=o-i.data.scaleX:i.scaleX=o;else{let d=0;if(h==Hs.mixOut)switch(c){case U.setup:d=i.data.scaleX,i.scaleX=d+(Math.abs(o)*Z.signum(d)-d)*r;break;case U.first:case U.replace:d=i.scaleX,i.scaleX=d+(Math.abs(o)*Z.signum(d)-d)*r;break;case U.add:i.scaleX+=(o-i.data.scaleX)*r}else switch(c){case U.setup:d=Math.abs(i.data.scaleX)*Z.signum(o),i.scaleX=d+(o-d)*r;break;case U.first:case U.replace:d=Math.abs(i.scaleX)*Z.signum(o),i.scaleX=d+(o-d)*r;break;case U.add:i.scaleX+=(o-i.data.scaleX)*r}}}},Ec=class extends kn{constructor(t,e,s){super(t,e,`${Ht.scaleY}|${s}`),Et(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case U.setup:i.scaleY=i.data.scaleY;return;case U.first:i.scaleY+=(i.data.scaleY-i.scaleY)*r}return}const o=this.getCurveValue(s)*i.data.scaleY;if(r==1)c==U.add?i.scaleY+=o-i.data.scaleY:i.scaleY=o;else{let d=0;if(h==Hs.mixOut)switch(c){case U.setup:d=i.data.scaleY,i.scaleY=d+(Math.abs(o)*Z.signum(d)-d)*r;break;case U.first:case U.replace:d=i.scaleY,i.scaleY=d+(Math.abs(o)*Z.signum(d)-d)*r;break;case U.add:i.scaleY+=(o-i.data.scaleY)*r}else switch(c){case U.setup:d=Math.abs(i.data.scaleY)*Z.signum(o),i.scaleY=d+(o-d)*r;break;case U.first:case U.replace:d=Math.abs(i.scaleY)*Z.signum(o),i.scaleY=d+(o-d)*r;break;case U.add:i.scaleY+=(o-i.data.scaleY)*r}}}},Tc=class extends ol{constructor(t,e,s){super(t,e,`${Ht.shearX}|${s}`,`${Ht.shearY}|${s}`),Et(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case U.setup:i.shearX=i.data.shearX,i.shearY=i.data.shearY;return;case U.first:i.shearX+=(i.data.shearX-i.shearX)*r,i.shearY+=(i.data.shearY-i.shearY)*r}return}let o=0,d=0;const f=ge.search(a,s,3),m=this.curves[f/3];switch(m){case 0:const l=a[f];o=a[f+1],d=a[f+2];const g=(s-l)/(a[f+3]-l);o+=(a[f+3+1]-o)*g,d+=(a[f+3+2]-d)*g;break;case 1:o=a[f+1],d=a[f+2];break;default:o=this.getBezierValue(s,f,1,m-2),d=this.getBezierValue(s,f,2,m+18-2)}switch(c){case U.setup:i.shearX=i.data.shearX+o*r,i.shearY=i.data.shearY+d*r;break;case U.first:case U.replace:i.shearX+=(i.data.shearX+o-i.shearX)*r,i.shearY+=(i.data.shearY+d-i.shearY)*r;break;case U.add:i.shearX+=o*r,i.shearY+=d*r}}},Ic=class extends kn{constructor(t,e,s){super(t,e,`${Ht.shearX}|${s}`),Et(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case U.setup:i.shearX=i.data.shearX;return;case U.first:i.shearX+=(i.data.shearX-i.shearX)*r}return}const o=this.getCurveValue(s);switch(c){case U.setup:i.shearX=i.data.shearX+o*r;break;case U.first:case U.replace:i.shearX+=(i.data.shearX+o-i.shearX)*r;break;case U.add:i.shearX+=o*r}}},Rc=class extends kn{constructor(t,e,s){super(t,e,`${Ht.shearY}|${s}`),Et(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case U.setup:i.shearY=i.data.shearY;return;case U.first:i.shearY+=(i.data.shearY-i.shearY)*r}return}const o=this.getCurveValue(s);switch(c){case U.setup:i.shearY=i.data.shearY+o*r;break;case U.first:case U.replace:i.shearY+=(i.data.shearY+o-i.shearY)*r;break;case U.add:i.shearY+=o*r}}},Pc=class extends Pn{constructor(t,e,s){super(t,e,[`${Ht.rgb}|${s}`,`${Ht.alpha}|${s}`]),Et(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 5}setFrame(t,e,s,n,r,c){t*=5,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=c}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color;if(s<a[0]){const y=i.data.color;switch(c){case U.setup:o.setFromColor(y);return;case U.first:o.add((y.r-o.r)*r,(y.g-o.g)*r,(y.b-o.b)*r,(y.a-o.a)*r)}return}let d=0,f=0,m=0,l=0;const g=ge.search(a,s,5),p=this.curves[g/5];switch(p){case 0:const y=a[g];d=a[g+1],f=a[g+2],m=a[g+3],l=a[g+4];const w=(s-y)/(a[g+5]-y);d+=(a[g+5+1]-d)*w,f+=(a[g+5+2]-f)*w,m+=(a[g+5+3]-m)*w,l+=(a[g+5+4]-l)*w;break;case 1:d=a[g+1],f=a[g+2],m=a[g+3],l=a[g+4];break;default:d=this.getBezierValue(s,g,1,p-2),f=this.getBezierValue(s,g,2,p+18-2),m=this.getBezierValue(s,g,3,p+18*2-2),l=this.getBezierValue(s,g,4,p+18*3-2)}r==1?o.set(d,f,m,l):(c==U.setup&&o.setFromColor(i.data.color),o.add((d-o.r)*r,(f-o.g)*r,(m-o.b)*r,(l-o.a)*r))}},kc=class extends Pn{constructor(t,e,s){super(t,e,[`${Ht.rgb}|${s}`]),Et(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 4}setFrame(t,e,s,n,r){t<<=2,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color;if(s<a[0]){const p=i.data.color;switch(c){case U.setup:o.r=p.r,o.g=p.g,o.b=p.b;return;case U.first:o.r+=(p.r-o.r)*r,o.g+=(p.g-o.g)*r,o.b+=(p.b-o.b)*r}return}let d=0,f=0,m=0;const l=ge.search(a,s,4),g=this.curves[l>>2];switch(g){case 0:const p=a[l];d=a[l+1],f=a[l+2],m=a[l+3];const y=(s-p)/(a[l+4]-p);d+=(a[l+4+1]-d)*y,f+=(a[l+4+2]-f)*y,m+=(a[l+4+3]-m)*y;break;case 1:d=a[l+1],f=a[l+2],m=a[l+3];break;default:d=this.getBezierValue(s,l,1,g-2),f=this.getBezierValue(s,l,2,g+18-2),m=this.getBezierValue(s,l,3,g+18*2-2)}if(r==1)o.r=d,o.g=f,o.b=m;else{if(c==U.setup){const p=i.data.color;o.r=p.r,o.g=p.g,o.b=p.b}o.r+=(d-o.r)*r,o.g+=(f-o.g)*r,o.b+=(m-o.b)*r}}},Fc=class extends kn{constructor(t,e,s){super(t,e,`${Ht.alpha}|${s}`),Et(this,"slotIndex",0),this.slotIndex=s}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.color;if(s<this.frames[0]){const d=i.data.color;switch(c){case U.setup:a.a=d.a;return;case U.first:a.a+=(d.a-a.a)*r}return}const o=this.getCurveValue(s);r==1?a.a=o:(c==U.setup&&(a.a=i.data.color.a),a.a+=(o-a.a)*r)}},Yc=class extends Pn{constructor(t,e,s){super(t,e,[`${Ht.rgb}|${s}`,`${Ht.alpha}|${s}`,`${Ht.rgb2}|${s}`]),Et(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 8}setFrame(t,e,s,n,r,c,h,i,a){t<<=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=c,this.frames[t+5]=h,this.frames[t+6]=i,this.frames[t+7]=a}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color,d=i.darkColor;if(s<a[0]){const S=i.data.color,C=i.data.darkColor;switch(c){case U.setup:o.setFromColor(S),d.r=C.r,d.g=C.g,d.b=C.b;return;case U.first:o.add((S.r-o.r)*r,(S.g-o.g)*r,(S.b-o.b)*r,(S.a-o.a)*r),d.r+=(C.r-d.r)*r,d.g+=(C.g-d.g)*r,d.b+=(C.b-d.b)*r}return}let f=0,m=0,l=0,g=0,p=0,y=0,w=0;const b=ge.search(a,s,8),x=this.curves[b>>3];switch(x){case 0:const S=a[b];f=a[b+1],m=a[b+2],l=a[b+3],g=a[b+4],p=a[b+5],y=a[b+6],w=a[b+7];const C=(s-S)/(a[b+8]-S);f+=(a[b+8+1]-f)*C,m+=(a[b+8+2]-m)*C,l+=(a[b+8+3]-l)*C,g+=(a[b+8+4]-g)*C,p+=(a[b+8+5]-p)*C,y+=(a[b+8+6]-y)*C,w+=(a[b+8+7]-w)*C;break;case 1:f=a[b+1],m=a[b+2],l=a[b+3],g=a[b+4],p=a[b+5],y=a[b+6],w=a[b+7];break;default:f=this.getBezierValue(s,b,1,x-2),m=this.getBezierValue(s,b,2,x+18-2),l=this.getBezierValue(s,b,3,x+18*2-2),g=this.getBezierValue(s,b,4,x+18*3-2),p=this.getBezierValue(s,b,5,x+18*4-2),y=this.getBezierValue(s,b,6,x+18*5-2),w=this.getBezierValue(s,b,7,x+18*6-2)}if(r==1)o.set(f,m,l,g),d.r=p,d.g=y,d.b=w;else{if(c==U.setup){o.setFromColor(i.data.color);const S=i.data.darkColor;d.r=S.r,d.g=S.g,d.b=S.b}o.add((f-o.r)*r,(m-o.g)*r,(l-o.b)*r,(g-o.a)*r),d.r+=(p-d.r)*r,d.g+=(y-d.g)*r,d.b+=(w-d.b)*r}}},$c=class extends Pn{constructor(t,e,s){super(t,e,[`${Ht.rgb}|${s}`,`${Ht.rgb2}|${s}`]),Et(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 7}setFrame(t,e,s,n,r,c,h,i){t*=7,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=c,this.frames[t+5]=h,this.frames[t+6]=i}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color,d=i.darkColor;if(s<a[0]){const x=i.data.color,S=i.data.darkColor;switch(c){case U.setup:o.r=x.r,o.g=x.g,o.b=x.b,d.r=S.r,d.g=S.g,d.b=S.b;return;case U.first:o.r+=(x.r-o.r)*r,o.g+=(x.g-o.g)*r,o.b+=(x.b-o.b)*r,d.r+=(S.r-d.r)*r,d.g+=(S.g-d.g)*r,d.b+=(S.b-d.b)*r}return}let f=0,m=0,l=0,g=0,p=0,y=0;const w=ge.search(a,s,7),b=this.curves[w/7];switch(b){case 0:const x=a[w];f=a[w+1],m=a[w+2],l=a[w+3],g=a[w+4],p=a[w+5],y=a[w+6];const S=(s-x)/(a[w+7]-x);f+=(a[w+7+1]-f)*S,m+=(a[w+7+2]-m)*S,l+=(a[w+7+3]-l)*S,g+=(a[w+7+4]-g)*S,p+=(a[w+7+5]-p)*S,y+=(a[w+7+6]-y)*S;break;case 1:f=a[w+1],m=a[w+2],l=a[w+3],g=a[w+4],p=a[w+5],y=a[w+6];break;default:f=this.getBezierValue(s,w,1,b-2),m=this.getBezierValue(s,w,2,b+18-2),l=this.getBezierValue(s,w,3,b+18*2-2),g=this.getBezierValue(s,w,4,b+18*3-2),p=this.getBezierValue(s,w,5,b+18*4-2),y=this.getBezierValue(s,w,6,b+18*5-2)}if(r==1)o.r=f,o.g=m,o.b=l,d.r=g,d.g=p,d.b=y;else{if(c==U.setup){const x=i.data.color,S=i.data.darkColor;o.r=x.r,o.g=x.g,o.b=x.b,d.r=S.r,d.g=S.g,d.b=S.b}o.r+=(f-o.r)*r,o.g+=(m-o.g)*r,o.b+=(l-o.b)*r,d.r+=(g-d.r)*r,d.g+=(p-d.g)*r,d.b+=(y-d.b)*r}}},sa=class extends ge{constructor(t,e){super(t,[`${Ht.attachment}|${e}`]),Et(this,"slotIndex",0),Et(this,"attachmentNames"),this.slotIndex=e,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.attachmentNames[t]=s}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(i.bone.active){if(h==Hs.mixOut){c==U.setup&&this.setAttachment(t,i,i.data.attachmentName);return}if(s<this.frames[0]){(c==U.setup||c==U.first)&&this.setAttachment(t,i,i.data.attachmentName);return}this.setAttachment(t,i,this.attachmentNames[ge.search1(this.frames,s)])}}setAttachment(t,e,s){e.setAttachment(s?t.getAttachment(this.slotIndex,s):null)}},_c=class extends Pn{constructor(t,e,s,n){super(t,e,[`${Ht.deform}|${s}|${n.id}`]),Et(this,"slotIndex",0),Et(this,"attachment"),Et(this,"vertices"),this.slotIndex=s,this.attachment=n,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.vertices[t]=s}setBezier(t,e,s,n,r,c,h,i,a,o,d){const f=this.curves;let m=this.getFrameCount()+t*18;s==0&&(f[e]=2+m);const l=(n-c*2+i)*.03,g=a*.03-h*.06,p=((c-i)*3-n+o)*.006,y=(h-a+.33333333)*.018;let w=l*2+p,b=g*2+y,x=(c-n)*.3+l+p*.16666667,S=h*.3+g+y*.16666667,C=n+x,A=S;for(let v=m+18;m<v;m+=2)f[m]=C,f[m+1]=A,x+=w,S+=b,w+=p,b+=y,C+=x,A+=S}getCurvePercent(t,e){const s=this.curves;let n=s[e];switch(n){case 0:const i=this.frames[e];return(t-i)/(this.frames[e+this.getFrameEntries()]-i);case 1:return 0}if(n-=2,s[n]>t){const i=this.frames[e];return s[n+1]*(t-i)/(s[n]-i)}const r=n+18;for(n+=2;n<r;n+=2)if(s[n]>=t){const i=s[n-2],a=s[n-1];return a+(t-i)/(s[n]-i)*(s[n+1]-a)}const c=s[r-2],h=s[r-1];return h+(1-h)*(t-c)/(this.frames[e+this.getFrameEntries()]-c)}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.getAttachment();if(!a||!(a instanceof ar)||a.timelineAttachment!=this.attachment)return;const o=i.deform;o.length==0&&(c=U.setup);const d=this.vertices,f=d[0].length,m=this.frames;if(s<m[0]){switch(c){case U.setup:o.length=0;return;case U.first:if(r==1){o.length=0;return}o.length=f;const w=a;if(w.bones){r=1-r;for(let b=0;b<f;b++)o[b]*=r}else{const b=w.vertices;for(let x=0;x<f;x++)o[x]+=(b[x]-o[x])*r}}return}if(o.length=f,s>=m[m.length-1]){const w=d[m.length-1];if(r==1)if(c==U.add){const b=a;if(b.bones)for(let x=0;x<f;x++)o[x]+=w[x];else{const x=b.vertices;for(let S=0;S<f;S++)o[S]+=w[S]-x[S]}}else ct.arrayCopy(w,0,o,0,f);else switch(c){case U.setup:{const x=a;if(x.bones)for(let S=0;S<f;S++)o[S]=w[S]*r;else{const S=x.vertices;for(let C=0;C<f;C++){const A=S[C];o[C]=A+(w[C]-A)*r}}break}case U.first:case U.replace:for(let x=0;x<f;x++)o[x]+=(w[x]-o[x])*r;break;case U.add:const b=a;if(b.bones)for(let x=0;x<f;x++)o[x]+=w[x]*r;else{const x=b.vertices;for(let S=0;S<f;S++)o[S]+=(w[S]-x[S])*r}}return}const l=ge.search1(m,s),g=this.getCurvePercent(s,l),p=d[l],y=d[l+1];if(r==1)if(c==U.add){const w=a;if(w.bones)for(let b=0;b<f;b++){const x=p[b];o[b]+=x+(y[b]-x)*g}else{const b=w.vertices;for(let x=0;x<f;x++){const S=p[x];o[x]+=S+(y[x]-S)*g-b[x]}}}else for(let w=0;w<f;w++){const b=p[w];o[w]=b+(y[w]-b)*g}else switch(c){case U.setup:{const b=a;if(b.bones)for(let x=0;x<f;x++){const S=p[x];o[x]=(S+(y[x]-S)*g)*r}else{const x=b.vertices;for(let S=0;S<f;S++){const C=p[S],A=x[S];o[S]=A+(C+(y[S]-C)*g-A)*r}}break}case U.first:case U.replace:for(let b=0;b<f;b++){const x=p[b];o[b]+=(x+(y[b]-x)*g-o[b])*r}break;case U.add:const w=a;if(w.bones)for(let b=0;b<f;b++){const x=p[b];o[b]+=(x+(y[b]-x)*g)*r}else{const b=w.vertices;for(let x=0;x<f;x++){const S=p[x];o[x]+=(S+(y[x]-S)*g-b[x])*r}}}}};const If=class hp extends ge{constructor(t){super(t,hp.propertyIds),Et(this,"events"),this.events=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,s,n,r,c,h){if(!n)return;const i=this.frames,a=this.frames.length;if(e>s)this.apply(t,e,Number.MAX_VALUE,n,r,c,h),e=-1;else if(e>=i[a-1])return;if(s<i[0])return;let o=0;if(e<i[0])o=0;else{o=ge.search1(i,e)+1;const d=i[o];for(;o>0&&i[o-1]==d;)o--}for(;o<a&&s>=i[o];o++)n.push(this.events[o])}};Et(If,"propertyIds",[`${Ht.event}`]);let ll=If;const Rf=class dp extends ge{constructor(t){super(t,dp.propertyIds),Et(this,"drawOrders"),this.drawOrders=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.drawOrders[t]=s}apply(t,e,s,n,r,c,h){if(h==Hs.mixOut){c==U.setup&&ct.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}if(s<this.frames[0]){(c==U.setup||c==U.first)&&ct.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const i=ge.search1(this.frames,s),a=this.drawOrders[i];if(!a)ct.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);else{const o=t.drawOrder,d=t.slots;for(let f=0,m=a.length;f<m;f++)o[f]=d[a[f]]}}};Et(Rf,"propertyIds",[`${Ht.drawOrder}`]);let Ea=Rf,Xc=class extends Pn{constructor(t,e,s){super(t,e,[`${Ht.ikConstraint}|${s}`]),Et(this,"ikConstraintIndex",0),this.ikConstraintIndex=s}getFrameEntries(){return 6}setFrame(t,e,s,n,r,c,h){t*=6,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=c?1:0,this.frames[t+5]=h?1:0}apply(t,e,s,n,r,c,h){const i=t.ikConstraints[this.ikConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case U.setup:i.mix=i.data.mix,i.softness=i.data.softness,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch;return;case U.first:i.mix+=(i.data.mix-i.mix)*r,i.softness+=(i.data.softness-i.softness)*r,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch}return}let o=0,d=0;const f=ge.search(a,s,6),m=this.curves[f/6];switch(m){case 0:const l=a[f];o=a[f+1],d=a[f+2];const g=(s-l)/(a[f+6]-l);o+=(a[f+6+1]-o)*g,d+=(a[f+6+2]-d)*g;break;case 1:o=a[f+1],d=a[f+2];break;default:o=this.getBezierValue(s,f,1,m-2),d=this.getBezierValue(s,f,2,m+18-2)}c==U.setup?(i.mix=i.data.mix+(o-i.data.mix)*r,i.softness=i.data.softness+(d-i.data.softness)*r,h==Hs.mixOut?(i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch):(i.bendDirection=a[f+3],i.compress=a[f+4]!=0,i.stretch=a[f+5]!=0)):(i.mix+=(o-i.mix)*r,i.softness+=(d-i.softness)*r,h==Hs.mixIn&&(i.bendDirection=a[f+3],i.compress=a[f+4]!=0,i.stretch=a[f+5]!=0))}},Bc=class extends Pn{constructor(t,e,s){super(t,e,[`${Ht.transformConstraint}|${s}`]),Et(this,"transformConstraintIndex",0),this.transformConstraintIndex=s}getFrameEntries(){return 7}setFrame(t,e,s,n,r,c,h,i){const a=this.frames;t*=7,a[t]=e,a[t+1]=s,a[t+2]=n,a[t+3]=r,a[t+4]=c,a[t+5]=h,a[t+6]=i}apply(t,e,s,n,r,c,h){const i=t.transformConstraints[this.transformConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){const w=i.data;switch(c){case U.setup:i.mixRotate=w.mixRotate,i.mixX=w.mixX,i.mixY=w.mixY,i.mixScaleX=w.mixScaleX,i.mixScaleY=w.mixScaleY,i.mixShearY=w.mixShearY;return;case U.first:i.mixRotate+=(w.mixRotate-i.mixRotate)*r,i.mixX+=(w.mixX-i.mixX)*r,i.mixY+=(w.mixY-i.mixY)*r,i.mixScaleX+=(w.mixScaleX-i.mixScaleX)*r,i.mixScaleY+=(w.mixScaleY-i.mixScaleY)*r,i.mixShearY+=(w.mixShearY-i.mixShearY)*r}return}let o,d,f,m,l,g;const p=ge.search(a,s,7),y=this.curves[p/7];switch(y){case 0:const w=a[p];o=a[p+1],d=a[p+2],f=a[p+3],m=a[p+4],l=a[p+5],g=a[p+6];const b=(s-w)/(a[p+7]-w);o+=(a[p+7+1]-o)*b,d+=(a[p+7+2]-d)*b,f+=(a[p+7+3]-f)*b,m+=(a[p+7+4]-m)*b,l+=(a[p+7+5]-l)*b,g+=(a[p+7+6]-g)*b;break;case 1:o=a[p+1],d=a[p+2],f=a[p+3],m=a[p+4],l=a[p+5],g=a[p+6];break;default:o=this.getBezierValue(s,p,1,y-2),d=this.getBezierValue(s,p,2,y+18-2),f=this.getBezierValue(s,p,3,y+18*2-2),m=this.getBezierValue(s,p,4,y+18*3-2),l=this.getBezierValue(s,p,5,y+18*4-2),g=this.getBezierValue(s,p,6,y+18*5-2)}if(c==U.setup){const w=i.data;i.mixRotate=w.mixRotate+(o-w.mixRotate)*r,i.mixX=w.mixX+(d-w.mixX)*r,i.mixY=w.mixY+(f-w.mixY)*r,i.mixScaleX=w.mixScaleX+(m-w.mixScaleX)*r,i.mixScaleY=w.mixScaleY+(l-w.mixScaleY)*r,i.mixShearY=w.mixShearY+(g-w.mixShearY)*r}else i.mixRotate+=(o-i.mixRotate)*r,i.mixX+=(d-i.mixX)*r,i.mixY+=(f-i.mixY)*r,i.mixScaleX+=(m-i.mixScaleX)*r,i.mixScaleY+=(l-i.mixScaleY)*r,i.mixShearY+=(g-i.mixShearY)*r}},Vc=class extends kn{constructor(t,e,s){super(t,e,`${Ht.pathConstraintPosition}|${s}`),Et(this,"pathConstraintIndex",0),this.pathConstraintIndex=s}apply(t,e,s,n,r,c,h){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case U.setup:i.position=i.data.position;return;case U.first:i.position+=(i.data.position-i.position)*r}return}const o=this.getCurveValue(s);c==U.setup?i.position=i.data.position+(o-i.data.position)*r:i.position+=(o-i.position)*r}},Nc=class extends kn{constructor(t,e,s){super(t,e,`${Ht.pathConstraintSpacing}|${s}`),Et(this,"pathConstraintIndex",0),this.pathConstraintIndex=s}apply(t,e,s,n,r,c,h){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case U.setup:i.spacing=i.data.spacing;return;case U.first:i.spacing+=(i.data.spacing-i.spacing)*r}return}const o=this.getCurveValue(s);c==U.setup?i.spacing=i.data.spacing+(o-i.data.spacing)*r:i.spacing+=(o-i.spacing)*r}},Dc=class extends Pn{constructor(t,e,s){super(t,e,[`${Ht.pathConstraintMix}|${s}`]),Et(this,"pathConstraintIndex",0),this.pathConstraintIndex=s}getFrameEntries(){return 4}setFrame(t,e,s,n,r){const c=this.frames;t<<=2,c[t]=e,c[t+1]=s,c[t+2]=n,c[t+3]=r}apply(t,e,s,n,r,c,h){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case U.setup:i.mixRotate=i.data.mixRotate,i.mixX=i.data.mixX,i.mixY=i.data.mixY;return;case U.first:i.mixRotate+=(i.data.mixRotate-i.mixRotate)*r,i.mixX+=(i.data.mixX-i.mixX)*r,i.mixY+=(i.data.mixY-i.mixY)*r}return}let o,d,f;const m=ge.search(a,s,4),l=this.curves[m>>2];switch(l){case 0:const g=a[m];o=a[m+1],d=a[m+2],f=a[m+3];const p=(s-g)/(a[m+4]-g);o+=(a[m+4+1]-o)*p,d+=(a[m+4+2]-d)*p,f+=(a[m+4+3]-f)*p;break;case 1:o=a[m+1],d=a[m+2],f=a[m+3];break;default:o=this.getBezierValue(s,m,1,l-2),d=this.getBezierValue(s,m,2,l+18-2),f=this.getBezierValue(s,m,3,l+18*2-2)}if(c==U.setup){const g=i.data;i.mixRotate=g.mixRotate+(o-g.mixRotate)*r,i.mixX=g.mixX+(d-g.mixX)*r,i.mixY=g.mixY+(f-g.mixY)*r}else i.mixRotate+=(o-i.mixRotate)*r,i.mixX+=(d-i.mixX)*r,i.mixY+=(f-i.mixY)*r}};const cl=class Ii extends ge{constructor(t,e,s){super(t,[`${Ht.sequence}|${e}|${s.sequence.id}`]),Et(this,"slotIndex"),Et(this,"attachment"),this.slotIndex=e,this.attachment=s}getFrameEntries(){return Ii.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(t,e,s,n,r){const c=this.frames;t*=Ii.ENTRIES,c[t]=e,c[t+Ii.MODE]=s|n<<4,c[t+Ii.DELAY]=r}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.attachment,o=this.attachment;if(a!=o&&(!(a instanceof ar)||a.timelineAttachment!=o))return;const d=this.frames;if(s<d[0]){(c==U.setup||c==U.first)&&(i.sequenceIndex=-1);return}const f=ge.search(d,s,Ii.ENTRIES),m=d[f],l=d[f+Ii.MODE],g=d[f+Ii.DELAY];if(!this.attachment.sequence)return;let p=l>>4;const y=this.attachment.sequence.regions.length,w=yc[l&15];if(w!=or.hold)switch(p+=(s-m)/g+1e-5|0,w){case or.once:p=Math.min(y-1,p);break;case or.loop:p%=y;break;case or.pingpong:{const b=(y<<1)-2;p=b==0?0:p%b,p>=y&&(p=b-p);break}case or.onceReverse:p=Math.max(y-1-p,0);break;case or.loopReverse:p=y-1-p%y;break;case or.pingpongReverse:{const b=(y<<1)-2;p=b==0?0:(p+y-1)%b,p>=y&&(p=b-p)}}i.sequenceIndex=p}};Et(cl,"ENTRIES",3),Et(cl,"MODE",1),Et(cl,"DELAY",2);let Lc=cl;var S1=Object.defineProperty,C1=(u,t,e)=>t in u?S1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ht=(u,t,e)=>C1(u,typeof t!="symbol"?t+"":t,e);const yo=class wr{constructor(t){ht(this,"data"),ht(this,"tracks",new Array),ht(this,"timeScale",1),ht(this,"unkeyedState",0),ht(this,"events",new Array),ht(this,"listeners",new Array),ht(this,"queue",new Ff(this)),ht(this,"propertyIDs",new xf),ht(this,"animationsChanged",!1),ht(this,"trackEntryPool",new yf(()=>new kf)),ht(this,"onComplete"),ht(this,"onEvent"),ht(this,"onStart"),ht(this,"onEnd"),this.data=t}static emptyAnimation(){return wr._emptyAnimation}update(t){t*=this.timeScale;const e=this.tracks;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(!r)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let c=t*r.timeScale;if(r.delay>0){if(r.delay-=c,r.delay>0)continue;c=-r.delay,r.delay=0}let h=r.next;if(h){const i=r.trackLast-h.delay;if(i>=0){for(h.delay=0,h.trackTime+=r.timeScale==0?0:(i/r.timeScale+t)*h.timeScale,r.trackTime+=c,this.setCurrent(s,h,!0);h.mixingFrom;)h.mixTime+=t,h=h.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&!r.mixingFrom){e[s]=null,this.queue.end(r),this.clearNext(r);continue}if(r.mixingFrom&&this.updateMixingFrom(r,t)){let i=r.mixingFrom;for(r.mixingFrom=null,i&&(i.mixingTo=null);i;)this.queue.end(i),i=i.mixingFrom}r.trackTime+=c}this.queue.drain()}updateMixingFrom(t,e){const s=t.mixingFrom;if(!s)return!0;const n=this.updateMixingFrom(s,e);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?((s.totalAlpha==0||t.mixDuration==0)&&(t.mixingFrom=s.mixingFrom,s.mixingFrom&&(s.mixingFrom.mixingTo=t),t.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=e*s.timeScale,t.mixTime+=e,!1)}apply(t){if(!t)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,s=this.tracks;let n=!1;for(let h=0,i=s.length;h<i;h++){const a=s[h];if(!a||a.delay>0)continue;n=!0;const o=h==0?U.first:a.mixBlend;let d=a.alpha;a.mixingFrom?d*=this.applyMixingFrom(a,t,o):a.trackTime>=a.trackEnd&&!a.next&&(d=0);const f=a.animationLast,m=a.getAnimationTime();let l=m,g=e;a.reverse&&(l=a.animation.duration-l,g=null);const p=a.animation.timelines,y=p.length;if(h==0&&d==1||o==U.add)for(let w=0;w<y;w++){ct.webkit602BugfixHelper(d,o);const b=p[w];b instanceof sa?this.applyAttachmentTimeline(b,t,l,o,!0):b.apply(t,f,l,g,d,o,Hs.mixIn)}else{const w=a.timelineMode,b=a.shortestRotation,x=!b&&a.timelinesRotation.length!=y<<1;x&&(a.timelinesRotation.length=y<<1);for(let S=0;S<y;S++){const C=p[S],A=w[S]==Wc?o:U.setup;!b&&C instanceof wo?this.applyRotateTimeline(C,t,l,d,A,a.timelinesRotation,S<<1,x):C instanceof sa?this.applyAttachmentTimeline(C,t,l,o,!0):(ct.webkit602BugfixHelper(d,o),C.apply(t,f,l,g,d,A,Hs.mixIn))}}this.queueEvents(a,m),e.length=0,a.nextAnimationLast=m,a.nextTrackLast=a.trackTime}const r=this.unkeyedState+Xf,c=t.slots;for(let h=0,i=t.slots.length;h<i;h++){const a=c[h];if(a.attachmentState==r){const o=a.data.attachmentName;a.setAttachment(o?t.getAttachment(a.data.index,o):null)}}return this.unkeyedState+=2,this.queue.drain(),n}applyMixingFrom(t,e,s){const n=t.mixingFrom;n.mixingFrom&&this.applyMixingFrom(n,e,s);let r=0;t.mixDuration==0?(r=1,s==U.first&&(s=U.setup)):(r=t.mixTime/t.mixDuration,r>1&&(r=1),s!=U.first&&(s=n.mixBlend));const c=r<n.attachmentThreshold,h=r<n.drawOrderThreshold,i=n.animation.timelines,a=i.length,o=n.alpha*t.interruptAlpha,d=o*(1-r),f=n.animationLast,m=n.getAnimationTime();let l=m,g=null;if(n.reverse?l=n.animation.duration-l:r<n.eventThreshold&&(g=this.events),s==U.add)for(let p=0;p<a;p++)i[p].apply(e,f,l,g,d,s,Hs.mixOut);else{const p=n.timelineMode,y=n.timelineHoldMix,w=n.shortestRotation,b=!w&&n.timelinesRotation.length!=a<<1;b&&(n.timelinesRotation.length=a<<1),n.totalAlpha=0;for(let x=0;x<a;x++){const S=i[x];let C=Hs.mixOut,A,v=0;switch(p[x]){case Wc:if(!h&&S instanceof Ea)continue;A=s,v=d;break;case $f:A=U.setup,v=d;break;case _f:A=s,v=o;break;case Uc:A=U.setup,v=o;break;default:A=U.setup;const M=y[x];v=o*Math.max(0,1-M.mixTime/M.mixDuration);break}n.totalAlpha+=v,!w&&S instanceof wo?this.applyRotateTimeline(S,e,l,v,A,n.timelinesRotation,x<<1,b):S instanceof sa?this.applyAttachmentTimeline(S,e,l,A,c):(ct.webkit602BugfixHelper(v,s),h&&S instanceof Ea&&A==U.setup&&(C=Hs.mixIn),S.apply(e,f,l,g,v,A,C))}}return t.mixDuration>0&&this.queueEvents(n,m),this.events.length=0,n.nextAnimationLast=m,n.nextTrackLast=n.trackTime,r}applyAttachmentTimeline(t,e,s,n,r){const c=e.slots[t.slotIndex];c.bone.active&&(s<t.frames[0]?(n==U.setup||n==U.first)&&this.setAttachment(e,c,c.data.attachmentName,r):this.setAttachment(e,c,t.attachmentNames[ge.search1(t.frames,s)],r),c.attachmentState<=this.unkeyedState&&(c.attachmentState=this.unkeyedState+Xf))}setAttachment(t,e,s,n){e.setAttachment(s?t.getAttachment(e.data.index,s):null),n&&(e.attachmentState=this.unkeyedState+M1)}applyRotateTimeline(t,e,s,n,r,c,h,i){if(i&&(c[h]=0),n==1){t.apply(e,0,s,null,1,r,Hs.mixIn);return}const a=e.bones[t.boneIndex];if(!a.active)return;const o=t.frames;let d=0,f=0;if(s<o[0])switch(r){case U.setup:a.rotation=a.data.rotation;default:return;case U.first:d=a.rotation,f=a.data.rotation}else d=r==U.setup?a.data.rotation:a.rotation,f=a.data.rotation+t.getCurveValue(s);let m=0,l=f-d;if(l-=(16384-(16384.499999999996-l/360|0))*360,l==0)m=c[h];else{let g=0,p=0;i?(g=0,p=l):(g=c[h],p=c[h+1]);const y=l>0;let w=g>=0;Z.signum(p)!=Z.signum(l)&&Math.abs(p)<=90&&(Math.abs(g)>180&&(g+=360*Z.signum(g)),w=y),m=l+g-g%360,w!=y&&(m+=360*Z.signum(g)),c[h]=m}c[h+1]=l,a.rotation=d+m*n}queueEvents(t,e){const s=t.animationStart,n=t.animationEnd,r=n-s,c=t.trackLast%r,h=this.events;let i=0;const a=h.length;for(;i<a;i++){const d=h[i];if(d.time<c)break;d.time>n||this.queue.event(t,d)}let o=!1;for(t.loop?o=r==0||c>t.trackTime%r:o=e>=n&&t.animationLast<n,o&&this.queue.complete(t);i<a;i++){const d=h[i];d.time<s||this.queue.event(t,d)}}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,s=this.tracks.length;e<s;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(!e)return;this.queue.end(e),this.clearNext(e);let s=e;for(;;){const n=s.mixingFrom;if(!n)break;this.queue.end(n),s.mixingFrom=null,s.mixingTo=null,s=n}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,s){const n=this.expandToIndex(t);this.tracks[t]=e,e.previous=null,n&&(s&&this.queue.interrupt(n),e.mixingFrom=n,n.mixingTo=e,e.mixTime=0,n.mixingFrom&&n.mixDuration>0&&(e.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,s=!1){const n=this.data.skeletonData.findAnimation(e);if(!n)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,n,s)}setAnimationWith(t,e,s=!1){if(!e)throw new Error("animation cannot be null.");let n=!0,r=this.expandToIndex(t);r&&(r.nextTrackLast==-1?(this.tracks[t]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.clearNext(r),r=r.mixingFrom,n=!1):this.clearNext(r));const c=this.trackEntry(t,e,s,r);return this.setCurrent(t,c,n),this.queue.drain(),c}addAnimation(t,e,s=!1,n=0){const r=this.data.skeletonData.findAnimation(e);if(!r)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,r,s,n)}addAnimationWith(t,e,s=!1,n=0){if(!e)throw new Error("animation cannot be null.");let r=this.expandToIndex(t);if(r)for(;r.next;)r=r.next;const c=this.trackEntry(t,e,s,r);return r?(r.next=c,c.previous=r,n<=0&&(n+=r.getTrackComplete()-c.mixDuration)):(this.setCurrent(t,c,!0),this.queue.drain()),c.delay=n,c}setEmptyAnimation(t,e=0){const s=this.setAnimationWith(t,wr.emptyAnimation(),!1);return s.mixDuration=e,s.trackEnd=e,s}addEmptyAnimation(t,e=0,s=0){const n=this.addAnimationWith(t,wr.emptyAnimation(),!1,s);return s<=0&&(n.delay+=n.mixDuration-e),n.mixDuration=e,n.trackEnd=e,n}setEmptyAnimations(t=0){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,n=this.tracks.length;s<n;s++){const r=this.tracks[s];r&&this.setEmptyAnimation(r.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(ct.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,s,n){const r=this.trackEntryPool.obtain();return r.reset(),r.trackIndex=t,r.animation=e,r.loop=s,r.holdPrevious=!1,r.reverse=!1,r.shortestRotation=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=e.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.mixTime=0,r.mixDuration=n?this.data.getMix(n.animation,e):0,r.interruptAlpha=1,r.totalAlpha=0,r.mixBlend=U.replace,r}clearNext(t){let e=t.next;for(;e;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const t=this.tracks;for(let e=0,s=t.length;e<s;e++){let n=t[e];if(n){for(;n.mixingFrom;)n=n.mixingFrom;do(!n.mixingTo||n.mixBlend!=U.add)&&this.computeHold(n),n=n.mixingTo;while(n)}}}computeHold(t){const e=t.mixingTo,s=t.animation.timelines,n=t.animation.timelines.length,r=t.timelineMode;r.length=n;const c=t.timelineHoldMix;c.length=0;const h=this.propertyIDs;if(e&&e.holdPrevious){for(let i=0;i<n;i++)r[i]=h.addAll(s[i].getPropertyIds())?Uc:_f;return}t:for(let i=0;i<n;i++){const a=s[i],o=a.getPropertyIds();if(!h.addAll(o))r[i]=Wc;else if(!e||a instanceof sa||a instanceof Ea||a instanceof ll||!e.animation.hasTimeline(o))r[i]=$f;else{for(let d=e.mixingTo;d;d=d.mixingTo)if(!d.animation.hasTimeline(o)){if(t.mixDuration>0){r[i]=v1,c[i]=d;continue t}break}r[i]=Uc}}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(!t)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,e,s){wr.deprecatedWarning1||(wr.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,e,s)}addAnimationByName(t,e,s,n){wr.deprecatedWarning2||(wr.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,e,s,n)}hasAnimation(t){return this.data.skeletonData.findAnimation(t)!==null}hasAnimationByName(t){return wr.deprecatedWarning3||(wr.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};ht(yo,"_emptyAnimation",new al("<empty>",[],0)),ht(yo,"deprecatedWarning1",!1),ht(yo,"deprecatedWarning2",!1),ht(yo,"deprecatedWarning3",!1);let Pf=yo;const Oc=class Or{constructor(){ht(this,"animation",null),ht(this,"previous",null),ht(this,"next",null),ht(this,"mixingFrom",null),ht(this,"mixingTo",null),ht(this,"listener",null),ht(this,"trackIndex",0),ht(this,"loop",!1),ht(this,"holdPrevious",!1),ht(this,"reverse",!1),ht(this,"shortestRotation",!1),ht(this,"eventThreshold",0),ht(this,"attachmentThreshold",0),ht(this,"drawOrderThreshold",0),ht(this,"animationStart",0),ht(this,"animationEnd",0),ht(this,"animationLast",0),ht(this,"nextAnimationLast",0),ht(this,"delay",0),ht(this,"trackTime",0),ht(this,"trackLast",0),ht(this,"nextTrackLast",0),ht(this,"trackEnd",0),ht(this,"timeScale",0),ht(this,"alpha",0),ht(this,"mixTime",0),ht(this,"mixDuration",0),ht(this,"interruptAlpha",0),ht(this,"totalAlpha",0),ht(this,"mixBlend",U.replace),ht(this,"timelineMode",new Array),ht(this,"timelineHoldMix",new Array),ht(this,"timelinesRotation",new Array),ht(this,"onComplete"),ht(this,"onEvent"),ht(this,"onStart"),ht(this,"onEnd")}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const t=this.animationEnd-this.animationStart;if(t!=0){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}get time(){return Or.deprecatedWarning1||(Or.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){Or.deprecatedWarning1||(Or.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return Or.deprecatedWarning2||(Or.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){Or.deprecatedWarning2||(Or.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};ht(Oc,"deprecatedWarning1",!1),ht(Oc,"deprecatedWarning2",!1);let kf=Oc,Ff=class{constructor(t){ht(this,"objects",[]),ht(this,"drainDisabled",!1),ht(this,"animState"),this.animState=t}start(t){this.objects.push(0),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(1),this.objects.push(t)}end(t){this.objects.push(2),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(3),this.objects.push(t)}complete(t){this.objects.push(4),this.objects.push(t)}event(t,e){this.objects.push(5),this.objects.push(t),this.objects.push(e)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let s=0;s<t.length;s+=2){const n=t[s],r=t[s+1];switch(n){case 0:r.listener&&r.listener.start&&r.listener.start(r);for(let h=0;h<e.length;h++){const i=e[h];i.start&&i.start(r)}break;case 1:r.listener&&r.listener.interrupt&&r.listener.interrupt(r);for(let h=0;h<e.length;h++){const i=e[h];i.interrupt&&i.interrupt(r)}break;case 2:r.listener&&r.listener.end&&r.listener.end(r);for(let h=0;h<e.length;h++){const i=e[h];i.end&&i.end(r)}case 3:r.listener&&r.listener.dispose&&r.listener.dispose(r);for(let h=0;h<e.length;h++){const i=e[h];i.dispose&&i.dispose(r)}this.animState.trackEntryPool.free(r);break;case 4:r.listener&&r.listener.complete&&r.listener.complete(r);for(let h=0;h<e.length;h++){const i=e[h];i.complete&&i.complete(r)}break;case 5:const c=t[s+++2];r.listener&&r.listener.event&&r.listener.event(r,c);for(let h=0;h<e.length;h++){const i=e[h];i.event&&i.event(r,c)}break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};var Yf=(u=>(u[u.start=0]="start",u[u.interrupt=1]="interrupt",u[u.end=2]="end",u[u.dispose=3]="dispose",u[u.complete=4]="complete",u[u.event=5]="event",u))(Yf||{});let A1=class{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}};const Wc=0,$f=1,_f=2,Uc=3,v1=4,Xf=1,M1=2;var E1=Object.defineProperty,T1=(u,t,e)=>t in u?E1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Bf=(u,t,e)=>T1(u,typeof t!="symbol"?t+"":t,e);let Vf=class up extends ar{constructor(t){super(t),Bf(this,"type",Se.BoundingBox),Bf(this,"color",new kt(1,1,1,1))}copy(){const t=new up(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}};var I1=Object.defineProperty,R1=(u,t,e)=>t in u?I1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,qc=(u,t,e)=>R1(u,typeof t!="symbol"?t+"":t,e);let Nf=class fp extends ar{constructor(t){super(t),qc(this,"type",Se.Clipping),qc(this,"endSlot",null),qc(this,"color",new kt(.2275,.2275,.8078,1))}copy(){const t=new fp(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}};var P1=Object.defineProperty,k1=(u,t,e)=>t in u?P1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ln=(u,t,e)=>k1(u,typeof t!="symbol"?t+"":t,e);let hl=class Bd extends ar{constructor(t,e){super(t),ln(this,"type",Se.Mesh),ln(this,"region",null),ln(this,"path"),ln(this,"regionUVs"),ln(this,"triangles",[]),ln(this,"color",new kt(1,1,1,1)),ln(this,"width",0),ln(this,"height",0),ln(this,"hullLength",0),ln(this,"edges",[]),ln(this,"parentMesh",null),ln(this,"sequence",null),ln(this,"tempColor",new kt(0,0,0,0)),this.path=e}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new Bd(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),ct.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),ct.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,t.sequence=this.sequence!=null?this.sequence.copy():null,this.edges&&(t.edges=new Array(this.edges.length),ct.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}computeWorldVertices(t,e,s,n,r,c){this.sequence!=null&&this.sequence.apply(t,this),super.computeWorldVertices(t,e,s,n,r,c)}newLinkedMesh(){const t=new Bd(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),t.timelineAttachment=this.timelineAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}};var F1=Object.defineProperty,Y1=(u,t,e)=>t in u?F1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,So=(u,t,e)=>Y1(u,typeof t!="symbol"?t+"":t,e);let Co=class mp extends ar{constructor(t){super(t),So(this,"type",Se.Path),So(this,"lengths",[]),So(this,"closed",!1),So(this,"constantSpeed",!1),So(this,"color",new kt(1,1,1,1))}copy(){const t=new mp(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),ct.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}};var $1=Object.defineProperty,_1=(u,t,e)=>t in u?$1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ao=(u,t,e)=>_1(u,typeof t!="symbol"?t+"":t,e);let Df=class gp extends ar{constructor(t){super(t),Ao(this,"type",Se.Point),Ao(this,"x",0),Ao(this,"y",0),Ao(this,"rotation",0),Ao(this,"color",new kt(.38,.94,0,1))}computeWorldPosition(t,e){const s=t.matrix;return e.x=this.x*s.a+this.y*s.c+t.worldX,e.y=this.x*s.b+this.y*s.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,s=Z.cosDeg(this.rotation),n=Z.sinDeg(this.rotation),r=s*e.a+n*e.c,c=s*e.b+n*e.d;return Math.atan2(c,r)*Z.radDeg}copy(){const t=new gp(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}};var X1=Object.defineProperty,B1=(u,t,e)=>t in u?X1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,V1=(u,t,e)=>B1(u,typeof t!="symbol"?t+"":t,e);let Gc=class{constructor(t){V1(this,"atlas"),this.atlas=t}loadSequence(t,e,s){const n=s.regions;for(let r=0,c=n.length;r<c;r++){const h=s.getPath(e,r),i=this.atlas.findRegion(h);if(i==null)throw new Error(`Region not found in atlas: ${h} (sequence: ${t})`);n[r]=i,n[r].renderObject=n[r]}}newRegionAttachment(t,e,s,n){const r=new xc(e,s);if(n!=null)this.loadSequence(e,s,n);else{const c=this.atlas.findRegion(s);if(!c)throw new Error(`Region not found in atlas: ${s} (region attachment: ${e})`);c.renderObject=c,r.region=c}return r}newMeshAttachment(t,e,s,n){const r=new hl(e,s);if(n!=null)this.loadSequence(e,s,n);else{const c=this.atlas.findRegion(s);if(!c)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${e})`);c.renderObject=c,r.region=c}return r}newBoundingBoxAttachment(t,e){return new Vf(e)}newPathAttachment(t,e){return new Co(e)}newPointAttachment(t,e){return new Df(e)}newClippingAttachment(t,e){return new Nf(e)}};var Er=(u=>(u[u.Fixed=0]="Fixed",u[u.Percent=1]="Percent",u))(Er||{}),Ta=(u=>(u[u.Tangent=0]="Tangent",u[u.Chain=1]="Chain",u[u.ChainScale=2]="ChainScale",u))(Ta||{});let dl=class{constructor(t,e,s){this.name=t,this.order=e,this.skinRequired=s}};var N1=Object.defineProperty,D1=(u,t,e)=>t in u?N1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Fn=(u,t,e)=>D1(u,typeof t!="symbol"?t+"":t,e);let zc=class extends dl{constructor(t){super(t,0,!1),Fn(this,"bones",new Array),Fn(this,"_target",null),Fn(this,"positionMode",Er.Fixed),Fn(this,"spacingMode",1),Fn(this,"rotateMode",Ta.Chain),Fn(this,"offsetRotation",0),Fn(this,"position",0),Fn(this,"spacing",0),Fn(this,"mixRotate",0),Fn(this,"mixX",0),Fn(this,"mixY",0)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}};var Ue=(u=>(u[u.Length=0]="Length",u[u.Fixed=1]="Fixed",u[u.Percent=2]="Percent",u[u.Proportional=3]="Proportional",u))(Ue||{}),L1=Object.defineProperty,O1=(u,t,e)=>t in u?L1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Xe=(u,t,e)=>O1(u,typeof t!="symbol"?t+"":t,e);const vo=class Wr{constructor(t,e){if(Xe(this,"data"),Xe(this,"bones"),Xe(this,"target"),Xe(this,"position",0),Xe(this,"spacing",0),Xe(this,"mixRotate",0),Xe(this,"mixX",0),Xe(this,"mixY",0),Xe(this,"spaces",new Array),Xe(this,"positions",new Array),Xe(this,"world",new Array),Xe(this,"curves",new Array),Xe(this,"lengths",new Array),Xe(this,"segments",new Array),Xe(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let n=0,r=t.bones.length;n<r;n++){const c=e.findBone(t.bones[n].name);if(!c)throw new Error(`Couldn't find bone ${t.bones[n].name}.`);this.bones.push(c)}const s=e.findSlot(t.target.name);if(!s)throw new Error(`Couldn't find target bone ${t.target.name}`);this.target=s,this.position=t.position,this.spacing=t.spacing,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY}isActive(){return this.active}update(){const t=this.target.getAttachment();if(!(t instanceof Co))return;const e=this.mixRotate,s=this.mixX,n=this.mixY;if(e==0&&s==0&&n==0)return;const r=this.data,c=r.rotateMode==Ta.Tangent,h=r.rotateMode==Ta.ChainScale,i=this.bones,a=i.length,o=c?a:a+1,d=ct.setArraySize(this.spaces,o),f=h?this.lengths=ct.setArraySize(this.lengths,a):[],m=this.spacing;switch(r.spacingMode){case Ue.Percent:if(h)for(let S=0,C=o-1;S<C;S++){const A=i[S],v=A.data.length;if(v<Wr.epsilon)f[S]=0;else{const M=v*A.matrix.a,E=v*A.matrix.b;f[S]=Math.sqrt(M*M+E*E)}}ct.arrayFill(d,1,o,m);break;case Ue.Proportional:let b=0;for(let S=0,C=o-1;S<C;){const A=i[S],v=A.data.length;if(v<Wr.epsilon)h&&(f[S]=0),d[++S]=m;else{const M=v*A.matrix.a,E=v*A.matrix.b,T=Math.sqrt(M*M+E*E);h&&(f[S]=T),d[++S]=T,b+=T}}if(b>0){b=o/b*m;for(let S=1;S<o;S++)d[S]*=b}break;default:const x=r.spacingMode==Ue.Length;for(let S=0,C=o-1;S<C;){const A=i[S],v=A.data.length;if(v<Wr.epsilon)h&&(f[S]=0),d[++S]=m;else{const M=v*A.matrix.a,E=v*A.matrix.b,T=Math.sqrt(M*M+E*E);h&&(f[S]=T),d[++S]=(x?v+m:m)*T/v}}}const l=this.computeWorldPositions(t,o,c);let g=l[0],p=l[1],y=r.offsetRotation,w=!1;if(y==0)w=r.rotateMode==Ta.Chain;else{w=!1;const b=this.target.bone.matrix;y*=b.a*b.d-b.b*b.c>0?Z.degRad:-Z.degRad}for(let b=0,x=3;b<a;b++,x+=3){const S=i[b],C=S.matrix;C.tx+=(g-C.tx)*s,C.ty+=(p-C.ty)*n;const A=l[x],v=l[x+1],M=A-g,E=v-p;if(h){const T=f[b];if(T!=0){const R=(Math.sqrt(M*M+E*E)/T-1)*e+1;C.a*=R,C.b*=R}}if(g=A,p=v,e>0){const T=C.a,R=C.c,k=C.b,I=C.d;let P=0,F=0,X=0;if(c?P=l[x-1]:d[b+1]==0?P=l[x+2]:P=Math.atan2(E,M),P-=Math.atan2(k,T),w){F=Math.cos(P),X=Math.sin(P);const W=S.data.length;g+=(W*(F*T-X*k)-M)*e,p+=(W*(X*T+F*k)-E)*e}else P+=y;P>Z.PI?P-=Z.PI2:P<-Z.PI&&(P+=Z.PI2),P*=e,F=Math.cos(P),X=Math.sin(P),C.a=F*T-X*k,C.c=F*R-X*I,C.b=X*T+F*k,C.d=X*R+F*I}S.updateAppliedTransform()}}computeWorldPositions(t,e,s){const n=this.target;let r=this.position;const c=this.spaces,h=ct.setArraySize(this.positions,e*3+2);let i=this.world;const a=t.closed;let o=t.worldVerticesLength,d=o/6,f=Wr.NONE;if(!t.constantSpeed){const W=t.lengths;d-=a?1:2;const Y=W[d];this.data.positionMode==Er.Percent&&(r*=Y);let _;switch(this.data.spacingMode){case Ue.Percent:_=Y;break;case Ue.Proportional:_=Y/e;break;default:_=1}i=ct.setArraySize(this.world,8);for(let O=0,z=0,$=0;O<e;O++,z+=3){const N=c[O]*_;r+=N;let V=r;if(a)V%=Y,V<0&&(V+=Y),$=0;else if(V<0){f!=Wr.BEFORE&&(f=Wr.BEFORE,t.computeWorldVertices(n,2,4,i,0,2)),this.addBeforePosition(V,i,0,h,z);continue}else if(V>Y){f!=Wr.AFTER&&(f=Wr.AFTER,t.computeWorldVertices(n,o-6,4,i,0,2)),this.addAfterPosition(V-Y,i,0,h,z);continue}for(;;$++){const rt=W[$];if(!(V>rt)){if($==0)V/=rt;else{const gt=W[$-1];V=(V-gt)/(rt-gt)}break}}$!=f&&(f=$,a&&$==d?(t.computeWorldVertices(n,o-4,4,i,0,2),t.computeWorldVertices(n,0,4,i,4,2)):t.computeWorldVertices(n,$*6+2,8,i,0,2)),this.addCurvePosition(V,i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7],h,z,s||O>0&&N==0)}return h}a?(o+=2,i=ct.setArraySize(this.world,o),t.computeWorldVertices(n,2,o-4,i,0,2),t.computeWorldVertices(n,0,2,i,o-4,2),i[o-2]=i[0],i[o-1]=i[1]):(d--,o-=4,i=ct.setArraySize(this.world,o),t.computeWorldVertices(n,2,o,i,0,2));const m=ct.setArraySize(this.curves,d);let l=0,g=i[0],p=i[1],y=0,w=0,b=0,x=0,S=0,C=0,A=0,v=0,M=0,E=0,T=0,R=0,k=0,I=0;for(let W=0,Y=2;W<d;W++,Y+=6)y=i[Y],w=i[Y+1],b=i[Y+2],x=i[Y+3],S=i[Y+4],C=i[Y+5],A=(g-y*2+b)*.1875,v=(p-w*2+x)*.1875,M=((y-b)*3-g+S)*.09375,E=((w-x)*3-p+C)*.09375,T=A*2+M,R=v*2+E,k=(y-g)*.75+A+M*.16666667,I=(w-p)*.75+v+E*.16666667,l+=Math.sqrt(k*k+I*I),k+=T,I+=R,T+=M,R+=E,l+=Math.sqrt(k*k+I*I),k+=T,I+=R,l+=Math.sqrt(k*k+I*I),k+=T+M,I+=R+E,l+=Math.sqrt(k*k+I*I),m[W]=l,g=S,p=C;this.data.positionMode==Er.Percent&&(r*=l);let P;switch(this.data.spacingMode){case Ue.Percent:P=l;break;case Ue.Proportional:P=l/e;break;default:P=1}const F=this.segments;let X=0;for(let W=0,Y=0,_=0,O=0;W<e;W++,Y+=3){const z=c[W]*P;r+=z;let $=r;if(a)$%=l,$<0&&($+=l),_=0;else if($<0){this.addBeforePosition($,i,0,h,Y);continue}else if($>l){this.addAfterPosition($-l,i,o-4,h,Y);continue}for(;;_++){const N=m[_];if(!($>N)){if(_==0)$/=N;else{const V=m[_-1];$=($-V)/(N-V)}break}}if(_!=f){f=_;let N=_*6;for(g=i[N],p=i[N+1],y=i[N+2],w=i[N+3],b=i[N+4],x=i[N+5],S=i[N+6],C=i[N+7],A=(g-y*2+b)*.03,v=(p-w*2+x)*.03,M=((y-b)*3-g+S)*.006,E=((w-x)*3-p+C)*.006,T=A*2+M,R=v*2+E,k=(y-g)*.3+A+M*.16666667,I=(w-p)*.3+v+E*.16666667,X=Math.sqrt(k*k+I*I),F[0]=X,N=1;N<8;N++)k+=T,I+=R,T+=M,R+=E,X+=Math.sqrt(k*k+I*I),F[N]=X;k+=T,I+=R,X+=Math.sqrt(k*k+I*I),F[8]=X,k+=T+M,I+=R+E,X+=Math.sqrt(k*k+I*I),F[9]=X,O=0}for($*=X;;O++){const N=F[O];if(!($>N)){if(O==0)$/=N;else{const V=F[O-1];$=O+($-V)/(N-V)}break}}this.addCurvePosition($*.1,g,p,y,w,b,x,S,C,h,Y,s||W>0&&z==0)}return h}addBeforePosition(t,e,s,n,r){const c=e[s],h=e[s+1],i=e[s+2]-c,a=e[s+3]-h,o=Math.atan2(a,i);n[r]=c+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addAfterPosition(t,e,s,n,r){const c=e[s+2],h=e[s+3],i=c-e[s],a=h-e[s+1],o=Math.atan2(a,i);n[r]=c+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addCurvePosition(t,e,s,n,r,c,h,i,a,o,d,f){if(t==0||isNaN(t)){o[d]=e,o[d+1]=s,o[d+2]=Math.atan2(r-s,n-e);return}const m=t*t,l=m*t,g=1-t,p=g*g,y=p*g,w=g*t,b=w*3,x=g*b,S=b*t,C=e*y+n*x+c*S+i*l,A=s*y+r*x+h*S+a*l;o[d]=C,o[d+1]=A,f&&(t<.001?o[d+2]=Math.atan2(r-s,n-e):o[d+2]=Math.atan2(A-(s*p+r*w*2+h*m),C-(e*p+n*w*2+c*m)))}};Xe(vo,"NONE",-1),Xe(vo,"BEFORE",-2),Xe(vo,"AFTER",-3),Xe(vo,"epsilon",1e-5);let Lf=vo;var W1=Object.defineProperty,U1=(u,t,e)=>t in u?W1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ce=(u,t,e)=>U1(u,typeof t!="symbol"?t+"":t,e);let Hc=class{constructor(t,e,s){if(Ce(this,"matrix",new G.Matrix),Ce(this,"data"),Ce(this,"skeleton"),Ce(this,"parent",null),Ce(this,"children",new Array),Ce(this,"x",0),Ce(this,"y",0),Ce(this,"rotation",0),Ce(this,"scaleX",0),Ce(this,"scaleY",0),Ce(this,"shearX",0),Ce(this,"shearY",0),Ce(this,"ax",0),Ce(this,"ay",0),Ce(this,"arotation",0),Ce(this,"ascaleX",0),Ce(this,"ascaleY",0),Ce(this,"ashearX",0),Ce(this,"ashearY",0),Ce(this,"sorted",!1),Ce(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=s,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,s,n,r,c,h){this.ax=t,this.ay=e,this.arotation=s,this.ascaleX=n,this.ascaleY=r,this.ashearX=c,this.ashearY=h;const i=this.parent,a=this.matrix,o=this.skeleton.scaleX,d=-this.skeleton.scaleY;if(!i){const p=this.skeleton,y=s+90+h;a.a=Z.cosDeg(s+c)*n*o,a.c=Z.cosDeg(y)*r*o,a.b=Z.sinDeg(s+c)*n*d,a.d=Z.sinDeg(y)*r*d,a.tx=t*o+p.x,a.ty=e*d+p.y;return}let f=i.matrix.a,m=i.matrix.c,l=i.matrix.b,g=i.matrix.d;switch(a.tx=f*t+m*e+i.matrix.tx,a.ty=l*t+g*e+i.matrix.ty,this.data.transformMode){case on.Normal:{const p=s+90+h,y=Z.cosDeg(s+c)*n,w=Z.cosDeg(p)*r,b=Z.sinDeg(s+c)*n,x=Z.sinDeg(p)*r;a.a=f*y+m*b,a.c=f*w+m*x,a.b=l*y+g*b,a.d=l*w+g*x;return}case on.OnlyTranslation:{const p=s+90+h;a.a=Z.cosDeg(s+c)*n,a.c=Z.cosDeg(p)*r,a.b=Z.sinDeg(s+c)*n,a.d=Z.sinDeg(p)*r;break}case on.NoRotationOrReflection:{let p=f*f+l*l,y=0;p>1e-4?(p=Math.abs(f*g-m*l)/p,f/=o,l/=d,m=l*p,g=f*p,y=Math.atan2(l,f)*Z.radDeg):(f=0,l=0,y=90-Math.atan2(g,m)*Z.radDeg);const w=s+c-y,b=s+h-y+90,x=Z.cosDeg(w)*n,S=Z.cosDeg(b)*r,C=Z.sinDeg(w)*n,A=Z.sinDeg(b)*r;a.a=f*x-m*C,a.c=f*S-m*A,a.b=l*x+g*C,a.d=l*S+g*A;break}case on.NoScale:case on.NoScaleOrReflection:{const p=Z.cosDeg(s),y=Z.sinDeg(s);let w=(f*p+m*y)/o,b=(l*p+g*y)/d,x=Math.sqrt(w*w+b*b);x>1e-5&&(x=1/x),w*=x,b*=x,x=Math.sqrt(w*w+b*b),this.data.transformMode==on.NoScale&&f*g-m*l<0!=(o<0!=d<0)&&(x=-x);const S=Math.PI/2+Math.atan2(b,w),C=Math.cos(S)*x,A=Math.sin(S)*x,v=Z.cosDeg(c)*n,M=Z.cosDeg(90+h)*r,E=Z.sinDeg(c)*n,T=Z.sinDeg(90+h)*r;a.a=w*v+C*E,a.c=w*M+C*T,a.b=b*v+A*E,a.d=b*M+A*T;break}}a.a*=o,a.c*=o,a.b*=d,a.d*=d}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*Z.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*Z.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,e=this.matrix;if(!t){this.ax=e.tx-this.skeleton.x,this.ay=e.ty-this.skeleton.y,this.arotation=Math.atan2(e.b,e.a)*Z.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*Z.radDeg;return}const s=t.matrix,n=1/(s.a*s.d-s.b*s.c),r=e.tx-s.tx,c=e.ty-s.ty;this.ax=r*s.d*n-c*s.c*n,this.ay=c*s.a*n-r*s.b*n;const h=n*s.d,i=n*s.a,a=n*s.c,o=n*s.b,d=h*e.a-a*e.b,f=h*e.c-a*e.d,m=i*e.b-o*e.a,l=i*e.d-o*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(d*d+m*m),this.ascaleX>1e-4){const g=d*l-f*m;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(d*f+m*l,g)*Z.radDeg,this.arotation=Math.atan2(m,d)*Z.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(f*f+l*l),this.ashearY=0,this.arotation=90-Math.atan2(l,f)*Z.radDeg}worldToLocal(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,c=e.d,h=1/(s*c-n*r),i=t.x-e.tx,a=t.y-e.ty;return t.x=i*c*h-a*n*h,t.y=a*s*h-i*r*h,t}localToWorld(t){const e=this.matrix,s=t.x,n=t.y;return t.x=s*e.a+n*e.c+e.tx,t.y=s*e.b+n*e.d+e.ty,t}worldToLocalRotation(t){const e=Z.sinDeg(t),s=Z.cosDeg(t),n=this.matrix;return Math.atan2(n.a*e-n.b*s,n.d*s-n.c*e)*Z.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const e=Z.sinDeg(t),s=Z.cosDeg(t),n=this.matrix;return Math.atan2(s*n.b+e*n.d,s*n.a+e*n.c)*Z.radDeg}rotateWorld(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,c=e.d,h=Z.cosDeg(t),i=Z.sinDeg(t);e.a=h*s-i*r,e.c=h*n-i*c,e.b=i*s+h*r,e.d=i*n+h*c}};var q1=Object.defineProperty,G1=(u,t,e)=>t in u?q1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Tr=(u,t,e)=>G1(u,typeof t!="symbol"?t+"":t,e);let Of=class{constructor(t,e){if(Tr(this,"blendMode"),Tr(this,"data"),Tr(this,"bone"),Tr(this,"color"),Tr(this,"darkColor",null),Tr(this,"attachment",null),Tr(this,"attachmentState",0),Tr(this,"sequenceIndex",-1),Tr(this,"deform",new Array),!t)throw new Error("data cannot be null.");if(!e)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new kt,this.darkColor=t.darkColor?new kt:null,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&((!(t instanceof ar)||!(this.attachment instanceof ar)||t.timelineAttachment!=this.attachment.timelineAttachment)&&(this.deform.length=0),this.attachment=t,this.sequenceIndex=-1)}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName?(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName))):this.attachment=null}};var z1=Object.defineProperty,H1=(u,t,e)=>t in u?z1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ir=(u,t,e)=>H1(u,typeof t!="symbol"?t+"":t,e);let Wf=class{constructor(t,e){if(Ir(this,"data"),Ir(this,"bones"),Ir(this,"target"),Ir(this,"bendDirection",0),Ir(this,"compress",!1),Ir(this,"stretch",!1),Ir(this,"mix",1),Ir(this,"softness",0),Ir(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let n=0;n<t.bones.length;n++){const r=e.findBone(t.bones[n].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[n].name}`);this.bones.push(r)}const s=e.findBone(t.target.name);if(!s)throw new Error(`Couldn't find bone ${t.target.name}`);this.target=s}isActive(){return this.active}update(){if(this.mix==0)return;const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,e,s,n,r,c,h){const i=t.parent.matrix;if(!i)throw new Error("IK bone must have parent.");const a=i.a;let o=i.c;const d=i.b;let f=i.d,m=-t.ashearX-t.arotation,l=0,g=0;const p=t.skeleton.scaleX,y=-t.skeleton.scaleY;switch(t.data.transformMode){case on.OnlyTranslation:l=e-t.worldX,g=s-t.worldY,g=-g;break;case on.NoRotationOrReflection:const x=Math.abs(a*f-o*d)/(a*a+d*d),S=a/p,C=d/y;o=-C*x*p,f=S*x*y,m+=Math.atan2(C,S)*Z.radDeg;default:const A=e-i.tx,v=s-i.ty,M=a*f-o*d;l=(A*f-v*o)/M-t.ax,g=(v*a-A*d)/M-t.ay}m+=Math.atan2(g,l)*Z.radDeg,t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let w=t.ascaleX,b=t.ascaleY;if(n||r){switch(t.data.transformMode){case on.NoScale:case on.NoScaleOrReflection:l=e-t.worldX,g=s-t.worldY}const x=t.data.length*w,S=Math.sqrt(l*l+g*g);if(n&&S<x||r&&S>x&&x>1e-4){const C=(S/x-1)*h+1;w*=C,c&&(b*=C)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*h,w,b,t.ashearX,t.ashearY)}apply2(t,e,s,n,r,c,h,i,a){const o=t.ax,d=t.ay;let f=t.ascaleX,m=t.ascaleY,l=f,g=m,p=e.ascaleX;const y=t.matrix;let w=0,b=0,x=0;f<0?(f=-f,w=180,x=-1):(w=0,x=1),m<0&&(m=-m,x=-x),p<0?(p=-p,b=180):b=0;const S=e.ax;let C=0,A=0,v=0,M=y.a,E=y.c,T=y.b,R=y.d;const k=Math.abs(f-m)<=1e-4;!k||c?(C=0,A=M*S+y.tx,v=T*S+y.ty):(C=e.ay,A=M*S+E*C+y.tx,v=T*S+R*C+y.ty);const I=t.parent.matrix;if(!I)throw new Error("IK parent must itself have a parent.");M=I.a,E=I.c,T=I.b,R=I.d;const P=1/(M*R-E*T);let F=A-I.tx,X=v-I.ty;const W=(F*R-X*E)*P-o,Y=(X*M-F*T)*P-d,_=Math.sqrt(W*W+Y*Y);let O=e.data.length*p,z,$;if(_<1e-4){this.apply1(t,s,n,!1,c,!1,a),e.updateWorldTransformWith(S,C,0,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY);return}F=s-I.tx,X=n-I.ty;let N=(F*R-X*E)*P-o,V=(X*M-F*T)*P-d,rt=N*N+V*V;if(i!=0){i*=f*(p+1)*.5;const lt=Math.sqrt(rt),At=lt-_-O*f+i;if(At>0){let Ot=Math.min(1,At/(i*2))-1;Ot=(At-i*(1-Ot*Ot))/lt,N-=Ot*N,V-=Ot*V,rt=N*N+V*V}}t:if(k){O*=f;let lt=(rt-_*_-O*O)/(2*_*O);lt<-1?(lt=-1,$=Math.PI*r):lt>1?(lt=1,$=0,c&&(M=(Math.sqrt(rt)/(_+O)-1)*a+1,l*=M,h&&(g*=M))):$=Math.acos(lt)*r,M=_+O*lt,E=O*Math.sin($),z=Math.atan2(V*M-N*E,N*M+V*E)}else{M=f*O,E=m*O;const lt=M*M,At=E*E,Ot=Math.atan2(V,N);T=At*_*_+lt*rt-lt*At;const ie=-2*At*_,bs=At-lt;if(R=ie*ie-4*bs*T,R>=0){let Qt=Math.sqrt(R);ie<0&&(Qt=-Qt),Qt=-(ie+Qt)*.5;const $s=Qt/bs,xr=T/Qt,fn=Math.abs($s)<Math.abs(xr)?$s:xr;if(fn*fn<=rt){X=Math.sqrt(rt-fn*fn)*r,z=Ot-Math.atan2(X,fn),$=Math.atan2(X/m,(fn-_)/f);break t}}let xs=Z.PI,Le=_-M,ze=Le*Le,ws=0,ys=0,ae=_+M,Fe=ae*ae,He=0;T=-M*_/(lt-At),T>=-1&&T<=1&&(T=Math.acos(T),F=M*Math.cos(T)+_,X=E*Math.sin(T),R=F*F+X*X,R<ze&&(xs=T,ze=R,Le=F,ws=X),R>Fe&&(ys=T,Fe=R,ae=F,He=X)),rt<=(ze+Fe)*.5?(z=Ot-Math.atan2(ws*r,Le),$=xs*r):(z=Ot-Math.atan2(He*r,ae),$=ys*r)}const gt=Math.atan2(C,S)*x;let yt=t.arotation;z=(z-gt)*Z.radDeg+w-yt,z>180?z-=360:z<-180&&(z+=360),t.updateWorldTransformWith(o,d,yt+z*a,l,g,0,0),yt=e.arotation,$=(($+gt)*Z.radDeg-e.ashearX)*x+b-yt,$>180?$-=360:$<-180&&($+=360),e.updateWorldTransformWith(S,C,yt+$*a,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}};var K1=Object.defineProperty,Z1=(u,t,e)=>t in u?K1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Yn=(u,t,e)=>Z1(u,typeof t!="symbol"?t+"":t,e);let Uf=class{constructor(t,e){if(Yn(this,"data"),Yn(this,"bones"),Yn(this,"target"),Yn(this,"mixRotate",0),Yn(this,"mixX",0),Yn(this,"mixY",0),Yn(this,"mixScaleX",0),Yn(this,"mixScaleY",0),Yn(this,"mixShearY",0),Yn(this,"temp",new pc),Yn(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let n=0;n<t.bones.length;n++){const r=e.findBone(t.bones[n].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[n].name}.`);this.bones.push(r)}const s=e.findBone(t.target.name);if(!s)throw new Error(`Couldn't find target bone ${t.target.name}.`);this.target=s}isActive(){return this.active}update(){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleX==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,c=this.mixShearY,h=e!=0||s!=0,i=this.target,a=i.matrix,o=a.a,d=a.c,f=a.b,m=a.d,l=o*m-d*f>0?Z.degRad:-Z.degRad,g=this.data.offsetRotation*l,p=this.data.offsetShearY*l,y=this.bones;for(let w=0,b=y.length;w<b;w++){const x=y[w],S=x.matrix;if(t!=0){const C=S.a,A=S.c,v=S.b,M=S.d;let E=Math.atan2(f,o)-Math.atan2(v,C)+g;E>Z.PI?E-=Z.PI2:E<-Z.PI&&(E+=Z.PI2),E*=t;const T=Math.cos(E),R=Math.sin(E);S.a=T*C-R*v,S.c=T*A-R*M,S.b=R*C+T*v,S.d=R*A+T*M}if(h){const C=this.temp;i.localToWorld(C.set(this.data.offsetX,this.data.offsetY)),S.tx+=(C.x-S.tx)*e,S.ty+=(C.y-S.ty)*s}if(n!=0){let C=Math.sqrt(S.a*S.a+S.b*S.b);C!=0&&(C=(C+(Math.sqrt(o*o+f*f)-C+this.data.offsetScaleX)*n)/C),S.a*=C,S.b*=C}if(r!=0){let C=Math.sqrt(S.c*S.c+S.d*S.d);C!=0&&(C=(C+(Math.sqrt(d*d+m*m)-C+this.data.offsetScaleY)*r)/C),S.c*=C,S.d*=C}if(c>0){const C=S.c,A=S.d,v=Math.atan2(A,C);let M=Math.atan2(m,d)-Math.atan2(f,o)-(v-Math.atan2(S.b,S.a));M>Z.PI?M-=Z.PI2:M<-Z.PI&&(M+=Z.PI2),M=v+(M+p)*c;const E=Math.sqrt(C*C+A*A);S.c=Math.cos(M)*E,S.d=Math.sin(M)*E}x.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,c=this.mixShearY,h=e!=0||s!=0,i=this.target,a=i.matrix,o=a.a,d=a.c,f=a.b,m=a.d,l=o*m-d*f>0?Z.degRad:-Z.degRad,g=this.data.offsetRotation*l,p=this.data.offsetShearY*l,y=this.bones;for(let w=0,b=y.length;w<b;w++){const x=y[w],S=x.matrix;if(t!=0){const C=S.a,A=S.c,v=S.b,M=S.d;let E=Math.atan2(f,o)+g;E>Z.PI?E-=Z.PI2:E<-Z.PI&&(E+=Z.PI2),E*=t;const T=Math.cos(E),R=Math.sin(E);S.a=T*C-R*v,S.c=T*A-R*M,S.b=R*C+T*v,S.d=R*A+T*M}if(h){const C=this.temp;i.localToWorld(C.set(this.data.offsetX,this.data.offsetY)),S.tx+=C.x*e,S.ty+=C.y*s}if(n!=0){const C=(Math.sqrt(o*o+f*f)-1+this.data.offsetScaleX)*n+1;S.a*=C,S.b*=C}if(r!=0){const C=(Math.sqrt(d*d+m*m)-1+this.data.offsetScaleY)*r+1;S.c*=C,S.d*=C}if(c>0){let C=Math.atan2(m,d)-Math.atan2(f,o);C>Z.PI?C-=Z.PI2:C<-Z.PI&&(C+=Z.PI2);const A=S.c,v=S.d;C=Math.atan2(v,A)+(C-Z.PI/2+p)*c;const M=Math.sqrt(A*A+v*v);S.c=Math.cos(C)*M,S.d=Math.sin(C)*M}x.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,c=this.mixShearY,h=this.target,i=this.bones;for(let a=0,o=i.length;a<o;a++){const d=i[a];let f=d.arotation;if(t!=0){let w=h.arotation-f+this.data.offsetRotation;w-=(16384-(16384.499999999996-w/360|0))*360,f+=w*t}let m=d.ax,l=d.ay;m+=(h.ax-m+this.data.offsetX)*e,l+=(h.ay-l+this.data.offsetY)*s;let g=d.ascaleX,p=d.ascaleY;n!=0&&g!=0&&(g=(g+(h.ascaleX-g+this.data.offsetScaleX)*n)/g),r!=0&&p!=0&&(p=(p+(h.ascaleY-p+this.data.offsetScaleY)*r)/p);let y=d.ashearY;if(c!=0){let w=h.ashearY-y+this.data.offsetShearY;w-=(16384-(16384.499999999996-w/360|0))*360,y+=w*c}d.updateWorldTransformWith(m,l,f,g,p,d.ashearX,y)}}applyRelativeLocal(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,c=this.mixShearY,h=this.target,i=this.bones;for(let a=0,o=i.length;a<o;a++){const d=i[a],f=d.arotation+(h.arotation+this.data.offsetRotation)*t,m=d.ax+(h.ax+this.data.offsetX)*e,l=d.ay+(h.ay+this.data.offsetY)*s,g=d.ascaleX*((h.ascaleX-1+this.data.offsetScaleX)*n+1),p=d.ascaleY*((h.ascaleY-1+this.data.offsetScaleY)*r+1),y=d.ashearY+(h.ashearY+this.data.offsetShearY)*c;d.updateWorldTransformWith(m,l,f,g,p,d.ashearX,y)}}};var Q1=Object.defineProperty,J1=(u,t,e)=>t in u?Q1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ks=(u,t,e)=>J1(u,typeof t!="symbol"?t+"":t,e);const qf=class qo{constructor(t){if(ks(this,"data"),ks(this,"bones"),ks(this,"slots"),ks(this,"drawOrder"),ks(this,"ikConstraints"),ks(this,"transformConstraints"),ks(this,"pathConstraints"),ks(this,"_updateCache",new Array),ks(this,"skin",null),ks(this,"color"),ks(this,"scaleX",1),ks(this,"scaleY",1),ks(this,"x",0),ks(this,"y",0),!t)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const s=t.bones[e];let n;if(!s.parent)n=new Hc(s,this,null);else{const r=this.bones[s.parent.index];n=new Hc(s,this,r),r.children.push(n)}this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const s=t.slots[e],n=this.bones[s.boneData.index],r=new Of(s,n);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const s=t.ikConstraints[e];this.ikConstraints.push(new Wf(s,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const s=t.transformConstraints[e];this.transformConstraints.push(new Uf(s,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const s=t.pathConstraints[e];this.pathConstraints.push(new Lf(s,this))}this.color=new kt(1,1,1,1),this.updateCache()}updateCache(){const t=this._updateCache;t.length=0;const e=this.bones;for(let o=0,d=e.length;o<d;o++){const f=e[o];f.sorted=f.data.skinRequired,f.active=!f.sorted}if(this.skin){const o=this.skin.bones;for(let d=0,f=this.skin.bones.length;d<f;d++){let m=this.bones[o[d].index];do m.sorted=!1,m.active=!0,m=m.parent;while(m)}}const s=this.ikConstraints,n=this.transformConstraints,r=this.pathConstraints,c=s.length,h=n.length,i=r.length,a=c+h+i;t:for(let o=0;o<a;o++){for(let d=0;d<c;d++){const f=s[d];if(f.data.order==o){this.sortIkConstraint(f);continue t}}for(let d=0;d<h;d++){const f=n[d];if(f.data.order==o){this.sortTransformConstraint(f);continue t}}for(let d=0;d<i;d++){const f=r[d];if(f.data.order==o){this.sortPathConstraint(f);continue t}}}for(let o=0,d=e.length;o<d;o++)this.sortBone(e[o])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&ct.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target;this.sortBone(e);const s=t.bones,n=s[0];if(this.sortBone(n),s.length==1)this._updateCache.push(t),this.sortReset(n.children);else{const r=s[s.length-1];this.sortBone(r),this._updateCache.push(t),this.sortReset(n.children),r.sorted=!0}}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||this.skin&&ct.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target,s=e.data.index,n=e.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,s,n),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,n);for(let i=0,a=this.data.skins.length;i<a;i++)this.sortPathConstraintAttachment(this.data.skins[i],s,n);const r=e.getAttachment();r instanceof Co&&this.sortPathConstraintAttachmentWith(r,n);const c=t.bones,h=c.length;for(let i=0;i<h;i++)this.sortBone(c[i]);this._updateCache.push(t);for(let i=0;i<h;i++)this.sortReset(c[i].children);for(let i=0;i<h;i++)c[i].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&ct.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);const e=t.bones,s=e.length;if(t.data.local)for(let n=0;n<s;n++){const r=e[n];this.sortBone(r.parent),this.sortBone(r)}else for(let n=0;n<s;n++)this.sortBone(e[n]);this._updateCache.push(t);for(let n=0;n<s;n++)this.sortReset(e[n].children);for(let n=0;n<s;n++)e[n].sorted=!0}sortPathConstraintAttachment(t,e,s){const n=t.attachments[e];if(n)for(const r in n)this.sortPathConstraintAttachmentWith(n[r],s)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof Co))return;const s=t.bones;if(!s)this.sortBone(e);else{const n=this.bones;for(let r=0,c=s.length;r<c;){let h=s[r++];for(h+=r;r<h;)this.sortBone(n[s[r++]])}}}sortBone(t){if(!t||t.sorted)return;const e=t.parent;e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,s=t.length;e<s;e++){const n=t[e];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(){const t=this.bones;for(let s=0,n=t.length;s<n;s++){const r=t[s];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY}const e=this._updateCache;for(let s=0,n=e.length;s<n;s++)e[s].update()}updateWorldTransformWith(t){const e=this.getRootBone(),s=t.matrix.a,n=t.matrix.c,r=t.matrix.b,c=t.matrix.d;e.matrix.tx=s*this.x+n*this.y+t.worldX,e.matrix.ty=r*this.x+c*this.y+t.worldY;const h=e.rotation+90+e.shearY,i=Z.cosDeg(e.rotation+e.shearX)*e.scaleX,a=Z.cosDeg(h)*e.scaleY,o=Z.sinDeg(e.rotation+e.shearX)*e.scaleX,d=Z.sinDeg(h)*e.scaleY,f=this.scaleX,m=-this.scaleY;e.matrix.a=(s*i+n*o)*f,e.matrix.c=(s*a+n*d)*f,e.matrix.b=(r*i+c*o)*m,e.matrix.d=(r*a+c*d)*m;const l=this._updateCache;for(let g=0,p=l.length;g<p;g++){const y=l[g];y!=e&&y.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let r=0,c=t.length;r<c;r++)t[r].setToSetupPose();const e=this.ikConstraints;for(let r=0,c=e.length;r<c;r++){const h=e[r];h.mix=h.data.mix,h.softness=h.data.softness,h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch}const s=this.transformConstraints;for(let r=0,c=s.length;r<c;r++){const h=s[r],i=h.data;h.mixRotate=i.mixRotate,h.mixX=i.mixX,h.mixY=i.mixY,h.mixScaleX=i.mixScaleX,h.mixScaleY=i.mixScaleY,h.mixShearY=i.mixShearY}const n=this.pathConstraints;for(let r=0,c=n.length;r<c;r++){const h=n[r],i=h.data;h.position=i.position,h.spacing=i.spacing,h.mixRotate=i.mixRotate,h.mixX=i.mixX,h.mixY=i.mixY}}setSlotsToSetupPose(){const t=this.slots;ct.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,s=t.length;e<s;e++)t[e].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(!e)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(t)if(this.skin)t.attachAll(this,this.skin);else{const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s],c=r.data.attachmentName;if(c){const h=t.getAttachment(s,c);h&&r.setAttachment(h)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){const s=this.data.findSlot(t);if(!s)throw new Error(`Can't find slot with name ${t}`);return this.getAttachment(s.index,e)}getAttachment(t,e){if(!e)throw new Error("attachmentName cannot be null.");if(this.skin){const s=this.skin.getAttachment(t,e);if(s)return s}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(!t)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,r=s.length;n<r;n++){const c=s[n];if(c.data.name==t){let h=null;if(e&&(h=this.getAttachment(n,e),!h))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);c.setAttachment(h);return}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}getBoundsRect(){const t=new pc,e=new pc;return this.getBounds(t,e),{x:t.x,y:t.y,width:e.x,height:e.y}}getBounds(t,e,s=new Array(2)){if(!t)throw new Error("offset cannot be null.");if(!e)throw new Error("size cannot be null.");const n=this.drawOrder;let r=Number.POSITIVE_INFINITY,c=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY,i=Number.NEGATIVE_INFINITY;for(let a=0,o=n.length;a<o;a++){const d=n[a];if(!d.bone.active)continue;let f=0,m=null;const l=d.getAttachment();if(l instanceof xc)f=8,m=ct.setArraySize(s,f,0),l.computeWorldVertices(d,m,0,2);else if(l instanceof hl){const g=l;f=g.worldVerticesLength,m=ct.setArraySize(s,f,0),g.computeWorldVertices(d,0,f,m,0,2)}if(m)for(let g=0,p=m.length;g<p;g+=2){const y=m[g],w=m[g+1];r=Math.min(r,y),c=Math.min(c,w),h=Math.max(h,y),i=Math.max(i,w)}}t.set(r,c),e.set(h-r,i-c)}get flipX(){return this.scaleX==-1}set flipX(t){qo.deprecatedWarning1||(qo.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return this.scaleY==-1}set flipY(t){qo.deprecatedWarning1||(qo.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};ks(qf,"deprecatedWarning1",!1);let Gf=qf;var j1=Object.defineProperty,tw=(u,t,e)=>t in u?j1(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,na=(u,t,e)=>tw(u,typeof t!="symbol"?t+"":t,e);let Kc=class{constructor(t,e){if(na(this,"data"),na(this,"intValue",0),na(this,"floatValue",0),na(this,"stringValue",null),na(this,"time",0),na(this,"volume",0),na(this,"balance",0),!e)throw new Error("data cannot be null.");this.time=t,this.data=e}};var ew=Object.defineProperty,sw=(u,t,e)=>t in u?ew(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Be=(u,t,e)=>sw(u,typeof t!="symbol"?t+"":t,e);let Zc=class{constructor(){Be(this,"name",null),Be(this,"bones",new Array),Be(this,"slots",new Array),Be(this,"skins",new Array),Be(this,"defaultSkin",null),Be(this,"events",new Array),Be(this,"animations",new Array),Be(this,"ikConstraints",new Array),Be(this,"transformConstraints",new Array),Be(this,"pathConstraints",new Array),Be(this,"x",0),Be(this,"y",0),Be(this,"width",0),Be(this,"height",0),Be(this,"version",null),Be(this,"hash",null),Be(this,"fps",0),Be(this,"imagesPath",null),Be(this,"audioPath",null)}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const e=this.skins;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const e=this.events;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const e=this.animations;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}};var nw=Object.defineProperty,rw=(u,t,e)=>t in u?nw(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ra=(u,t,e)=>rw(u,typeof t!="symbol"?t+"":t,e);let Qc=class{constructor(t,e,s){if(ra(this,"index",0),ra(this,"name"),ra(this,"boneData"),ra(this,"color",new kt(1,1,1,1)),ra(this,"darkColor",null),ra(this,"attachmentName",null),ra(this,"blendMode",G.BLEND_MODES.NORMAL),t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");if(!s)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=s}};var iw=Object.defineProperty,aw=(u,t,e)=>t in u?iw(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ks=(u,t,e)=>aw(u,typeof t!="symbol"?t+"":t,e);let Jc=class{constructor(t,e,s){if(Ks(this,"index",0),Ks(this,"name"),Ks(this,"parent",null),Ks(this,"length",0),Ks(this,"x",0),Ks(this,"y",0),Ks(this,"rotation",0),Ks(this,"scaleX",1),Ks(this,"scaleY",1),Ks(this,"shearX",0),Ks(this,"shearY",0),Ks(this,"transformMode",on.Normal),Ks(this,"skinRequired",!1),Ks(this,"color",new kt),t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=s}};var ow=Object.defineProperty,lw=(u,t,e)=>t in u?ow(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ai=(u,t,e)=>lw(u,typeof t!="symbol"?t+"":t,e);let jc=class extends dl{constructor(t){super(t,0,!1),ai(this,"bones",new Array),ai(this,"_target",null),ai(this,"bendDirection",1),ai(this,"compress",!1),ai(this,"stretch",!1),ai(this,"uniform",!1),ai(this,"mix",1),ai(this,"softness",0)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}};var cw=Object.defineProperty,hw=(u,t,e)=>t in u?cw(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ms=(u,t,e)=>hw(u,typeof t!="symbol"?t+"":t,e);let th=class extends dl{constructor(t){super(t,0,!1),Ms(this,"bones",new Array),Ms(this,"_target",null),Ms(this,"mixRotate",0),Ms(this,"mixX",0),Ms(this,"mixY",0),Ms(this,"mixScaleX",0),Ms(this,"mixScaleY",0),Ms(this,"mixShearY",0),Ms(this,"offsetRotation",0),Ms(this,"offsetX",0),Ms(this,"offsetY",0),Ms(this,"offsetScaleX",0),Ms(this,"offsetScaleY",0),Ms(this,"offsetShearY",0),Ms(this,"relative",!1),Ms(this,"local",!1)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}};var dw=Object.defineProperty,uw=(u,t,e)=>t in u?dw(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ul=(u,t,e)=>uw(u,typeof t!="symbol"?t+"":t,e);let eh=class{constructor(t,e,s){this.slotIndex=t,this.name=e,this.attachment=s}},fl=class{constructor(t){if(ul(this,"name"),ul(this,"attachments",new Array),ul(this,"bones",Array()),ul(this,"constraints",new Array),!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,e,s){if(!s)throw new Error("attachment cannot be null.");const n=this.attachments;t>=n.length&&(n.length=t+1),n[t]||(n[t]={}),n[t][e]=s}addSkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];this.setAttachment(n.slotIndex,n.name,n.attachment)}}copySkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];n.attachment&&(n.attachment instanceof hl?(n.attachment=n.attachment.newLinkedMesh(),this.setAttachment(n.slotIndex,n.name,n.attachment)):(n.attachment=n.attachment.copy(),this.setAttachment(n.slotIndex,n.name,n.attachment)))}}getAttachment(t,e){const s=this.attachments[t];return s?s[e]:null}removeAttachment(t,e){const s=this.attachments[t];s&&delete s[e]}getAttachments(){const t=new Array;for(let e=0;e<this.attachments.length;e++){const s=this.attachments[e];if(s)for(const n in s){const r=s[n];r&&t.push(new eh(e,n,r))}}return t}getAttachmentsForSlot(t,e){const s=this.attachments[t];if(s)for(const n in s){const r=s[n];r&&e.push(new eh(t,n,r))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,e){let s=0;for(let n=0;n<t.slots.length;n++){const r=t.slots[n],c=r.getAttachment();if(c&&s<e.attachments.length){const h=e.attachments[s];for(const i in h){const a=h[i];if(c==a){const o=this.getAttachment(s,i);o&&r.setAttachment(o);break}}}s++}}};var fw=Object.defineProperty,mw=(u,t,e)=>t in u?fw(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ia=(u,t,e)=>mw(u,typeof t!="symbol"?t+"":t,e);let sh=class{constructor(t){ia(this,"name"),ia(this,"intValue",0),ia(this,"floatValue",0),ia(this,"stringValue",null),ia(this,"audioPath",null),ia(this,"volume",0),ia(this,"balance",0),this.name=t}},gw=class{constructor(t,e=new Array,s=0,n=new DataView(t.buffer)){this.strings=e,this.index=s,this.buffer=n}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),s=e&127;return e&128&&(e=this.readByte(),s|=(e&127)<<7,e&128&&(e=this.readByte(),s|=(e&127)<<14,e&128&&(e=this.readByte(),s|=(e&127)<<21,e&128&&(e=this.readByte(),s|=(e&127)<<28)))),t?s:s>>>1^-(s&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let s=0;s<t;){const n=this.readUnsignedByte();switch(n>>4){case 12:case 13:e+=String.fromCharCode((n&31)<<6|this.readByte()&63),s+=2;break;case 14:e+=String.fromCharCode((n&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),s+=3;break;default:e+=String.fromCharCode(n),s++}}return e}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}};var pw=Object.defineProperty,bw=(u,t,e)=>t in u?pw(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,lr=(u,t,e)=>bw(u,typeof t!="symbol"?t+"":t,e);let nh=class{constructor(t){lr(this,"ver40",!1),lr(this,"scale",1),lr(this,"attachmentLoader"),lr(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new Zc;s.name="";const n=new gw(t),r=n.readInt32(),c=n.readInt32();s.hash=c==0&&r==0?null:c.toString(16)+r.toString(16),s.version=n.readString();const h=s.version.substr(0,3);if(h!=="4.0"&&h!=="4.1"){const d=`Spine 4.1 loader cant load version ${s.version}. Please configure your pixi-spine bundle`;console.error(d)}this.ver40=h==="4.0",s.x=n.readFloat(),s.y=n.readFloat(),s.width=n.readFloat(),s.height=n.readFloat();const i=n.readBoolean();i&&(s.fps=n.readFloat(),s.imagesPath=n.readString(),s.audioPath=n.readString());let a=0;a=n.readInt(!0);for(let d=0;d<a;d++){const f=n.readString();if(!f)throw new Error("String in string table must not be null.");n.strings.push(f)}a=n.readInt(!0);for(let d=0;d<a;d++){const f=n.readString();if(!f)throw new Error("Bone name must not be null.");const m=d==0?null:s.bones[n.readInt(!0)],l=new Jc(d,f,m);l.rotation=n.readFloat(),l.x=n.readFloat()*e,l.y=n.readFloat()*e,l.scaleX=n.readFloat(),l.scaleY=n.readFloat(),l.shearX=n.readFloat(),l.shearY=n.readFloat(),l.length=n.readFloat()*e,l.transformMode=n.readInt(!0),l.skinRequired=n.readBoolean(),i&&kt.rgba8888ToColor(l.color,n.readInt32()),s.bones.push(l)}a=n.readInt(!0);for(let d=0;d<a;d++){const f=n.readString();if(!f)throw new Error("Slot name must not be null.");const m=s.bones[n.readInt(!0)],l=new Qc(d,f,m);kt.rgba8888ToColor(l.color,n.readInt32());const g=n.readInt32();g!=-1&&kt.rgb888ToColor(l.darkColor=new kt,g),l.attachmentName=n.readStringRef(),l.blendMode=n.readInt(!0),s.slots.push(l)}a=n.readInt(!0);for(let d=0,f;d<a;d++){const m=n.readString();if(!m)throw new Error("IK constraint data name must not be null.");const l=new jc(m);l.order=n.readInt(!0),l.skinRequired=n.readBoolean(),f=n.readInt(!0);for(let g=0;g<f;g++)l.bones.push(s.bones[n.readInt(!0)]);l.target=s.bones[n.readInt(!0)],l.mix=n.readFloat(),l.softness=n.readFloat()*e,l.bendDirection=n.readByte(),l.compress=n.readBoolean(),l.stretch=n.readBoolean(),l.uniform=n.readBoolean(),s.ikConstraints.push(l)}a=n.readInt(!0);for(let d=0,f;d<a;d++){const m=n.readString();if(!m)throw new Error("Transform constraint data name must not be null.");const l=new th(m);l.order=n.readInt(!0),l.skinRequired=n.readBoolean(),f=n.readInt(!0);for(let g=0;g<f;g++)l.bones.push(s.bones[n.readInt(!0)]);l.target=s.bones[n.readInt(!0)],l.local=n.readBoolean(),l.relative=n.readBoolean(),l.offsetRotation=n.readFloat(),l.offsetX=n.readFloat()*e,l.offsetY=n.readFloat()*e,l.offsetScaleX=n.readFloat(),l.offsetScaleY=n.readFloat(),l.offsetShearY=n.readFloat(),l.mixRotate=n.readFloat(),l.mixX=n.readFloat(),l.mixY=n.readFloat(),l.mixScaleX=n.readFloat(),l.mixScaleY=n.readFloat(),l.mixShearY=n.readFloat(),s.transformConstraints.push(l)}a=n.readInt(!0);for(let d=0,f;d<a;d++){const m=n.readString();if(!m)throw new Error("Path constraint data name must not be null.");const l=new zc(m);l.order=n.readInt(!0),l.skinRequired=n.readBoolean(),f=n.readInt(!0);for(let g=0;g<f;g++)l.bones.push(s.bones[n.readInt(!0)]);l.target=s.slots[n.readInt(!0)],l.positionMode=n.readInt(!0),l.spacingMode=n.readInt(!0),l.rotateMode=n.readInt(!0),l.offsetRotation=n.readFloat(),l.position=n.readFloat(),l.positionMode==Er.Fixed&&(l.position*=e),l.spacing=n.readFloat(),(l.spacingMode==Ue.Length||l.spacingMode==Ue.Fixed)&&(l.spacing*=e),l.mixRotate=n.readFloat(),l.mixX=n.readFloat(),l.mixY=n.readFloat(),s.pathConstraints.push(l)}const o=this.readSkin(n,s,!0,i);o&&(s.defaultSkin=o,s.skins.push(o));{let d=s.skins.length;for(ct.setArraySize(s.skins,a=d+n.readInt(!0));d<a;d++){const f=this.readSkin(n,s,!1,i);if(!f)throw new Error("readSkin() should not have returned null.");s.skins[d]=f}}a=this.linkedMeshes.length;for(let d=0;d<a;d++){const f=this.linkedMeshes[d],m=f.skin?s.findSkin(f.skin):s.defaultSkin;if(!m)throw new Error("Not skin found for linked mesh.");if(!f.parent)throw new Error("Linked mesh parent must not be null");const l=m.getAttachment(f.slotIndex,f.parent);if(!l)throw new Error(`Parent mesh not found: ${f.parent}`);f.mesh.timelineAttachment=f.inheritTimeline?l:f.mesh,f.mesh.setParentMesh(l)}this.linkedMeshes.length=0,a=n.readInt(!0);for(let d=0;d<a;d++){const f=n.readStringRef();if(!f)throw new Error;const m=new sh(f);m.intValue=n.readInt(!1),m.floatValue=n.readFloat(),m.stringValue=n.readString(),m.audioPath=n.readString(),m.audioPath&&(m.volume=n.readFloat(),m.balance=n.readFloat()),s.events.push(m)}a=n.readInt(!0);for(let d=0;d<a;d++){const f=n.readString();if(!f)throw new Error("Animatio name must not be null.");s.animations.push(this.readAnimation(n,f,s))}return s}readSkin(t,e,s,n){let r=null,c=0;if(s){if(c=t.readInt(!0),c==0)return null;r=new fl("default")}else{const h=t.readStringRef();if(!h)throw new Error("Skin name must not be null.");r=new fl(h),r.bones.length=t.readInt(!0);for(let i=0,a=r.bones.length;i<a;i++)r.bones[i]=e.bones[t.readInt(!0)];for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.ikConstraints[t.readInt(!0)]);for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.transformConstraints[t.readInt(!0)]);for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.pathConstraints[t.readInt(!0)]);c=t.readInt(!0)}for(let h=0;h<c;h++){const i=t.readInt(!0);for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readStringRef();if(!d)throw new Error("Attachment name must not be null");const f=this.readAttachment(t,e,r,i,d,n);f&&r.setAttachment(i,d,f)}}return r}readAttachment(t,e,s,n,r,c){const h=this.scale;let i=t.readStringRef();switch(i||(i=r),t.readByte()){case Se.Region:{let a=t.readStringRef();const o=t.readFloat(),d=t.readFloat(),f=t.readFloat(),m=t.readFloat(),l=t.readFloat(),g=t.readFloat(),p=t.readFloat(),y=t.readInt32(),w=this.readSequence(t);a||(a=i);const b=this.attachmentLoader.newRegionAttachment(s,i,a,w);return b?(b.path=a,b.x=d*h,b.y=f*h,b.scaleX=m,b.scaleY=l,b.rotation=o,b.width=g*h,b.height=p*h,kt.rgba8888ToColor(b.color,y),b.sequence=w,w==null&&b.updateRegion(),b):null}case Se.BoundingBox:{const a=t.readInt(!0),o=this.readVertices(t,a),d=c?t.readInt32():0,f=this.attachmentLoader.newBoundingBoxAttachment(s,i);return f?(f.worldVerticesLength=a<<1,f.vertices=o.vertices,f.bones=o.bones,c&&kt.rgba8888ToColor(f.color,d),f):null}case Se.Mesh:{let a=t.readStringRef();const o=t.readInt32(),d=t.readInt(!0),f=this.readFloatArray(t,d<<1,1),m=this.readShortArray(t),l=this.readVertices(t,d),g=t.readInt(!0),p=this.readSequence(t);let y=[],w=0,b=0;c&&(y=this.readShortArray(t),w=t.readFloat(),b=t.readFloat()),a||(a=i);const x=this.attachmentLoader.newMeshAttachment(s,i,a,p);return x?(x.path=a,kt.rgba8888ToColor(x.color,o),x.bones=l.bones,x.vertices=l.vertices,x.worldVerticesLength=d<<1,x.triangles=m,x.regionUVs=new Float32Array(f),x.hullLength=g<<1,x.sequence=p,c&&(x.edges=y,x.width=w*h,x.height=b*h),x):null}case Se.LinkedMesh:{let a=t.readStringRef();const o=t.readInt32(),d=t.readStringRef(),f=t.readStringRef(),m=t.readBoolean(),l=this.readSequence(t);let g=0,p=0;c&&(g=t.readFloat(),p=t.readFloat()),a||(a=i);const y=this.attachmentLoader.newMeshAttachment(s,i,a,l);return y?(y.path=a,kt.rgba8888ToColor(y.color,o),y.sequence=l,c&&(y.width=g*h,y.height=p*h),this.linkedMeshes.push(new xw(y,d,n,f,m)),y):null}case Se.Path:{const a=t.readBoolean(),o=t.readBoolean(),d=t.readInt(!0),f=this.readVertices(t,d),m=ct.newArray(d/3,0);for(let p=0,y=m.length;p<y;p++)m[p]=t.readFloat()*h;const l=c?t.readInt32():0,g=this.attachmentLoader.newPathAttachment(s,i);return g?(g.closed=a,g.constantSpeed=o,g.worldVerticesLength=d<<1,g.vertices=f.vertices,g.bones=f.bones,g.lengths=m,c&&kt.rgba8888ToColor(g.color,l),g):null}case Se.Point:{const a=t.readFloat(),o=t.readFloat(),d=t.readFloat(),f=c?t.readInt32():0,m=this.attachmentLoader.newPointAttachment(s,i);return m?(m.x=o*h,m.y=d*h,m.rotation=a,c&&kt.rgba8888ToColor(m.color,f),m):null}case Se.Clipping:{const a=t.readInt(!0),o=t.readInt(!0),d=this.readVertices(t,o),f=c?t.readInt32():0,m=this.attachmentLoader.newClippingAttachment(s,i);return m?(m.endSlot=e.slots[a],m.worldVerticesLength=o<<1,m.vertices=d.vertices,m.bones=d.bones,c&&kt.rgba8888ToColor(m.color,f),m):null}}return null}readSequence(t){if(this.ver40||!t.readBoolean())return null;const e=new wc(t.readInt(!0));return e.start=t.readInt(!0),e.digits=t.readInt(!0),e.setupIndex=t.readInt(!0),e}readDeformTimelineType(t){return this.ver40?zf:t.readByte()}readVertices(t,e){const s=this.scale,n=e<<1,r=new ww;if(!t.readBoolean())return r.vertices=this.readFloatArray(t,n,s),r;const c=new Array,h=new Array;for(let i=0;i<e;i++){const a=t.readInt(!0);h.push(a);for(let o=0;o<a;o++)h.push(t.readInt(!0)),c.push(t.readFloat()*s),c.push(t.readFloat()*s),c.push(t.readFloat())}return r.vertices=ct.toFloatArray(c),r.bones=h,r}readFloatArray(t,e,s){const n=new Array(e);if(s==1)for(let r=0;r<e;r++)n[r]=t.readFloat();else for(let r=0;r<e;r++)n[r]=t.readFloat()*s;return n}readShortArray(t){const e=t.readInt(!0),s=new Array(e);for(let n=0;n<e;n++)s[n]=t.readShort();return s}readAnimation(t,e,s){t.readInt(!0);const n=new Array,r=this.scale;for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0);for(let f=0,m=t.readInt(!0);f<m;f++){const l=t.readByte(),g=t.readInt(!0),p=g-1;switch(l){case Pw:{const y=new sa(g,d);for(let w=0;w<g;w++)y.setFrame(w,t.readFloat(),t.readStringRef());n.push(y);break}case kw:{const y=t.readInt(!0),w=new Pc(g,y,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255;for(let v=0,M=0;w.setFrame(v,b,x,S,C,A),v!=p;v++){const E=t.readFloat(),T=t.readUnsignedByte()/255,R=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255;switch(t.readByte()){case $n:w.setStepped(v);break;case _n:Yt(t,w,M++,v,0,b,E,x,T,1),Yt(t,w,M++,v,1,b,E,S,R,1),Yt(t,w,M++,v,2,b,E,C,k,1),Yt(t,w,M++,v,3,b,E,A,I,1)}b=E,x=T,S=R,C=k,A=I}n.push(w);break}case Fw:{const y=t.readInt(!0),w=new kc(g,y,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255;for(let A=0,v=0;w.setFrame(A,b,x,S,C),A!=p;A++){const M=t.readFloat(),E=t.readUnsignedByte()/255,T=t.readUnsignedByte()/255,R=t.readUnsignedByte()/255;switch(t.readByte()){case $n:w.setStepped(A);break;case _n:Yt(t,w,v++,A,0,b,M,x,E,1),Yt(t,w,v++,A,1,b,M,S,T,1),Yt(t,w,v++,A,2,b,M,C,R,1)}b=M,x=E,S=T,C=R}n.push(w);break}case Yw:{const y=t.readInt(!0),w=new Yc(g,y,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255,E=t.readUnsignedByte()/255;for(let T=0,R=0;w.setFrame(T,b,x,S,C,A,v,M,E),T!=p;T++){const k=t.readFloat(),I=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,W=t.readUnsignedByte()/255,Y=t.readUnsignedByte()/255,_=t.readUnsignedByte()/255;switch(t.readByte()){case $n:w.setStepped(T);break;case _n:Yt(t,w,R++,T,0,b,k,x,I,1),Yt(t,w,R++,T,1,b,k,S,P,1),Yt(t,w,R++,T,2,b,k,C,F,1),Yt(t,w,R++,T,3,b,k,A,X,1),Yt(t,w,R++,T,4,b,k,v,W,1),Yt(t,w,R++,T,5,b,k,M,Y,1),Yt(t,w,R++,T,6,b,k,E,_,1)}b=k,x=I,S=P,C=F,A=X,v=W,M=Y,E=_}n.push(w);break}case $w:{const y=t.readInt(!0),w=new $c(g,y,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255;for(let E=0,T=0;w.setFrame(E,b,x,S,C,A,v,M),E!=p;E++){const R=t.readFloat(),k=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,W=t.readUnsignedByte()/255;switch(t.readByte()){case $n:w.setStepped(E);break;case _n:Yt(t,w,T++,E,0,b,R,x,k,1),Yt(t,w,T++,E,1,b,R,S,I,1),Yt(t,w,T++,E,2,b,R,C,P,1),Yt(t,w,T++,E,3,b,R,A,F,1),Yt(t,w,T++,E,4,b,R,v,X,1),Yt(t,w,T++,E,5,b,R,M,W,1)}b=R,x=k,S=I,C=P,A=F,v=X,M=W}n.push(w);break}case _w:{const y=new Fc(g,t.readInt(!0),d);let w=t.readFloat(),b=t.readUnsignedByte()/255;for(let x=0,S=0;y.setFrame(x,w,b),x!=p;x++){const C=t.readFloat(),A=t.readUnsignedByte()/255;switch(t.readByte()){case $n:y.setStepped(x);break;case _n:Yt(t,y,S++,x,0,w,C,b,A,1)}w=C,b=A}n.push(y)}}}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0);for(let f=0,m=t.readInt(!0);f<m;f++){const l=t.readByte(),g=t.readInt(!0),p=t.readInt(!0);switch(l){case yw:n.push(Rr(t,new wo(g,p,d),1));break;case Sw:n.push(rh(t,new Sc(g,p,d),r));break;case Cw:n.push(Rr(t,new Cc(g,p,d),r));break;case Aw:n.push(Rr(t,new Ac(g,p,d),r));break;case vw:n.push(rh(t,new vc(g,p,d),1));break;case Mw:n.push(Rr(t,new Mc(g,p,d),1));break;case Ew:n.push(Rr(t,new Ec(g,p,d),1));break;case Tw:n.push(rh(t,new Tc(g,p,d),1));break;case Iw:n.push(Rr(t,new Ic(g,p,d),1));break;case Rw:n.push(Rr(t,new Rc(g,p,d),1))}}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),f=t.readInt(!0),m=f-1,l=new Xc(f,t.readInt(!0),d);let g=t.readFloat(),p=t.readFloat(),y=t.readFloat()*r;for(let w=0,b=0;l.setFrame(w,g,p,y,t.readByte(),t.readBoolean(),t.readBoolean()),w!=m;w++){const x=t.readFloat(),S=t.readFloat(),C=t.readFloat()*r;switch(t.readByte()){case $n:l.setStepped(w);break;case _n:Yt(t,l,b++,w,0,g,x,p,S,1),Yt(t,l,b++,w,1,g,x,y,C,r)}g=x,p=S,y=C}n.push(l)}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),f=t.readInt(!0),m=f-1,l=new Bc(f,t.readInt(!0),d);let g=t.readFloat(),p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),b=t.readFloat(),x=t.readFloat(),S=t.readFloat();for(let C=0,A=0;l.setFrame(C,g,p,y,w,b,x,S),C!=m;C++){const v=t.readFloat(),M=t.readFloat(),E=t.readFloat(),T=t.readFloat(),R=t.readFloat(),k=t.readFloat(),I=t.readFloat();switch(t.readByte()){case $n:l.setStepped(C);break;case _n:Yt(t,l,A++,C,0,g,v,p,M,1),Yt(t,l,A++,C,1,g,v,y,E,1),Yt(t,l,A++,C,2,g,v,w,T,1),Yt(t,l,A++,C,3,g,v,b,R,1),Yt(t,l,A++,C,4,g,v,x,k,1),Yt(t,l,A++,C,5,g,v,S,I,1)}g=v,p=M,y=E,w=T,b=R,x=k,S=I}n.push(l)}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),f=s.pathConstraints[d];for(let m=0,l=t.readInt(!0);m<l;m++)switch(t.readByte()){case Bw:n.push(Rr(t,new Vc(t.readInt(!0),t.readInt(!0),d),f.positionMode==Er.Fixed?r:1));break;case Vw:n.push(Rr(t,new Nc(t.readInt(!0),t.readInt(!0),d),f.spacingMode==Ue.Length||f.spacingMode==Ue.Fixed?r:1));break;case Nw:const g=new Dc(t.readInt(!0),t.readInt(!0),d);let p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),b=t.readFloat();for(let x=0,S=0,C=g.getFrameCount()-1;g.setFrame(x,p,y,w,b),x!=C;x++){const A=t.readFloat(),v=t.readFloat(),M=t.readFloat(),E=t.readFloat();switch(t.readByte()){case $n:g.setStepped(x);break;case _n:Yt(t,g,S++,x,0,p,A,y,v,1),Yt(t,g,S++,x,1,p,A,w,M,1),Yt(t,g,S++,x,2,p,A,b,E,1)}p=A,y=v,w=M,b=E}n.push(g)}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=s.skins[t.readInt(!0)];for(let f=0,m=t.readInt(!0);f<m;f++){const l=t.readInt(!0);for(let g=0,p=t.readInt(!0);g<p;g++){const y=t.readStringRef();if(!y)throw new Error("attachmentName must not be null.");const w=d.getAttachment(l,y),b=this.readDeformTimelineType(t),x=t.readInt(!0),S=x-1;switch(b){case zf:{const C=w,A=C.bones,v=C.vertices,M=A?v.length/3*2:v.length,E=t.readInt(!0),T=new _c(x,E,l,C);let R=t.readFloat();for(let k=0,I=0;;k++){let P,F=t.readInt(!0);if(F==0)P=A?ct.newFloatArray(M):v;else{P=ct.newFloatArray(M);const W=t.readInt(!0);if(F+=W,r==1)for(let Y=W;Y<F;Y++)P[Y]=t.readFloat();else for(let Y=W;Y<F;Y++)P[Y]=t.readFloat()*r;if(!A)for(let Y=0,_=P.length;Y<_;Y++)P[Y]+=v[Y]}if(T.setFrame(k,R,P),k==S)break;const X=t.readFloat();switch(t.readByte()){case $n:T.setStepped(k);break;case _n:Yt(t,T,I++,k,0,R,X,0,1,1)}R=X}n.push(T);break}case Xw:{const C=new Lc(x,l,w);for(let A=0;A<x;A++){const v=t.readFloat(),M=t.readInt32();C.setFrame(A,v,yc[M&15],M>>4,t.readFloat())}n.push(C);break}}}}}const c=t.readInt(!0);if(c>0){const a=new Ea(c),o=s.slots.length;for(let d=0;d<c;d++){const f=t.readFloat(),m=t.readInt(!0),l=ct.newArray(o,0);for(let w=o-1;w>=0;w--)l[w]=-1;const g=ct.newArray(o-m,0);let p=0,y=0;for(let w=0;w<m;w++){const b=t.readInt(!0);for(;p!=b;)g[y++]=p++;l[p+t.readInt(!0)]=p++}for(;p<o;)g[y++]=p++;for(let w=o-1;w>=0;w--)l[w]==-1&&(l[w]=g[--y]);a.setFrame(d,f,l)}n.push(a)}const h=t.readInt(!0);if(h>0){const a=new ll(h);for(let o=0;o<h;o++){const d=t.readFloat(),f=s.events[t.readInt(!0)],m=new Kc(d,f);m.intValue=t.readInt(!1),m.floatValue=t.readFloat(),m.stringValue=t.readBoolean()?t.readString():f.stringValue,m.data.audioPath&&(m.volume=t.readFloat(),m.balance=t.readFloat()),a.setFrame(o,m)}n.push(a)}let i=0;for(let a=0,o=n.length;a<o;a++)i=Math.max(i,n[a].getDuration());return new al(e,n,i)}};lr(nh,"BlendModeValues",[G.BLEND_MODES.NORMAL,G.BLEND_MODES.ADD,G.BLEND_MODES.MULTIPLY,G.BLEND_MODES.SCREEN]);let xw=class{constructor(t,e,s,n,r){lr(this,"parent"),lr(this,"skin"),lr(this,"slotIndex"),lr(this,"mesh"),lr(this,"inheritTimeline"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritTimeline=r}},ww=class{constructor(t=null,e=null){this.bones=t,this.vertices=e}};function Rr(u,t,e){let s=u.readFloat(),n=u.readFloat()*e;for(let r=0,c=0,h=t.getFrameCount()-1;t.setFrame(r,s,n),r!=h;r++){const i=u.readFloat(),a=u.readFloat()*e;switch(u.readByte()){case $n:t.setStepped(r);break;case _n:Yt(u,t,c++,r,0,s,i,n,a,e)}s=i,n=a}return t}function rh(u,t,e){let s=u.readFloat(),n=u.readFloat()*e,r=u.readFloat()*e;for(let c=0,h=0,i=t.getFrameCount()-1;t.setFrame(c,s,n,r),c!=i;c++){const a=u.readFloat(),o=u.readFloat()*e,d=u.readFloat()*e;switch(u.readByte()){case $n:t.setStepped(c);break;case _n:Yt(u,t,h++,c,0,s,a,n,o,e),Yt(u,t,h++,c,1,s,a,r,d,e)}s=a,n=o,r=d}return t}function Yt(u,t,e,s,n,r,c,h,i,a){t.setBezier(e,s,n,r,h,u.readFloat(),u.readFloat()*a,u.readFloat(),u.readFloat()*a,c,i)}const yw=0,Sw=1,Cw=2,Aw=3,vw=4,Mw=5,Ew=6,Tw=7,Iw=8,Rw=9,Pw=0,kw=1,Fw=2,Yw=3,$w=4,_w=5,zf=0,Xw=1,Bw=0,Vw=1,Nw=2,$n=1,_n=2;var Dw=Object.defineProperty,Lw=(u,t,e)=>t in u?Dw(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,oi=(u,t,e)=>Lw(u,typeof t!="symbol"?t+"":t,e);let Hf=class pp{constructor(t){oi(this,"attachmentLoader"),oi(this,"scale",1),oi(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new Zc,n=typeof t=="string"?JSON.parse(t):t,r=n.skeleton;if(r){s.hash=r.hash,s.version=r.spine;const c=s.version.substr(0,3);if(c!=="4.0"&&c!=="4.1"){const h=`Spine 4.1 loader cant load version ${r.spine}. Please configure your pixi-spine bundle`;console.error(h)}s.x=r.x,s.y=r.y,s.width=r.width,s.height=r.height,s.fps=r.fps,s.imagesPath=r.images}if(n.bones)for(let c=0;c<n.bones.length;c++){const h=n.bones[c];let i=null;const a=D(h,"parent",null);if(a!=null&&(i=s.findBone(a),i==null))throw new Error(`Parent bone not found: ${a}`);const o=new Jc(s.bones.length,h.name,i);o.length=D(h,"length",0)*e,o.x=D(h,"x",0)*e,o.y=D(h,"y",0)*e,o.rotation=D(h,"rotation",0),o.scaleX=D(h,"scaleX",1),o.scaleY=D(h,"scaleY",1),o.shearX=D(h,"shearX",0),o.shearY=D(h,"shearY",0),o.transformMode=ct.enumValue(on,D(h,"transform","Normal")),o.skinRequired=D(h,"skin",!1);const d=D(h,"color",null);d&&o.color.setFromString(d),s.bones.push(o)}if(n.slots)for(let c=0;c<n.slots.length;c++){const h=n.slots[c],i=s.findBone(h.bone);if(!i)throw new Error(`Couldn't find bone ${h.bone} for slot ${h.name}`);const a=new Qc(s.slots.length,h.name,i),o=D(h,"color",null);o&&a.color.setFromString(o);const d=D(h,"dark",null);d&&(a.darkColor=kt.fromString(d)),a.attachmentName=D(h,"attachment",null),a.blendMode=pp.blendModeFromString(D(h,"blend","normal")),s.slots.push(a)}if(n.ik)for(let c=0;c<n.ik.length;c++){const h=n.ik[c],i=new jc(h.name);i.order=D(h,"order",0),i.skinRequired=D(h,"skin",!1);for(let a=0;a<h.bones.length;a++){const o=h.bones[a],d=s.findBone(o);if(d==null)throw new Error(`IK bone not found: ${o}`);i.bones.push(d)}i.target=s.findBone(h.target),i.mix=D(h,"mix",1),i.softness=D(h,"softness",0)*e,i.bendDirection=D(h,"bendPositive",!0)?1:-1,i.compress=D(h,"compress",!1),i.stretch=D(h,"stretch",!1),i.uniform=D(h,"uniform",!1),s.ikConstraints.push(i)}if(n.transform)for(let c=0;c<n.transform.length;c++){const h=n.transform[c],i=new th(h.name);i.order=D(h,"order",0),i.skinRequired=D(h,"skin",!1);for(let d=0;d<h.bones.length;d++){const f=h.bones[d],m=s.findBone(f);if(!m)throw new Error(`Couldn't find bone ${f} for transform constraint ${h.name}.`);i.bones.push(m)}const a=h.target,o=s.findBone(a);if(!o)throw new Error(`Couldn't find target bone ${a} for transform constraint ${h.name}.`);i.target=o,i.local=D(h,"local",!1),i.relative=D(h,"relative",!1),i.offsetRotation=D(h,"rotation",0),i.offsetX=D(h,"x",0)*e,i.offsetY=D(h,"y",0)*e,i.offsetScaleX=D(h,"scaleX",0),i.offsetScaleY=D(h,"scaleY",0),i.offsetShearY=D(h,"shearY",0),i.mixRotate=D(h,"mixRotate",1),i.mixX=D(h,"mixX",1),i.mixY=D(h,"mixY",i.mixX),i.mixScaleX=D(h,"mixScaleX",1),i.mixScaleY=D(h,"mixScaleY",i.mixScaleX),i.mixShearY=D(h,"mixShearY",1),s.transformConstraints.push(i)}if(n.path)for(let c=0;c<n.path.length;c++){const h=n.path[c],i=new zc(h.name);i.order=D(h,"order",0),i.skinRequired=D(h,"skin",!1);for(let d=0;d<h.bones.length;d++){const f=h.bones[d],m=s.findBone(f);if(!m)throw new Error(`Couldn't find bone ${f} for path constraint ${h.name}.`);i.bones.push(m)}const a=h.target,o=s.findSlot(a);if(!o)throw new Error(`Couldn't find target slot ${a} for path constraint ${h.name}.`);i.target=o,i.positionMode=ct.enumValue(Er,D(h,"positionMode","Percent")),i.spacingMode=ct.enumValue(Ue,D(h,"spacingMode","Length")),i.rotateMode=ct.enumValue(Ta,D(h,"rotateMode","Tangent")),i.offsetRotation=D(h,"rotation",0),i.position=D(h,"position",0),i.positionMode==Er.Fixed&&(i.position*=e),i.spacing=D(h,"spacing",0),(i.spacingMode==Ue.Length||i.spacingMode==Ue.Fixed)&&(i.spacing*=e),i.mixRotate=D(h,"mixRotate",1),i.mixX=D(h,"mixX",1),i.mixY=D(h,"mixY",i.mixX),s.pathConstraints.push(i)}if(n.skins)for(let c=0;c<n.skins.length;c++){const h=n.skins[c],i=new fl(h.name);if(h.bones)for(let a=0;a<h.bones.length;a++){const o=h.bones[a],d=s.findBone(o);if(!d)throw new Error(`Couldn't find bone ${o} for skin ${h.name}.`);i.bones.push(d)}if(h.ik)for(let a=0;a<h.ik.length;a++){const o=h.ik[a],d=s.findIkConstraint(o);if(!d)throw new Error(`Couldn't find IK constraint ${o} for skin ${h.name}.`);i.constraints.push(d)}if(h.transform)for(let a=0;a<h.transform.length;a++){const o=h.transform[a],d=s.findTransformConstraint(o);if(!d)throw new Error(`Couldn't find transform constraint ${o} for skin ${h.name}.`);i.constraints.push(d)}if(h.path)for(let a=0;a<h.path.length;a++){const o=h.path[a],d=s.findPathConstraint(o);if(!d)throw new Error(`Couldn't find path constraint ${o} for skin ${h.name}.`);i.constraints.push(d)}for(const a in h.attachments){const o=s.findSlot(a);if(!o)throw new Error(`Couldn't find slot ${a} for skin ${h.name}.`);const d=h.attachments[a];for(const f in d){const m=this.readAttachment(d[f],i,o.index,f,s);m&&i.setAttachment(o.index,f,m)}}s.skins.push(i),i.name=="default"&&(s.defaultSkin=i)}for(let c=0,h=this.linkedMeshes.length;c<h;c++){const i=this.linkedMeshes[c],a=i.skin?s.findSkin(i.skin):s.defaultSkin;if(!a)throw new Error(`Skin not found: ${i.skin}`);const o=a.getAttachment(i.slotIndex,i.parent);if(!o)throw new Error(`Parent mesh not found: ${i.parent}`);i.mesh.timelineAttachment=i.inheritTimeline?o:i.mesh,i.mesh.setParentMesh(o)}if(this.linkedMeshes.length=0,n.events)for(const c in n.events){const h=n.events[c],i=new sh(c);i.intValue=D(h,"int",0),i.floatValue=D(h,"float",0),i.stringValue=D(h,"string",""),i.audioPath=D(h,"audio",null),i.audioPath&&(i.volume=D(h,"volume",1),i.balance=D(h,"balance",0)),s.events.push(i)}if(n.animations)for(const c in n.animations){const h=n.animations[c];this.readAnimation(h,c,s)}return s}readAttachment(t,e,s,n,r){const c=this.scale;switch(n=D(t,"name",n),D(t,"type","region")){case"region":{const h=D(t,"path",n),i=this.readSequence(D(t,"sequence",null)),a=this.attachmentLoader.newRegionAttachment(e,n,h,i);if(!a)return null;a.path=h,a.x=D(t,"x",0)*c,a.y=D(t,"y",0)*c,a.scaleX=D(t,"scaleX",1),a.scaleY=D(t,"scaleY",1),a.rotation=D(t,"rotation",0),a.width=t.width*c,a.height=t.height*c,a.sequence=i;const o=D(t,"color",null);return o&&a.color.setFromString(o),a}case"boundingbox":{const h=this.attachmentLoader.newBoundingBoxAttachment(e,n);if(!h)return null;this.readVertices(t,h,t.vertexCount<<1);const i=D(t,"color",null);return i&&h.color.setFromString(i),h}case"mesh":case"linkedmesh":{const h=D(t,"path",n),i=this.readSequence(D(t,"sequence",null)),a=this.attachmentLoader.newMeshAttachment(e,n,h,i);if(!a)return null;a.path=h;const o=D(t,"color",null);o&&a.color.setFromString(o),a.width=D(t,"width",0)*c,a.height=D(t,"height",0)*c,a.sequence=i;const d=D(t,"parent",null);if(d)return this.linkedMeshes.push(new Ow(a,D(t,"skin",null),s,d,D(t,"timelines",!0))),a;const f=t.uvs;return this.readVertices(t,a,f.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(f),a.edges=D(t,"edges",null),a.hullLength=D(t,"hull",0)*2,a}case"path":{const h=this.attachmentLoader.newPathAttachment(e,n);if(!h)return null;h.closed=D(t,"closed",!1),h.constantSpeed=D(t,"constantSpeed",!0);const i=t.vertexCount;this.readVertices(t,h,i<<1);const a=ct.newArray(i/3,0);for(let d=0;d<t.lengths.length;d++)a[d]=t.lengths[d]*c;h.lengths=a;const o=D(t,"color",null);return o&&h.color.setFromString(o),h}case"point":{const h=this.attachmentLoader.newPointAttachment(e,n);if(!h)return null;h.x=D(t,"x",0)*c,h.y=D(t,"y",0)*c,h.rotation=D(t,"rotation",0);const i=D(t,"color",null);return i&&h.color.setFromString(i),h}case"clipping":{const h=this.attachmentLoader.newClippingAttachment(e,n);if(!h)return null;const i=D(t,"end",null);if(i!=null){const d=r.findSlot(i);if(d==null)throw new Error(`Clipping end slot not found: ${i}`);h.endSlot=d}const a=t.vertexCount;this.readVertices(t,h,a<<1);const o=D(t,"color",null);return o&&h.color.setFromString(o),h}}return null}readSequence(t){if(t==null)return null;const e=new wc(D(t,"count",0));return e.start=D(t,"start",1),e.digits=D(t,"digits",0),e.setupIndex=D(t,"setup",0),e}readVertices(t,e,s){const n=this.scale;e.worldVerticesLength=s;const r=t.vertices;if(s==r.length){const i=ct.toFloatArray(r);if(n!=1)for(let a=0,o=r.length;a<o;a++)i[a]*=n;e.vertices=i;return}const c=new Array,h=new Array;for(let i=0,a=r.length;i<a;){const o=r[i++];h.push(o);for(let d=i+o*4;i<d;i+=4)h.push(r[i]),c.push(r[i+1]*n),c.push(r[i+2]*n),c.push(r[i+3])}e.bones=h,e.vertices=ct.toFloatArray(c)}readAnimation(t,e,s){const n=this.scale,r=new Array;if(t.slots)for(const h in t.slots){const i=t.slots[h],a=s.findSlot(h);if(!a)throw new Error(`Slot not found: ${h}`);const o=a.index;for(const d in i){const f=i[d];if(!f)continue;const m=f.length;if(d=="attachment"){const l=new sa(m,o);for(let g=0;g<m;g++){const p=f[g];l.setFrame(g,D(p,"time",0),D(p,"name",null))}r.push(l)}else if(d=="rgba"){const l=new Pc(m,m<<2,o);let g=f[0],p=D(g,"time",0),y=kt.fromString(g.color);for(let w=0,b=0;;w++){l.setFrame(w,p,y.r,y.g,y.b,y.a);const x=f[w+1];if(!x){l.shrink(b);break}const S=D(x,"time",0),C=kt.fromString(x.color),A=g.curve;A&&(b=Xt(A,l,b,w,0,p,S,y.r,C.r,1),b=Xt(A,l,b,w,1,p,S,y.g,C.g,1),b=Xt(A,l,b,w,2,p,S,y.b,C.b,1),b=Xt(A,l,b,w,3,p,S,y.a,C.a,1)),p=S,y=C,g=x}r.push(l)}else if(d=="rgb"){const l=new kc(m,m*3,o);let g=f[0],p=D(g,"time",0),y=kt.fromString(g.color);for(let w=0,b=0;;w++){l.setFrame(w,p,y.r,y.g,y.b);const x=f[w+1];if(!x){l.shrink(b);break}const S=D(x,"time",0),C=kt.fromString(x.color),A=g.curve;A&&(b=Xt(A,l,b,w,0,p,S,y.r,C.r,1),b=Xt(A,l,b,w,1,p,S,y.g,C.g,1),b=Xt(A,l,b,w,2,p,S,y.b,C.b,1)),p=S,y=C,g=x}r.push(l)}else if(d=="alpha")r.push(cr(f,new Fc(m,m,o),0,1));else if(d=="rgba2"){const l=new Yc(m,m*7,o);let g=f[0],p=D(g,"time",0),y=kt.fromString(g.light),w=kt.fromString(g.dark);for(let b=0,x=0;;b++){l.setFrame(b,p,y.r,y.g,y.b,y.a,w.r,w.g,w.b);const S=f[b+1];if(!S){l.shrink(x);break}const C=D(S,"time",0),A=kt.fromString(S.light),v=kt.fromString(S.dark),M=g.curve;M&&(x=Xt(M,l,x,b,0,p,C,y.r,A.r,1),x=Xt(M,l,x,b,1,p,C,y.g,A.g,1),x=Xt(M,l,x,b,2,p,C,y.b,A.b,1),x=Xt(M,l,x,b,3,p,C,y.a,A.a,1),x=Xt(M,l,x,b,4,p,C,w.r,v.r,1),x=Xt(M,l,x,b,5,p,C,w.g,v.g,1),x=Xt(M,l,x,b,6,p,C,w.b,v.b,1)),p=C,y=A,w=v,g=S}r.push(l)}else if(d=="rgb2"){const l=new $c(m,m*6,o);let g=f[0],p=D(g,"time",0),y=kt.fromString(g.light),w=kt.fromString(g.dark);for(let b=0,x=0;;b++){l.setFrame(b,p,y.r,y.g,y.b,w.r,w.g,w.b);const S=f[b+1];if(!S){l.shrink(x);break}const C=D(S,"time",0),A=kt.fromString(S.light),v=kt.fromString(S.dark),M=g.curve;M&&(x=Xt(M,l,x,b,0,p,C,y.r,A.r,1),x=Xt(M,l,x,b,1,p,C,y.g,A.g,1),x=Xt(M,l,x,b,2,p,C,y.b,A.b,1),x=Xt(M,l,x,b,3,p,C,w.r,v.r,1),x=Xt(M,l,x,b,4,p,C,w.g,v.g,1),x=Xt(M,l,x,b,5,p,C,w.b,v.b,1)),p=C,y=A,w=v,g=S}r.push(l)}}}if(t.bones)for(const h in t.bones){const i=t.bones[h],a=s.findBone(h);if(!a)throw new Error(`Bone not found: ${h}`);const o=a.index;for(const d in i){const f=i[d],m=f.length;if(m!=0){if(d==="rotate")r.push(cr(f,new wo(m,m,o),0,1));else if(d==="translate"){const l=new Sc(m,m<<1,o);r.push(ih(f,l,"x","y",0,n))}else if(d==="translatex"){const l=new Cc(m,m,o);r.push(cr(f,l,0,n))}else if(d==="translatey"){const l=new Ac(m,m,o);r.push(cr(f,l,0,n))}else if(d==="scale"){const l=new vc(m,m<<1,o);r.push(ih(f,l,"x","y",1,1))}else if(d==="scalex"){const l=new Mc(m,m,o);r.push(cr(f,l,1,1))}else if(d==="scaley"){const l=new Ec(m,m,o);r.push(cr(f,l,1,1))}else if(d==="shear"){const l=new Tc(m,m<<1,o);r.push(ih(f,l,"x","y",0,1))}else if(d==="shearx"){const l=new Ic(m,m,o);r.push(cr(f,l,0,1))}else if(d==="sheary"){const l=new Rc(m,m,o);r.push(cr(f,l,0,1))}}}}if(t.ik)for(const h in t.ik){const i=t.ik[h];let a=i[0];if(!a)continue;const o=s.findIkConstraint(h);if(!o)throw new Error(`IK Constraint not found: ${h}`);const d=s.ikConstraints.indexOf(o),f=new Xc(i.length,i.length<<1,d);let m=D(a,"time",0),l=D(a,"mix",1),g=D(a,"softness",0)*n;for(let p=0,y=0;;p++){f.setFrame(p,m,l,g,D(a,"bendPositive",!0)?1:-1,D(a,"compress",!1),D(a,"stretch",!1));const w=i[p+1];if(!w){f.shrink(y);break}const b=D(w,"time",0),x=D(w,"mix",1),S=D(w,"softness",0)*n,C=a.curve;C&&(y=Xt(C,f,y,p,0,m,b,l,x,1),y=Xt(C,f,y,p,1,m,b,g,S,n)),m=b,l=x,g=S,a=w}r.push(f)}if(t.transform)for(const h in t.transform){const i=t.transform[h];let a=i[0];if(!a)continue;const o=s.findTransformConstraint(h);if(!o)throw new Error(`Transform constraint not found: ${h}`);const d=s.transformConstraints.indexOf(o),f=new Bc(i.length,i.length*6,d);let m=D(a,"time",0),l=D(a,"mixRotate",1),g=D(a,"mixX",1),p=D(a,"mixY",g),y=D(a,"mixScaleX",1),w=D(a,"mixScaleY",y);const b=D(a,"mixShearY",1);for(let x=0,S=0;;x++){f.setFrame(x,m,l,g,p,y,w,b);const C=i[x+1];if(!C){f.shrink(S);break}const A=D(C,"time",0),v=D(C,"mixRotate",1),M=D(C,"mixX",1),E=D(C,"mixY",M),T=D(C,"mixScaleX",1),R=D(C,"mixScaleY",T),k=D(C,"mixShearY",1),I=a.curve;I&&(S=Xt(I,f,S,x,0,m,A,l,v,1),S=Xt(I,f,S,x,1,m,A,g,M,1),S=Xt(I,f,S,x,2,m,A,p,E,1),S=Xt(I,f,S,x,3,m,A,y,T,1),S=Xt(I,f,S,x,4,m,A,w,R,1),S=Xt(I,f,S,x,5,m,A,b,k,1)),m=A,l=v,g=M,p=E,y=T,w=R,y=T,a=C}r.push(f)}if(t.path)for(const h in t.path){const i=t.path[h],a=s.findPathConstraint(h);if(!a)throw new Error(`Path constraint not found: ${h}`);const o=s.pathConstraints.indexOf(a);for(const d in i){const f=i[d];let m=f[0];if(!m)continue;const l=f.length;if(d==="position"){const g=new Vc(l,l,o);r.push(cr(f,g,0,a.positionMode==Er.Fixed?n:1))}else if(d==="spacing"){const g=new Nc(l,l,o);r.push(cr(f,g,0,a.spacingMode==Ue.Length||a.spacingMode==Ue.Fixed?n:1))}else if(d==="mix"){const g=new Dc(l,l*3,o);let p=D(m,"time",0),y=D(m,"mixRotate",1),w=D(m,"mixX",1),b=D(m,"mixY",w);for(let x=0,S=0;;x++){g.setFrame(x,p,y,w,b);const C=f[x+1];if(!C){g.shrink(S);break}const A=D(C,"time",0),v=D(C,"mixRotate",1),M=D(C,"mixX",1),E=D(C,"mixY",M),T=m.curve;T&&(S=Xt(T,g,S,x,0,p,A,y,v,1),S=Xt(T,g,S,x,1,p,A,w,M,1),S=Xt(T,g,S,x,2,p,A,b,E,1)),p=A,y=v,w=M,b=E,m=C}r.push(g)}}}if(t.deform){t.attachments={};for(const h in t.deform){const i=t.deform[h],a=t.attachments[h]={};for(const o in i){const d=i[o],f=a[o]={};for(const m in d)f[m]={deform:d[m]}}}}if(t.attachments)for(const h in t.attachments){const i=t.attachments[h],a=s.findSkin(h);if(a!=null)for(const o in i){const d=i[o],f=s.findSlot(o);if(!f)throw new Error(`Slot not found: ${o}`);const m=f.index;for(const l in d){const g=d[l],p=a.getAttachment(m,l);for(const y in g){const w=g[y];let b=w[0];if(b){if(y=="deform"){const x=p.bones,S=p.vertices,C=x?S.length/3*2:S.length,A=new _c(w.length,w.length,m,p);let v=D(b,"time",0);for(let M=0,E=0;;M++){let T;const R=D(b,"vertices",null);if(!R)T=x?ct.newFloatArray(C):S;else{T=ct.newFloatArray(C);const F=D(b,"offset",0);if(ct.arrayCopy(R,0,T,F,R.length),n!=1)for(let X=F,W=X+R.length;X<W;X++)T[X]*=n;if(!x)for(let X=0;X<C;X++)T[X]+=S[X]}A.setFrame(M,v,T);const k=w[M+1];if(!k){A.shrink(E);break}const I=D(k,"time",0),P=b.curve;P&&(E=Xt(P,A,E,M,0,v,I,0,1,1)),v=I,b=k}r.push(A)}else if(y=="sequence"){const x=new Lc(w.length,m,p);let S=0;for(let C=0;C<w.length;C++){const A=D(b,"delay",S),v=D(b,"time",0),M=or[D(b,"mode","hold")],E=D(b,"index",0);x.setFrame(C,v,M,E,A),S=A,b=w[C+1]}r.push(x)}}}}}}if(t.drawOrder){const h=new Ea(t.drawOrder.length),i=s.slots.length;let a=0;for(let o=0;o<t.drawOrder.length;o++,a++){const d=t.drawOrder[o];let f=null;const m=D(d,"offsets",null);if(m){f=ct.newArray(i,-1);const l=ct.newArray(i-m.length,0);let g=0,p=0;for(let y=0;y<m.length;y++){const w=m[y],b=s.findSlot(w.slot);if(!b)throw new Error(`Slot not found: ${b}`);const x=b.index;for(;g!=x;)l[p++]=g++;f[g+w.offset]=g++}for(;g<i;)l[p++]=g++;for(let y=i-1;y>=0;y--)f[y]==-1&&(f[y]=l[--p])}h.setFrame(a,D(d,"time",0),f)}r.push(h)}if(t.events){const h=new ll(t.events.length);let i=0;for(let a=0;a<t.events.length;a++,i++){const o=t.events[a],d=s.findEvent(o.name);if(!d)throw new Error(`Event not found: ${o.name}`);const f=new Kc(ct.toSinglePrecision(D(o,"time",0)),d);f.intValue=D(o,"int",d.intValue),f.floatValue=D(o,"float",d.floatValue),f.stringValue=D(o,"string",d.stringValue),f.data.audioPath&&(f.volume=D(o,"volume",1),f.balance=D(o,"balance",0)),h.setFrame(i,f)}r.push(h)}let c=0;for(let h=0,i=r.length;h<i;h++)c=Math.max(c,r[h].getDuration());if(isNaN(c))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new al(e,r,c))}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return G.BLEND_MODES.NORMAL;if(t=="additive")return G.BLEND_MODES.ADD;if(t=="multiply")return G.BLEND_MODES.MULTIPLY;if(t=="screen")return G.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}},Ow=class{constructor(t,e,s,n,r){oi(this,"parent"),oi(this,"skin"),oi(this,"slotIndex"),oi(this,"mesh"),oi(this,"inheritTimeline"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritTimeline=r}};function cr(u,t,e,s){let n=u[0],r=D(n,"time",0),c=D(n,"value",e)*s,h=0;for(let i=0;;i++){t.setFrame(i,r,c);const a=u[i+1];if(!a)return t.shrink(h),t;const o=D(a,"time",0),d=D(a,"value",e)*s;n.curve&&(h=Xt(n.curve,t,h,i,0,r,o,c,d,s)),r=o,c=d,n=a}}function ih(u,t,e,s,n,r){let c=u[0],h=D(c,"time",0),i=D(c,e,n)*r,a=D(c,s,n)*r,o=0;for(let d=0;;d++){t.setFrame(d,h,i,a);const f=u[d+1];if(!f)return t.shrink(o),t;const m=D(f,"time",0),l=D(f,e,n)*r,g=D(f,s,n)*r,p=c.curve;p&&(o=Xt(p,t,o,d,0,h,m,i,l,r),o=Xt(p,t,o,d,1,h,m,a,g,r)),h=m,i=l,a=g,c=f}}function Xt(u,t,e,s,n,r,c,h,i,a){if(u=="stepped")return t.setStepped(s),e;const o=n<<2,d=u[o],f=u[o+1]*a,m=u[o+2],l=u[o+3]*a;return t.setBezier(e,s,n,r,h,d,f,m,l,c,i),e+1}function D(u,t,e){return u[t]!==void 0?u[t]:e}var Ww=Object.defineProperty,Uw=(u,t,e)=>t in u?Ww(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ds=(u,t,e)=>Uw(u,typeof t!="symbol"?t+"":t,e);let Kf=class{constructor(){ds(this,"entries",{}),ds(this,"size",0)}add(t){const e=this.entries[t];return this.entries[t]=!0,e?!1:(this.size++,!0)}addAll(t){const e=this.size;for(let s=0,n=t.length;s<n;s++)this.add(t[s]);return e!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}};const Xn=class bp{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new bp().setFromString(t)}};ds(Xn,"WHITE",new Xn(1,1,1,1)),ds(Xn,"RED",new Xn(1,0,0,1)),ds(Xn,"GREEN",new Xn(0,1,0,1)),ds(Xn,"BLUE",new Xn(0,0,1,1)),ds(Xn,"MAGENTA",new Xn(1,0,1,1));let Pt=Xn;const Zs=class Go{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*Go.degRad)}static sinDeg(t){return Math.sin(t*Go.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*Go.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return Go.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};ds(Zs,"PI",3.1415927),ds(Zs,"PI2",Zs.PI*2),ds(Zs,"invPI2",1/Zs.PI2),ds(Zs,"radiansToDegrees",180/Zs.PI),ds(Zs,"radDeg",Zs.radiansToDegrees),ds(Zs,"degreesToRadians",Zs.PI/180),ds(Zs,"degRad",Zs.degreesToRadians);let st=Zs;const Zf=class Wa{static arrayCopy(t,e,s,n,r){for(let c=e,h=n;c<e+r;c++,h++)s[h]=t[c]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:Wa.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(Wa.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(Wa.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return Wa.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return Wa.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}};ds(Zf,"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");let nt=Zf,ml=class{constructor(t){ds(this,"items",new Array),ds(this,"instantiator"),this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}},ah=class{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}};var aa=(u=>(u[u.Region=0]="Region",u[u.BoundingBox=1]="BoundingBox",u[u.Mesh=2]="Mesh",u[u.LinkedMesh=3]="LinkedMesh",u[u.Path=4]="Path",u[u.Point=5]="Point",u[u.Clipping=6]="Clipping",u))(aa||{}),pe=(u=>(u[u.Normal=0]="Normal",u[u.OnlyTranslation=1]="OnlyTranslation",u[u.NoRotationOrReflection=2]="NoRotationOrReflection",u[u.NoScale=3]="NoScale",u[u.NoScaleOrReflection=4]="NoScaleOrReflection",u))(pe||{}),li=(u=>(u[u.none=0]="none",u[u.reset=1]="reset",u[u.update=2]="update",u[u.pose=3]="pose",u))(li||{}),qw=Object.defineProperty,Gw=(u,t,e)=>t in u?qw(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Mo=(u,t,e)=>Gw(u,typeof t!="symbol"?t+"":t,e);let Qf=class{constructor(){Mo(this,"texture"),Mo(this,"size",null),Mo(this,"names",null),Mo(this,"values",null),Mo(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}};var Jf=(u=>(u[u.UNKNOWN=0]="UNKNOWN",u[u.VER37=37]="VER37",u[u.VER38=38]="VER38",u[u.VER40=40]="VER40",u[u.VER41=41]="VER41",u[u.VER42=42]="VER42",u))(Jf||{});function zw(u){const t=u.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}const Hw={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var Kw=Object.defineProperty,Zw=(u,t,e)=>t in u?Kw(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,us=(u,t,e)=>Zw(u,typeof t!="symbol"?t+"":t,e);const ci=[0,0,0];let Qw=class extends zr.Sprite{constructor(){super(...arguments),us(this,"region",null),us(this,"attachment",null)}},Jw=class extends Gr.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),us(this,"region",null),us(this,"attachment",null)}};const jf=class xp extends Lt.Container{constructor(t){if(super(),us(this,"tintRgb"),us(this,"spineData"),us(this,"skeleton"),us(this,"stateData"),us(this,"state"),us(this,"slotContainers"),us(this,"tempClipContainers"),us(this,"localDelayLimit"),us(this,"_autoUpdate"),us(this,"_visible"),us(this,"_debug"),us(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),c=this.newContainer();if(this.slotContainers.push(c),this.addChild(c),this.tempClipContainers.push(null),!!r)if(r.type===aa.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,c.addChild(i)}else if(r.type===aa.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,c.addChild(h)}else r.type===aa.Clipping&&(this.createGraphics(n,r),c.addChild(n.clippingContainer),c.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?xp.prototype.autoUpdateTransform:Lt.Container.prototype.updateTransform)}get tint(){return G.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=G.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:Hw.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=zw(this.spineData.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===Jf.VER42&&li.update);const n=this.skeleton.slots,r=this.color;let c=null,h=null;r?(c=r.light,h=r.dark):c=this.tintRgb;for(let f=0,m=n.length;f<m;f++){const l=n[f],g=l.getAttachment(),p=this.slotContainers[f];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(l,g);let w=g.region;const b=g.color;switch(g!=null&&g.type){case aa.Region:if(p.transform.setFromMatrix(l.bone.matrix),w=g.region,l.currentMesh&&(l.currentMesh.visible=!1,l.currentMesh=null,l.currentMeshId=void 0,l.currentMeshName=void 0),!w){l.currentSprite&&(l.currentSprite.renderable=!1);break}if(!l.currentSpriteName||l.currentSpriteName!==g.name){const C=g.name;if(l.currentSprite&&(l.currentSprite.visible=!1),l.sprites=l.sprites||{},l.sprites[C]!==void 0)l.sprites[C].visible=!0;else{const A=this.createSprite(l,g,C);p.addChild(A)}l.currentSprite=l.sprites[C],l.currentSpriteName=C}l.currentSprite.renderable=!0,l.hackRegion||this.setSpriteRegion(g,l.currentSprite,w),l.currentSprite.color?y=l.currentSprite.color:(ci[0]=c[0]*l.color.r*b.r,ci[1]=c[1]*l.color.g*b.g,ci[2]=c[2]*l.color.b*b.b,l.currentSprite.tint=G.utils.rgb2hex(ci)),l.currentSprite.blendMode=l.blendMode;break;case aa.Mesh:if(l.currentSprite){l.currentSprite.visible=!1,l.currentSprite=null,l.currentSpriteName=void 0;const C=new G.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){l.currentMesh&&(l.currentMesh.renderable=!1);break}const S=g.id;if(l.currentMeshId===void 0||l.currentMeshId!==S){const C=S;if(l.currentMesh&&(l.currentMesh.visible=!1),l.meshes=l.meshes||{},l.meshes[C]!==void 0)l.meshes[C].visible=!0;else{const A=this.createMesh(l,g);p.addChild(A)}l.currentMesh=l.meshes[C],l.currentMeshName=g.name,l.currentMeshId=C}l.currentMesh.renderable=!0,g.computeWorldVerticesOld(l,l.currentMesh.vertices),l.currentMesh.color?y=l.currentMesh.color:(ci[0]=c[0]*l.color.r*b.r,ci[1]=c[1]*l.color.g*b.g,ci[2]=c[2]*l.color.b*b.b,l.currentMesh.tint=G.utils.rgb2hex(ci)),l.currentMesh.blendMode=l.blendMode,l.hackRegion||this.setMeshRegion(g,l.currentMesh,w);break;case aa.Clipping:l.currentGraphics||(this.createGraphics(l,g),p.addChild(l.clippingContainer),p.addChild(l.currentGraphics)),this.updateGraphics(l,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let x=l.color.r*b.r,S=l.color.g*b.g,C=l.color.b*b.b;y.setLight(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C)),l.darkColor?(x=l.darkColor.r,S=l.darkColor.g,C=l.darkColor.b):(x=0,S=0,C=0),y.setDark(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C))}p.alpha=l.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let f=0,m=i.length;f<m;f++){const l=n[i[f].data.index],g=this.slotContainers[i[f].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),l.currentGraphics&&l.getAttachment())o=l.clippingContainer,a=l.getAttachment(),o.children.length=0,this.children[f]=g,a.endSlot===l.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[f];p||(p=this.tempClipContainers[f]=this.newContainer(),p.visible=!1),this.children[f]=p,g.parent=null,o.addChild(g),a.endSlot==l.data&&(o.renderable=!0,o=null,a=null)}else this.children[f]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*st.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}Lt.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,c=this.newSprite(r);return c.anchor.set(.5),n&&this.setSpriteRegion(e,c,e.region),t.sprites=t.sprites||{},t.sprites[s]=c,c}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),G.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new G.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let c=r.region;return e?(c=new Qf,c.texture=e,c.size=s,n.hackRegion=c,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,c):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,c),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),c=this.skeleton.getAttachmentByName(t,e);c.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=c.region;return s?(a=new Qf,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Lt.Container}newSprite(t){return new Qw(t)}newGraphics(){return new Ye.Graphics}newMesh(t,e,s,n,r){return new Jw(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let c=0,h=this.skeleton.slots.length;c<h;c++){const i=this.skeleton.slots[c],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};us(jf,"clippingPolygon",[]);let tm=jf;Object.defineProperty(tm.prototype,"visible",{get(){return this._visible},set(u){u!==this._visible&&(this._visible=u,u&&(this.lastTime=0))}});var jw=Object.defineProperty,ty=(u,t,e)=>t in u?jw(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,hi=(u,t,e)=>ty(u,typeof t!="symbol"?t+"":t,e);let oh=class{constructor(t){if(hi(this,"name"),hi(this,"type"),!t)throw new Error("name cannot be null.");this.name=t}};const em=class wp extends oh{constructor(t){super(t),hi(this,"id",wp.nextID++),hi(this,"bones",null),hi(this,"vertices",[]),hi(this,"worldVerticesLength",0),hi(this,"timelineAttachment",this)}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,s,n,r,c){s=r+(s>>1)*c;const h=t.bone.skeleton,i=t.deform;let a=this.vertices;const o=this.bones;if(!o){i.length>0&&(a=i);const l=t.bone,g=l.worldX,p=l.worldY,y=l.a,w=l.b,b=l.c,x=l.d;for(let S=e,C=r;C<s;S+=2,C+=c){const A=a[S],v=a[S+1];n[C]=A*y+v*w+g,n[C+1]=A*b+v*x+p}return}let d=0,f=0;for(let l=0;l<e;l+=2){const g=o[d];d+=g+1,f+=g}const m=h.bones;if(i.length==0)for(let l=r,g=f*3;l<s;l+=c){let p=0,y=0,w=o[d++];for(w+=d;d<w;d++,g+=3){const b=m[o[d]],x=a[g],S=a[g+1],C=a[g+2];p+=(x*b.a+S*b.b+b.worldX)*C,y+=(x*b.c+S*b.d+b.worldY)*C}n[l]=p,n[l+1]=y}else{const l=i;for(let g=r,p=f*3,y=f<<1;g<s;g+=c){let w=0,b=0,x=o[d++];for(x+=d;d<x;d++,p+=3,y+=2){const S=m[o[d]],C=a[p]+l[y],A=a[p+1]+l[y+1],v=a[p+2];w+=(C*S.a+A*S.b+S.worldX)*v,b+=(C*S.c+A*S.d+S.worldY)*v}n[g]=w,n[g+1]=b}}}copyTo(t){this.bones?(t.bones=new Array(this.bones.length),nt.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices&&(t.vertices=nt.newFloatArray(this.vertices.length),nt.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)),t.worldVerticesLength=this.worldVerticesLength,t.timelineAttachment=this.timelineAttachment}};hi(em,"nextID",0);let hr=em;var ey=Object.defineProperty,sy=(u,t,e)=>t in u?ey(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ia=(u,t,e)=>sy(u,typeof t!="symbol"?t+"":t,e);const sm=class Fl{constructor(t){Ia(this,"id",Fl.nextID()),Ia(this,"regions"),Ia(this,"start",0),Ia(this,"digits",0),Ia(this,"setupIndex",0),this.regions=new Array(t)}copy(){const t=new Fl(this.regions.length);return nt.arrayCopy(this.regions,0,t.regions,0,this.regions.length),t.start=this.start,t.digits=this.digits,t.setupIndex=this.setupIndex,t}apply(t,e){let s=t.sequenceIndex;s==-1&&(s=this.setupIndex),s>=this.regions.length&&(s=this.regions.length-1);const n=this.regions[s];e.region!=n&&(e.region=n)}getPath(t,e){let s=t;const n=(this.start+e).toString();for(let r=this.digits-n.length;r>0;r--)s+="0";return s+=n,s}static nextID(){return Fl._nextID++}};Ia(sm,"_nextID",0);let lh=sm;var dr=(u=>(u[u.hold=0]="hold",u[u.once=1]="once",u[u.loop=2]="loop",u[u.pingpong=3]="pingpong",u[u.onceReverse=4]="onceReverse",u[u.loopReverse=5]="loopReverse",u[u.pingpongReverse=6]="pingpongReverse",u))(dr||{});const ch=[0,1,2,3,4,5,6];var ny=Object.defineProperty,ry=(u,t,e)=>t in u?ny(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ct=(u,t,e)=>ry(u,typeof t!="symbol"?t+"":t,e);let gl=class{constructor(t,e,s){if(Ct(this,"name"),Ct(this,"timelines",[]),Ct(this,"timelineIds",new Kf),Ct(this,"duration"),!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(e),this.duration=s}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(let e=0;e<t.length;e++)this.timelineIds.addAll(t[e].getPropertyIds())}hasTimeline(t){for(let e=0;e<t.length;e++)if(this.timelineIds.contains(t[e]))return!0;return!1}apply(t,e,s,n,r,c,h,i){if(!t)throw new Error("skeleton cannot be null.");n&&this.duration!=0&&(s%=this.duration,e>0&&(e%=this.duration));const a=this.timelines;for(let o=0,d=a.length;o<d;o++)a[o].apply(t,e,s,r,c,h,i)}};var Ae=(u=>(u[u.setup=0]="setup",u[u.first=1]="first",u[u.replace=2]="replace",u[u.add=3]="add",u))(Ae||{}),di=(u=>(u[u.mixIn=0]="mixIn",u[u.mixOut=1]="mixOut",u))(di||{});const Tt={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,transformMode:7,rgb:8,alpha:9,rgb2:10,attachment:11,deform:12,event:13,drawOrder:14,ikConstraint:15,transformConstraint:16,pathConstraintPosition:17,pathConstraintSpacing:18,pathConstraintMix:19,physicsConstraintInertia:20,physicsConstraintStrength:21,physicsConstraintDamping:22,physicsConstraintMass:23,physicsConstraintWind:24,physicsConstraintGravity:25,physicsConstraintMix:26,physicsConstraintReset:27,sequence:28};let ne=class{constructor(t,e){Ct(this,"propertyIds"),Ct(this,"frames"),this.propertyIds=e,this.frames=nt.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,e){const s=t.length;for(let n=1;n<s;n++)if(t[n]>e)return n-1;return s-1}static search(t,e,s){const n=t.length;for(let r=s;r<n;r+=s)if(t[r]>e)return r-s;return n-s}},Bn=class extends ne{constructor(t,e,s){super(t,s),Ct(this,"curves"),this.curves=nt.newFloatArray(t+e*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const e=this.getFrameCount()+t*18;if(this.curves.length>e){const s=nt.newFloatArray(e);nt.arrayCopy(this.curves,0,s,0,e),this.curves=s}}setBezier(t,e,s,n,r,c,h,i,a,o,d){const f=this.curves;let m=this.getFrameCount()+t*18;s==0&&(f[e]=2+m);const l=(n-c*2+i)*.03,g=(r-h*2+a)*.03,p=((c-i)*3-n+o)*.006,y=((h-a)*3-r+d)*.006;let w=l*2+p,b=g*2+y,x=(c-n)*.3+l+p*.16666667,S=(h-r)*.3+g+y*.16666667,C=n+x,A=r+S;for(let v=m+18;m<v;m+=2)f[m]=C,f[m+1]=A,x+=w,S+=b,w+=p,b+=y,C+=x,A+=S}getBezierValue(t,e,s,n){const r=this.curves;if(r[n]>t){const a=this.frames[e],o=this.frames[e+s];return o+(t-a)/(r[n]-a)*(r[n+1]-o)}const c=n+18;for(n+=2;n<c;n+=2)if(r[n]>=t){const a=r[n-2],o=r[n-1];return o+(t-a)/(r[n]-a)*(r[n+1]-o)}e+=this.getFrameEntries();const h=r[c-2],i=r[c-1];return i+(t-h)/(this.frames[e]-h)*(this.frames[e+s]-i)}},xn=class extends Bn{constructor(t,e,s){super(t,e,[s])}getFrameEntries(){return 2}setFrame(t,e,s){t<<=1,this.frames[t]=e,this.frames[t+1]=s}getCurveValue(t){const e=this.frames;let s=e.length-2;for(let r=2;r<=s;r+=2)if(e[r]>t){s=r-2;break}const n=this.curves[s>>1];switch(n){case 0:const r=e[s],c=e[s+1];return c+(t-r)/(e[s+2]-r)*(e[s+2+1]-c);case 1:return e[s+1]}return this.getBezierValue(t,s,1,n-2)}getRelativeValue(t,e,s,n,r){if(t<this.frames[0]){switch(s){case 0:return r;case 1:return n+(r-n)*e}return n}let c=this.getCurveValue(t);switch(s){case 0:return r+c*e;case 1:case 2:c+=r-n}return n+c*e}getAbsoluteValue(t,e,s,n,r){if(t<this.frames[0]){switch(s){case 0:return r;case 1:return n+(r-n)*e}return n}const c=this.getCurveValue(t);return s==0?r+(c-r)*e:n+(c-n)*e}getAbsoluteValue2(t,e,s,n,r,c){if(t<this.frames[0]){switch(s){case 0:return r;case 1:return n+(r-n)*e}return n}return s==0?r+(c-r)*e:n+(c-n)*e}getScaleValue(t,e,s,n,r,c){const h=this.frames;if(t<h[0]){switch(s){case 0:return c;case 1:return r+(c-r)*e}return r}const i=this.getCurveValue(t)*c;if(e==1)return s==3?r+i-c:i;if(n==1)switch(s){case 0:return c+(Math.abs(i)*st.signum(c)-c)*e;case 1:case 2:return r+(Math.abs(i)*st.signum(r)-r)*e}else{let a=0;switch(s){case 0:return a=Math.abs(c)*st.signum(i),a+(i-a)*e;case 1:case 2:return a=Math.abs(r)*st.signum(i),a+(i-a)*e}}return r+(i-c)*e}},pl=class extends Bn{constructor(t,e,s,n){super(t,e,[s,n])}getFrameEntries(){return 3}setFrame(t,e,s,n){t*=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n}},Eo=class extends xn{constructor(t,e,s){super(t,e,`${Tt.rotate}|${s}`),Ct(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];i.active&&(i.rotation=this.getRelativeValue(s,r,c,i.rotation,i.data.rotation))}},hh=class extends pl{constructor(t,e,s){super(t,e,`${Tt.x}|${s}`,`${Tt.y}|${s}`),Ct(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case 0:i.x=i.data.x,i.y=i.data.y;return;case 1:i.x+=(i.data.x-i.x)*r,i.y+=(i.data.y-i.y)*r}return}let o=0,d=0;const f=ne.search(a,s,3),m=this.curves[f/3];switch(m){case 0:const l=a[f];o=a[f+1],d=a[f+2];const g=(s-l)/(a[f+3]-l);o+=(a[f+3+1]-o)*g,d+=(a[f+3+2]-d)*g;break;case 1:o=a[f+1],d=a[f+2];break;default:o=this.getBezierValue(s,f,1,m-2),d=this.getBezierValue(s,f,2,m+18-2)}switch(c){case 0:i.x=i.data.x+o*r,i.y=i.data.y+d*r;break;case 1:case 2:i.x+=(i.data.x+o-i.x)*r,i.y+=(i.data.y+d-i.y)*r;break;case 3:i.x+=o*r,i.y+=d*r}}},dh=class extends xn{constructor(t,e,s){super(t,e,`${Tt.x}|${s}`),Ct(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];i.active&&(i.x=this.getRelativeValue(s,r,c,i.x,i.data.x))}},uh=class extends xn{constructor(t,e,s){super(t,e,`${Tt.y}|${s}`),Ct(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];i.active&&(i.y=this.getRelativeValue(s,r,c,i.y,i.data.y))}},fh=class extends pl{constructor(t,e,s){super(t,e,`${Tt.scaleX}|${s}`,`${Tt.scaleY}|${s}`),Ct(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case 0:i.scaleX=i.data.scaleX,i.scaleY=i.data.scaleY;return;case 1:i.scaleX+=(i.data.scaleX-i.scaleX)*r,i.scaleY+=(i.data.scaleY-i.scaleY)*r}return}let o,d;const f=ne.search(a,s,3),m=this.curves[f/3];switch(m){case 0:const l=a[f];o=a[f+1],d=a[f+2];const g=(s-l)/(a[f+3]-l);o+=(a[f+3+1]-o)*g,d+=(a[f+3+2]-d)*g;break;case 1:o=a[f+1],d=a[f+2];break;default:o=this.getBezierValue(s,f,1,m-2),d=this.getBezierValue(s,f,2,m+18-2)}if(o*=i.data.scaleX,d*=i.data.scaleY,r==1)c==3?(i.scaleX+=o-i.data.scaleX,i.scaleY+=d-i.data.scaleY):(i.scaleX=o,i.scaleY=d);else{let l=0,g=0;if(h==1)switch(c){case 0:l=i.data.scaleX,g=i.data.scaleY,i.scaleX=l+(Math.abs(o)*st.signum(l)-l)*r,i.scaleY=g+(Math.abs(d)*st.signum(g)-g)*r;break;case 1:case 2:l=i.scaleX,g=i.scaleY,i.scaleX=l+(Math.abs(o)*st.signum(l)-l)*r,i.scaleY=g+(Math.abs(d)*st.signum(g)-g)*r;break;case 3:i.scaleX+=(o-i.data.scaleX)*r,i.scaleY+=(d-i.data.scaleY)*r}else switch(c){case 0:l=Math.abs(i.data.scaleX)*st.signum(o),g=Math.abs(i.data.scaleY)*st.signum(d),i.scaleX=l+(o-l)*r,i.scaleY=g+(d-g)*r;break;case 1:case 2:l=Math.abs(i.scaleX)*st.signum(o),g=Math.abs(i.scaleY)*st.signum(d),i.scaleX=l+(o-l)*r,i.scaleY=g+(d-g)*r;break;case 3:i.scaleX+=(o-i.data.scaleX)*r,i.scaleY+=(d-i.data.scaleY)*r}}}},mh=class extends xn{constructor(t,e,s){super(t,e,`${Tt.scaleX}|${s}`),Ct(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];i.active&&(i.scaleX=this.getScaleValue(s,r,c,h,i.scaleX,i.data.scaleX))}},gh=class extends xn{constructor(t,e,s){super(t,e,`${Tt.scaleY}|${s}`),Ct(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];i.active&&(i.scaleY=this.getScaleValue(s,r,c,h,i.scaleY,i.data.scaleY))}},ph=class extends pl{constructor(t,e,s){super(t,e,`${Tt.shearX}|${s}`,`${Tt.shearY}|${s}`),Ct(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case 0:i.shearX=i.data.shearX,i.shearY=i.data.shearY;return;case 1:i.shearX+=(i.data.shearX-i.shearX)*r,i.shearY+=(i.data.shearY-i.shearY)*r}return}let o=0,d=0;const f=ne.search(a,s,3),m=this.curves[f/3];switch(m){case 0:const l=a[f];o=a[f+1],d=a[f+2];const g=(s-l)/(a[f+3]-l);o+=(a[f+3+1]-o)*g,d+=(a[f+3+2]-d)*g;break;case 1:o=a[f+1],d=a[f+2];break;default:o=this.getBezierValue(s,f,1,m-2),d=this.getBezierValue(s,f,2,m+18-2)}switch(c){case 0:i.shearX=i.data.shearX+o*r,i.shearY=i.data.shearY+d*r;break;case 1:case 2:i.shearX+=(i.data.shearX+o-i.shearX)*r,i.shearY+=(i.data.shearY+d-i.shearY)*r;break;case 3:i.shearX+=o*r,i.shearY+=d*r}}},bh=class extends xn{constructor(t,e,s){super(t,e,`${Tt.shearX}|${s}`),Ct(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];i.active&&(i.shearX=this.getRelativeValue(s,r,c,i.shearX,i.data.shearX))}},xh=class extends xn{constructor(t,e,s){super(t,e,`${Tt.shearY}|${s}`),Ct(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];i.active&&(i.shearY=this.getRelativeValue(s,r,c,i.shearY,i.data.shearY))}};class wh extends ne{constructor(t,e){super(t,[`${Tt.transformMode}|${e}`]),Ct(this,"boneIndex",0),this.boneIndex=e}getFrameEntries(){return 2}setFrame(t,e,s){t*=2,this.frames[t]=e,this.frames[t+1]=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;if(h==1){c==0&&(i.transformMode=i.data.transformMode);return}const a=this.frames;if(s<a[0]){(c==0||c==1)&&(i.transformMode=i.data.transformMode);return}i.transformMode=this.frames[ne.search(a,s,2)+1]}}let yh=class extends Bn{constructor(t,e,s){super(t,e,[`${Tt.rgb}|${s}`,`${Tt.alpha}|${s}`]),Ct(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 5}setFrame(t,e,s,n,r,c){t*=5,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=c}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color;if(s<a[0]){const y=i.data.color;switch(c){case 0:o.setFromColor(y);return;case 1:o.add((y.r-o.r)*r,(y.g-o.g)*r,(y.b-o.b)*r,(y.a-o.a)*r)}return}let d=0,f=0,m=0,l=0;const g=ne.search(a,s,5),p=this.curves[g/5];switch(p){case 0:const y=a[g];d=a[g+1],f=a[g+2],m=a[g+3],l=a[g+4];const w=(s-y)/(a[g+5]-y);d+=(a[g+5+1]-d)*w,f+=(a[g+5+2]-f)*w,m+=(a[g+5+3]-m)*w,l+=(a[g+5+4]-l)*w;break;case 1:d=a[g+1],f=a[g+2],m=a[g+3],l=a[g+4];break;default:d=this.getBezierValue(s,g,1,p-2),f=this.getBezierValue(s,g,2,p+18-2),m=this.getBezierValue(s,g,3,p+18*2-2),l=this.getBezierValue(s,g,4,p+18*3-2)}r==1?o.set(d,f,m,l):(c==0&&o.setFromColor(i.data.color),o.add((d-o.r)*r,(f-o.g)*r,(m-o.b)*r,(l-o.a)*r))}},Sh=class extends Bn{constructor(t,e,s){super(t,e,[`${Tt.rgb}|${s}`]),Ct(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 4}setFrame(t,e,s,n,r){t<<=2,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color;if(s<a[0]){const p=i.data.color;switch(c){case 0:o.r=p.r,o.g=p.g,o.b=p.b;return;case 1:o.r+=(p.r-o.r)*r,o.g+=(p.g-o.g)*r,o.b+=(p.b-o.b)*r}return}let d=0,f=0,m=0;const l=ne.search(a,s,4),g=this.curves[l>>2];switch(g){case 0:const p=a[l];d=a[l+1],f=a[l+2],m=a[l+3];const y=(s-p)/(a[l+4]-p);d+=(a[l+4+1]-d)*y,f+=(a[l+4+2]-f)*y,m+=(a[l+4+3]-m)*y;break;case 1:d=a[l+1],f=a[l+2],m=a[l+3];break;default:d=this.getBezierValue(s,l,1,g-2),f=this.getBezierValue(s,l,2,g+18-2),m=this.getBezierValue(s,l,3,g+18*2-2)}if(r==1)o.r=d,o.g=f,o.b=m;else{if(c==0){const p=i.data.color;o.r=p.r,o.g=p.g,o.b=p.b}o.r+=(d-o.r)*r,o.g+=(f-o.g)*r,o.b+=(m-o.b)*r}}},Ch=class extends xn{constructor(t,e,s){super(t,e,`${Tt.alpha}|${s}`),Ct(this,"slotIndex",0),this.slotIndex=s}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.color;if(s<this.frames[0]){const d=i.data.color;switch(c){case 0:a.a=d.a;return;case 1:a.a+=(d.a-a.a)*r}return}const o=this.getCurveValue(s);r==1?a.a=o:(c==0&&(a.a=i.data.color.a),a.a+=(o-a.a)*r)}},Ah=class extends Bn{constructor(t,e,s){super(t,e,[`${Tt.rgb}|${s}`,`${Tt.alpha}|${s}`,`${Tt.rgb2}|${s}`]),Ct(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 8}setFrame(t,e,s,n,r,c,h,i,a){t<<=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=c,this.frames[t+5]=h,this.frames[t+6]=i,this.frames[t+7]=a}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color,d=i.darkColor;if(s<a[0]){const S=i.data.color,C=i.data.darkColor;switch(c){case 0:o.setFromColor(S),d.r=C.r,d.g=C.g,d.b=C.b;return;case 1:o.add((S.r-o.r)*r,(S.g-o.g)*r,(S.b-o.b)*r,(S.a-o.a)*r),d.r+=(C.r-d.r)*r,d.g+=(C.g-d.g)*r,d.b+=(C.b-d.b)*r}return}let f=0,m=0,l=0,g=0,p=0,y=0,w=0;const b=ne.search(a,s,8),x=this.curves[b>>3];switch(x){case 0:const S=a[b];f=a[b+1],m=a[b+2],l=a[b+3],g=a[b+4],p=a[b+5],y=a[b+6],w=a[b+7];const C=(s-S)/(a[b+8]-S);f+=(a[b+8+1]-f)*C,m+=(a[b+8+2]-m)*C,l+=(a[b+8+3]-l)*C,g+=(a[b+8+4]-g)*C,p+=(a[b+8+5]-p)*C,y+=(a[b+8+6]-y)*C,w+=(a[b+8+7]-w)*C;break;case 1:f=a[b+1],m=a[b+2],l=a[b+3],g=a[b+4],p=a[b+5],y=a[b+6],w=a[b+7];break;default:f=this.getBezierValue(s,b,1,x-2),m=this.getBezierValue(s,b,2,x+18-2),l=this.getBezierValue(s,b,3,x+18*2-2),g=this.getBezierValue(s,b,4,x+18*3-2),p=this.getBezierValue(s,b,5,x+18*4-2),y=this.getBezierValue(s,b,6,x+18*5-2),w=this.getBezierValue(s,b,7,x+18*6-2)}if(r==1)o.set(f,m,l,g),d.r=p,d.g=y,d.b=w;else{if(c==0){o.setFromColor(i.data.color);const S=i.data.darkColor;d.r=S.r,d.g=S.g,d.b=S.b}o.add((f-o.r)*r,(m-o.g)*r,(l-o.b)*r,(g-o.a)*r),d.r+=(p-d.r)*r,d.g+=(y-d.g)*r,d.b+=(w-d.b)*r}}},vh=class extends Bn{constructor(t,e,s){super(t,e,[`${Tt.rgb}|${s}`,`${Tt.rgb2}|${s}`]),Ct(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 7}setFrame(t,e,s,n,r,c,h,i){t*=7,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=c,this.frames[t+5]=h,this.frames[t+6]=i}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color,d=i.darkColor;if(s<a[0]){const x=i.data.color,S=i.data.darkColor;switch(c){case 0:o.r=x.r,o.g=x.g,o.b=x.b,d.r=S.r,d.g=S.g,d.b=S.b;return;case 1:o.r+=(x.r-o.r)*r,o.g+=(x.g-o.g)*r,o.b+=(x.b-o.b)*r,d.r+=(S.r-d.r)*r,d.g+=(S.g-d.g)*r,d.b+=(S.b-d.b)*r}return}let f=0,m=0,l=0,g=0,p=0,y=0;const w=ne.search(a,s,7),b=this.curves[w/7];switch(b){case 0:const x=a[w];f=a[w+1],m=a[w+2],l=a[w+3],g=a[w+4],p=a[w+5],y=a[w+6];const S=(s-x)/(a[w+7]-x);f+=(a[w+7+1]-f)*S,m+=(a[w+7+2]-m)*S,l+=(a[w+7+3]-l)*S,g+=(a[w+7+4]-g)*S,p+=(a[w+7+5]-p)*S,y+=(a[w+7+6]-y)*S;break;case 1:f=a[w+1],m=a[w+2],l=a[w+3],g=a[w+4],p=a[w+5],y=a[w+6];break;default:f=this.getBezierValue(s,w,1,b-2),m=this.getBezierValue(s,w,2,b+18-2),l=this.getBezierValue(s,w,3,b+18*2-2),g=this.getBezierValue(s,w,4,b+18*3-2),p=this.getBezierValue(s,w,5,b+18*4-2),y=this.getBezierValue(s,w,6,b+18*5-2)}if(r==1)o.r=f,o.g=m,o.b=l,d.r=g,d.g=p,d.b=y;else{if(c==0){const x=i.data.color,S=i.data.darkColor;o.r=x.r,o.g=x.g,o.b=x.b,d.r=S.r,d.g=S.g,d.b=S.b}o.r+=(f-o.r)*r,o.g+=(m-o.g)*r,o.b+=(l-o.b)*r,d.r+=(g-d.r)*r,d.g+=(p-d.g)*r,d.b+=(y-d.b)*r}}},oa=class extends ne{constructor(t,e){super(t,[`${Tt.attachment}|${e}`]),Ct(this,"slotIndex",0),Ct(this,"attachmentNames"),this.slotIndex=e,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.attachmentNames[t]=s}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(i.bone.active){if(h==1){c==0&&this.setAttachment(t,i,i.data.attachmentName);return}if(s<this.frames[0]){(c==0||c==1)&&this.setAttachment(t,i,i.data.attachmentName);return}this.setAttachment(t,i,this.attachmentNames[ne.search1(this.frames,s)])}}setAttachment(t,e,s){e.setAttachment(s?t.getAttachment(this.slotIndex,s):null)}},Mh=class extends Bn{constructor(t,e,s,n){super(t,e,[`${Tt.deform}|${s}|${n.id}`]),Ct(this,"slotIndex",0),Ct(this,"attachment"),Ct(this,"vertices"),this.slotIndex=s,this.attachment=n,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.vertices[t]=s}setBezier(t,e,s,n,r,c,h,i,a,o,d){const f=this.curves;let m=this.getFrameCount()+t*18;s==0&&(f[e]=2+m);const l=(n-c*2+i)*.03,g=a*.03-h*.06,p=((c-i)*3-n+o)*.006,y=(h-a+.33333333)*.018;let w=l*2+p,b=g*2+y,x=(c-n)*.3+l+p*.16666667,S=h*.3+g+y*.16666667,C=n+x,A=S;for(let v=m+18;m<v;m+=2)f[m]=C,f[m+1]=A,x+=w,S+=b,w+=p,b+=y,C+=x,A+=S}getCurvePercent(t,e){const s=this.curves;let n=s[e];switch(n){case 0:const i=this.frames[e];return(t-i)/(this.frames[e+this.getFrameEntries()]-i);case 1:return 0}if(n-=2,s[n]>t){const i=this.frames[e];return s[n+1]*(t-i)/(s[n]-i)}const r=n+18;for(n+=2;n<r;n+=2)if(s[n]>=t){const i=s[n-2],a=s[n-1];return a+(t-i)/(s[n]-i)*(s[n+1]-a)}const c=s[r-2],h=s[r-1];return h+(1-h)*(t-c)/(this.frames[e+this.getFrameEntries()]-c)}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.getAttachment();if(!a||!(a instanceof hr)||a.timelineAttachment!=this.attachment)return;const o=i.deform;o.length==0&&(c=0);const d=this.vertices,f=d[0].length,m=this.frames;if(s<m[0]){switch(c){case 0:o.length=0;return;case 1:if(r==1){o.length=0;return}o.length=f;const w=a;if(w.bones){r=1-r;for(let b=0;b<f;b++)o[b]*=r}else{const b=w.vertices;for(let x=0;x<f;x++)o[x]+=(b[x]-o[x])*r}}return}if(o.length=f,s>=m[m.length-1]){const w=d[m.length-1];if(r==1)if(c==3){const b=a;if(b.bones)for(let x=0;x<f;x++)o[x]+=w[x];else{const x=b.vertices;for(let S=0;S<f;S++)o[S]+=w[S]-x[S]}}else nt.arrayCopy(w,0,o,0,f);else switch(c){case 0:{const x=a;if(x.bones)for(let S=0;S<f;S++)o[S]=w[S]*r;else{const S=x.vertices;for(let C=0;C<f;C++){const A=S[C];o[C]=A+(w[C]-A)*r}}break}case 1:case 2:for(let x=0;x<f;x++)o[x]+=(w[x]-o[x])*r;break;case 3:const b=a;if(b.bones)for(let x=0;x<f;x++)o[x]+=w[x]*r;else{const x=b.vertices;for(let S=0;S<f;S++)o[S]+=(w[S]-x[S])*r}}return}const l=ne.search1(m,s),g=this.getCurvePercent(s,l),p=d[l],y=d[l+1];if(r==1)if(c==3){const w=a;if(w.bones)for(let b=0;b<f;b++){const x=p[b];o[b]+=x+(y[b]-x)*g}else{const b=w.vertices;for(let x=0;x<f;x++){const S=p[x];o[x]+=S+(y[x]-S)*g-b[x]}}}else for(let w=0;w<f;w++){const b=p[w];o[w]=b+(y[w]-b)*g}else switch(c){case 0:{const b=a;if(b.bones)for(let x=0;x<f;x++){const S=p[x];o[x]=(S+(y[x]-S)*g)*r}else{const x=b.vertices;for(let S=0;S<f;S++){const C=p[S],A=x[S];o[S]=A+(C+(y[S]-C)*g-A)*r}}break}case 1:case 2:for(let b=0;b<f;b++){const x=p[b];o[b]+=(x+(y[b]-x)*g-o[b])*r}break;case 3:const w=a;if(w.bones)for(let b=0;b<f;b++){const x=p[b];o[b]+=(x+(y[b]-x)*g)*r}else{const b=w.vertices;for(let x=0;x<f;x++){const S=p[x];o[x]+=(S+(y[x]-S)*g-b[x])*r}}}}};const nm=class yp extends ne{constructor(t){super(t,yp.propertyIds),Ct(this,"events"),this.events=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,s,n,r,c,h){if(!n)return;const i=this.frames,a=this.frames.length;if(e>s)this.apply(t,e,Number.MAX_VALUE,n,r,c,h),e=-1;else if(e>=i[a-1])return;if(s<i[0])return;let o=0;if(e<i[0])o=0;else{o=ne.search1(i,e)+1;const d=i[o];for(;o>0&&i[o-1]==d;)o--}for(;o<a&&s>=i[o];o++)n.push(this.events[o])}};Ct(nm,"propertyIds",[`${Tt.event}`]);let bl=nm;const rm=class Sp extends ne{constructor(t){super(t,Sp.propertyIds),Ct(this,"drawOrders"),this.drawOrders=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.drawOrders[t]=s}apply(t,e,s,n,r,c,h){if(h==1){c==0&&nt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}if(s<this.frames[0]){(c==0||c==1)&&nt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const i=ne.search1(this.frames,s),a=this.drawOrders[i];if(!a)nt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);else{const o=t.drawOrder,d=t.slots;for(let f=0,m=a.length;f<m;f++)o[f]=d[a[f]]}}};Ct(rm,"propertyIds",[`${Tt.drawOrder}`]);let Ra=rm,Eh=class extends Bn{constructor(t,e,s){super(t,e,[`${Tt.ikConstraint}|${s}`]),Ct(this,"constraintIndex",0),this.constraintIndex=s}getFrameEntries(){return 6}setFrame(t,e,s,n,r,c,h){t*=6,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=c?1:0,this.frames[t+5]=h?1:0}apply(t,e,s,n,r,c,h){const i=t.ikConstraints[this.constraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case 0:i.mix=i.data.mix,i.softness=i.data.softness,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch;return;case 1:i.mix+=(i.data.mix-i.mix)*r,i.softness+=(i.data.softness-i.softness)*r,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch}return}let o=0,d=0;const f=ne.search(a,s,6),m=this.curves[f/6];switch(m){case 0:const l=a[f];o=a[f+1],d=a[f+2];const g=(s-l)/(a[f+6]-l);o+=(a[f+6+1]-o)*g,d+=(a[f+6+2]-d)*g;break;case 1:o=a[f+1],d=a[f+2];break;default:o=this.getBezierValue(s,f,1,m-2),d=this.getBezierValue(s,f,2,m+18-2)}c==0?(i.mix=i.data.mix+(o-i.data.mix)*r,i.softness=i.data.softness+(d-i.data.softness)*r,h==1?(i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch):(i.bendDirection=a[f+3],i.compress=a[f+4]!=0,i.stretch=a[f+5]!=0)):(i.mix+=(o-i.mix)*r,i.softness+=(d-i.softness)*r,h==0&&(i.bendDirection=a[f+3],i.compress=a[f+4]!=0,i.stretch=a[f+5]!=0))}},Th=class extends Bn{constructor(t,e,s){super(t,e,[`${Tt.transformConstraint}|${s}`]),Ct(this,"constraintIndex",0),this.constraintIndex=s}getFrameEntries(){return 7}setFrame(t,e,s,n,r,c,h,i){const a=this.frames;t*=7,a[t]=e,a[t+1]=s,a[t+2]=n,a[t+3]=r,a[t+4]=c,a[t+5]=h,a[t+6]=i}apply(t,e,s,n,r,c,h){const i=t.transformConstraints[this.constraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){const w=i.data;switch(c){case 0:i.mixRotate=w.mixRotate,i.mixX=w.mixX,i.mixY=w.mixY,i.mixScaleX=w.mixScaleX,i.mixScaleY=w.mixScaleY,i.mixShearY=w.mixShearY;return;case 1:i.mixRotate+=(w.mixRotate-i.mixRotate)*r,i.mixX+=(w.mixX-i.mixX)*r,i.mixY+=(w.mixY-i.mixY)*r,i.mixScaleX+=(w.mixScaleX-i.mixScaleX)*r,i.mixScaleY+=(w.mixScaleY-i.mixScaleY)*r,i.mixShearY+=(w.mixShearY-i.mixShearY)*r}return}let o,d,f,m,l,g;const p=ne.search(a,s,7),y=this.curves[p/7];switch(y){case 0:const w=a[p];o=a[p+1],d=a[p+2],f=a[p+3],m=a[p+4],l=a[p+5],g=a[p+6];const b=(s-w)/(a[p+7]-w);o+=(a[p+7+1]-o)*b,d+=(a[p+7+2]-d)*b,f+=(a[p+7+3]-f)*b,m+=(a[p+7+4]-m)*b,l+=(a[p+7+5]-l)*b,g+=(a[p+7+6]-g)*b;break;case 1:o=a[p+1],d=a[p+2],f=a[p+3],m=a[p+4],l=a[p+5],g=a[p+6];break;default:o=this.getBezierValue(s,p,1,y-2),d=this.getBezierValue(s,p,2,y+18-2),f=this.getBezierValue(s,p,3,y+18*2-2),m=this.getBezierValue(s,p,4,y+18*3-2),l=this.getBezierValue(s,p,5,y+18*4-2),g=this.getBezierValue(s,p,6,y+18*5-2)}if(c==0){const w=i.data;i.mixRotate=w.mixRotate+(o-w.mixRotate)*r,i.mixX=w.mixX+(d-w.mixX)*r,i.mixY=w.mixY+(f-w.mixY)*r,i.mixScaleX=w.mixScaleX+(m-w.mixScaleX)*r,i.mixScaleY=w.mixScaleY+(l-w.mixScaleY)*r,i.mixShearY=w.mixShearY+(g-w.mixShearY)*r}else i.mixRotate+=(o-i.mixRotate)*r,i.mixX+=(d-i.mixX)*r,i.mixY+=(f-i.mixY)*r,i.mixScaleX+=(m-i.mixScaleX)*r,i.mixScaleY+=(l-i.mixScaleY)*r,i.mixShearY+=(g-i.mixShearY)*r}},Ih=class extends xn{constructor(t,e,s){super(t,e,`${Tt.pathConstraintPosition}|${s}`),Ct(this,"constraintIndex",0),this.constraintIndex=s}apply(t,e,s,n,r,c,h){const i=t.pathConstraints[this.constraintIndex];i.active&&(i.position=this.getAbsoluteValue(s,r,c,i.position,i.data.position))}},Rh=class extends xn{constructor(t,e,s){super(t,e,`${Tt.pathConstraintSpacing}|${s}`),Ct(this,"constraintIndex",0),this.constraintIndex=s}apply(t,e,s,n,r,c,h){const i=t.pathConstraints[this.constraintIndex];i.active&&(i.spacing=this.getAbsoluteValue(s,r,c,i.spacing,i.data.spacing))}},Ph=class extends Bn{constructor(t,e,s){super(t,e,[`${Tt.pathConstraintMix}|${s}`]),Ct(this,"constraintIndex",0),this.constraintIndex=s}getFrameEntries(){return 4}setFrame(t,e,s,n,r){const c=this.frames;t<<=2,c[t]=e,c[t+1]=s,c[t+2]=n,c[t+3]=r}apply(t,e,s,n,r,c,h){const i=t.pathConstraints[this.constraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case 0:i.mixRotate=i.data.mixRotate,i.mixX=i.data.mixX,i.mixY=i.data.mixY;return;case 1:i.mixRotate+=(i.data.mixRotate-i.mixRotate)*r,i.mixX+=(i.data.mixX-i.mixX)*r,i.mixY+=(i.data.mixY-i.mixY)*r}return}let o,d,f;const m=ne.search(a,s,4),l=this.curves[m>>2];switch(l){case 0:const g=a[m];o=a[m+1],d=a[m+2],f=a[m+3];const p=(s-g)/(a[m+4]-g);o+=(a[m+4+1]-o)*p,d+=(a[m+4+2]-d)*p,f+=(a[m+4+3]-f)*p;break;case 1:o=a[m+1],d=a[m+2],f=a[m+3];break;default:o=this.getBezierValue(s,m,1,l-2),d=this.getBezierValue(s,m,2,l+18-2),f=this.getBezierValue(s,m,3,l+18*2-2)}if(c==0){const g=i.data;i.mixRotate=g.mixRotate+(o-g.mixRotate)*r,i.mixX=g.mixX+(d-g.mixX)*r,i.mixY=g.mixY+(f-g.mixY)*r}else i.mixRotate+=(o-i.mixRotate)*r,i.mixX+=(d-i.mixX)*r,i.mixY+=(f-i.mixY)*r}};class ui extends xn{constructor(t,e,s,n){super(t,e,`${n}|${s}`),Ct(this,"constraintIndex",0),this.constraintIndex=s}apply(t,e,s,n,r,c,h){let i;if(this.constraintIndex==-1){const a=s>=this.frames[0]?this.getCurveValue(s):0;for(const o of t.physicsConstraints)o.active&&this.global(o.data)&&this.set(o,this.getAbsoluteValue2(s,r,c,this.get(o),this.setup(o),a))}else i=t.physicsConstraints[this.constraintIndex],i.active&&this.set(i,this.getAbsoluteValue(s,r,c,this.get(i),this.setup(i)))}}class kh extends ui{constructor(t,e,s){super(t,e,s,Tt.physicsConstraintInertia)}setup(t){return t.data.inertia}get(t){return t.inertia}set(t,e){t.inertia=e}global(t){return t.inertiaGlobal}}class Fh extends ui{constructor(t,e,s){super(t,e,s,Tt.physicsConstraintStrength)}setup(t){return t.data.strength}get(t){return t.strength}set(t,e){t.strength=e}global(t){return t.strengthGlobal}}class Yh extends ui{constructor(t,e,s){super(t,e,s,Tt.physicsConstraintDamping)}setup(t){return t.data.damping}get(t){return t.damping}set(t,e){t.damping=e}global(t){return t.dampingGlobal}}class $h extends ui{constructor(t,e,s){super(t,e,s,Tt.physicsConstraintMass)}setup(t){return 1/t.data.massInverse}get(t){return 1/t.massInverse}set(t,e){t.massInverse=1/e}global(t){return t.massGlobal}}class _h extends ui{constructor(t,e,s){super(t,e,s,Tt.physicsConstraintWind)}setup(t){return t.data.wind}get(t){return t.wind}set(t,e){t.wind=e}global(t){return t.windGlobal}}class Xh extends ui{constructor(t,e,s){super(t,e,s,Tt.physicsConstraintGravity)}setup(t){return t.data.gravity}get(t){return t.gravity}set(t,e){t.gravity=e}global(t){return t.gravityGlobal}}class Bh extends ui{constructor(t,e,s){super(t,e,s,Tt.physicsConstraintMix)}setup(t){return t.data.mix}get(t){return t.mix}set(t,e){t.mix=e}global(t){return t.mixGlobal}}const im=class Cp extends ne{constructor(t,e){super(t,Cp.propertyIds),Ct(this,"constraintIndex"),this.constraintIndex=e}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e}apply(t,e,s,n,r,c,h){let i;if(this.constraintIndex!=-1&&(i=t.physicsConstraints[this.constraintIndex],!i.active))return;const a=this.frames;if(e>s)this.apply(t,e,Number.MAX_VALUE,[],r,c,h),e=-1;else if(e>=a[a.length-1])return;if(!(s<a[0])&&(e<a[0]||s>=a[ne.search1(a,e)+1]))if(i!=null)i.reset();else for(const o of t.physicsConstraints)o.active&&o.reset()}};Ct(im,"propertyIds",[Tt.physicsConstraintReset.toString()]);let Vh=im;const xl=class Ri extends ne{constructor(t,e,s){super(t,[`${Tt.sequence}|${e}|${s.sequence.id}`]),Ct(this,"slotIndex"),Ct(this,"attachment"),this.slotIndex=e,this.attachment=s}getFrameEntries(){return Ri.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(t,e,s,n,r){const c=this.frames;t*=Ri.ENTRIES,c[t]=e,c[t+Ri.MODE]=s|n<<4,c[t+Ri.DELAY]=r}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.attachment,o=this.attachment;if(a!=o&&(!(a instanceof hr)||a.timelineAttachment!=o))return;const d=this.frames;if(s<d[0]){(c==0||c==1)&&(i.sequenceIndex=-1);return}const f=ne.search(d,s,Ri.ENTRIES),m=d[f],l=d[f+Ri.MODE],g=d[f+Ri.DELAY];if(!this.attachment.sequence)return;let p=l>>4;const y=this.attachment.sequence.regions.length,w=ch[l&15];if(w!=dr.hold)switch(p+=(s-m)/g+1e-5|0,w){case dr.once:p=Math.min(y-1,p);break;case dr.loop:p%=y;break;case dr.pingpong:{const b=(y<<1)-2;p=b==0?0:p%b,p>=y&&(p=b-p);break}case dr.onceReverse:p=Math.max(y-1-p,0);break;case dr.loopReverse:p=y-1-p%y;break;case dr.pingpongReverse:{const b=(y<<1)-2;p=b==0?0:(p+y-1)%b,p>=y&&(p=b-p)}}i.sequenceIndex=p}};Ct(xl,"ENTRIES",3),Ct(xl,"MODE",1),Ct(xl,"DELAY",2);let Nh=xl;var iy=Object.defineProperty,ay=(u,t,e)=>t in u?iy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,xt=(u,t,e)=>ay(u,typeof t!="symbol"?t+"":t,e);const am=class Yl{constructor(t){xt(this,"data"),xt(this,"tracks",new Array),xt(this,"timeScale",1),xt(this,"unkeyedState",0),xt(this,"events",new Array),xt(this,"listeners",new Array),xt(this,"queue",new cm(this)),xt(this,"propertyIDs",new Kf),xt(this,"animationsChanged",!1),xt(this,"trackEntryPool",new ml(()=>new lm)),this.data=t}static emptyAnimation(){return Yl._emptyAnimation}update(t){t*=this.timeScale;const e=this.tracks;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(!r)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let c=t*r.timeScale;if(r.delay>0){if(r.delay-=c,r.delay>0)continue;c=-r.delay,r.delay=0}let h=r.next;if(h){const i=r.trackLast-h.delay;if(i>=0){for(h.delay=0,h.trackTime+=r.timeScale==0?0:(i/r.timeScale+t)*h.timeScale,r.trackTime+=c,this.setCurrent(s,h,!0);h.mixingFrom;)h.mixTime+=t,h=h.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&!r.mixingFrom){e[s]=null,this.queue.end(r),this.clearNext(r);continue}if(r.mixingFrom&&this.updateMixingFrom(r,t)){let i=r.mixingFrom;for(r.mixingFrom=null,i&&(i.mixingTo=null);i;)this.queue.end(i),i=i.mixingFrom}r.trackTime+=c}this.queue.drain()}updateMixingFrom(t,e){const s=t.mixingFrom;if(!s)return!0;const n=this.updateMixingFrom(s,e);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?((s.totalAlpha==0||t.mixDuration==0)&&(t.mixingFrom=s.mixingFrom,s.mixingFrom&&(s.mixingFrom.mixingTo=t),t.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=e*s.timeScale,t.mixTime+=e,!1)}apply(t){if(!t)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,s=this.tracks;let n=!1;for(let h=0,i=s.length;h<i;h++){const a=s[h];if(!a||a.delay>0)continue;n=!0;const o=h==0?Ae.first:a.mixBlend;let d=a.alpha;a.mixingFrom?d*=this.applyMixingFrom(a,t,o):a.trackTime>=a.trackEnd&&!a.next&&(d=0);let f=d>=a.alphaAttachmentThreshold;const m=a.animationLast,l=a.getAnimationTime();let g=l,p=e;a.reverse&&(g=a.animation.duration-g,p=null);const y=a.animation.timelines,w=y.length;if(h==0&&d==1||o==Ae.add){h==0&&(f=!0);for(let b=0;b<w;b++){nt.webkit602BugfixHelper(d,o);const x=y[b];x instanceof oa?this.applyAttachmentTimeline(x,t,g,o,f):x.apply(t,m,g,p,d,o,di.mixIn)}}else{const b=a.timelineMode,x=a.shortestRotation,S=!x&&a.timelinesRotation.length!=w<<1;S&&(a.timelinesRotation.length=w<<1);for(let C=0;C<w;C++){const A=y[C],v=b[C]==wl?o:Ae.setup;!x&&A instanceof Eo?this.applyRotateTimeline(A,t,g,d,v,a.timelinesRotation,C<<1,S):A instanceof oa?this.applyAttachmentTimeline(A,t,g,o,f):(nt.webkit602BugfixHelper(d,o),A.apply(t,m,g,p,d,v,di.mixIn))}}this.queueEvents(a,l),e.length=0,a.nextAnimationLast=l,a.nextTrackLast=a.trackTime}const r=this.unkeyedState+Oh,c=t.slots;for(let h=0,i=t.slots.length;h<i;h++){const a=c[h];if(a.attachmentState==r){const o=a.data.attachmentName;a.setAttachment(o?t.getAttachment(a.data.index,o):null)}}return this.unkeyedState+=2,this.queue.drain(),n}applyMixingFrom(t,e,s){const n=t.mixingFrom;n.mixingFrom&&this.applyMixingFrom(n,e,s);let r=0;t.mixDuration==0?(r=1,s==Ae.first&&(s=Ae.setup)):(r=t.mixTime/t.mixDuration,r>1&&(r=1),s!=Ae.first&&(s=n.mixBlend));const c=r<n.mixAttachmentThreshold,h=r<n.mixDrawOrderThreshold,i=n.animation.timelines,a=i.length,o=n.alpha*t.interruptAlpha,d=o*(1-r),f=n.animationLast,m=n.getAnimationTime();let l=m,g=null;if(n.reverse?l=n.animation.duration-l:r<n.eventThreshold&&(g=this.events),s==Ae.add)for(let p=0;p<a;p++)i[p].apply(e,f,l,g,d,s,di.mixOut);else{const p=n.timelineMode,y=n.timelineHoldMix,w=n.shortestRotation,b=!w&&n.timelinesRotation.length!=a<<1;b&&(n.timelinesRotation.length=a<<1),n.totalAlpha=0;for(let x=0;x<a;x++){const S=i[x];let C=di.mixOut,A,v=0;switch(p[x]){case wl:if(!h&&S instanceof Ra)continue;A=s,v=d;break;case Dh:A=Ae.setup,v=d;break;case Lh:A=s,v=o;break;case yl:A=Ae.setup,v=o;break;default:A=Ae.setup;const M=y[x];v=o*Math.max(0,1-M.mixTime/M.mixDuration);break}n.totalAlpha+=v,!w&&S instanceof Eo?this.applyRotateTimeline(S,e,l,v,A,n.timelinesRotation,x<<1,b):S instanceof oa?this.applyAttachmentTimeline(S,e,l,A,c&&v>=n.alphaAttachmentThreshold):(nt.webkit602BugfixHelper(v,s),h&&S instanceof Ra&&A==Ae.setup&&(C=di.mixIn),S.apply(e,f,l,g,v,A,C))}}return t.mixDuration>0&&this.queueEvents(n,m),this.events.length=0,n.nextAnimationLast=m,n.nextTrackLast=n.trackTime,r}applyAttachmentTimeline(t,e,s,n,r){const c=e.slots[t.slotIndex];c.bone.active&&(s<t.frames[0]?(n==Ae.setup||n==Ae.first)&&this.setAttachment(e,c,c.data.attachmentName,r):this.setAttachment(e,c,t.attachmentNames[ne.search1(t.frames,s)],r),c.attachmentState<=this.unkeyedState&&(c.attachmentState=this.unkeyedState+Oh))}setAttachment(t,e,s,n){e.setAttachment(s?t.getAttachment(e.data.index,s):null),n&&(e.attachmentState=this.unkeyedState+um)}applyRotateTimeline(t,e,s,n,r,c,h,i){if(i&&(c[h]=0),n==1){t.apply(e,0,s,null,1,r,di.mixIn);return}const a=e.bones[t.boneIndex];if(!a.active)return;const o=t.frames;let d=0,f=0;if(s<o[0])switch(r){case Ae.setup:a.rotation=a.data.rotation;default:return;case Ae.first:d=a.rotation,f=a.data.rotation}else d=r==Ae.setup?a.data.rotation:a.rotation,f=a.data.rotation+t.getCurveValue(s);let m=0,l=f-d;if(l-=Math.ceil(l/360-.5)*360,l==0)m=c[h];else{let g=0,p=0;i?(g=0,p=l):(g=c[h],p=c[h+1]);const y=g-g%360;m=l+y;const w=l>=0;let b=g>=0;Math.abs(p)<=90&&st.signum(p)!=st.signum(l)&&(Math.abs(g-y)>180?(m+=360*st.signum(g),b=w):y!=0?m-=360*st.signum(g):b=w),b!=w&&(m+=360*st.signum(g)),c[h]=m}c[h+1]=l,a.rotation=d+m*n}queueEvents(t,e){const s=t.animationStart,n=t.animationEnd,r=n-s,c=t.trackLast%r,h=this.events;let i=0;const a=h.length;for(;i<a;i++){const d=h[i];if(d.time<c)break;d.time>n||this.queue.event(t,d)}let o=!1;if(t.loop)if(r==0)o=!0;else{const d=Math.floor(t.trackTime/r);o=d>0&&d>Math.floor(t.trackLast/r)}else o=e>=n&&t.animationLast<n;for(o&&this.queue.complete(t);i<a;i++){const d=h[i];d.time<s||this.queue.event(t,d)}}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,s=this.tracks.length;e<s;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(!e)return;this.queue.end(e),this.clearNext(e);let s=e;for(;;){const n=s.mixingFrom;if(!n)break;this.queue.end(n),s.mixingFrom=null,s.mixingTo=null,s=n}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,s){const n=this.expandToIndex(t);this.tracks[t]=e,e.previous=null,n&&(s&&this.queue.interrupt(n),e.mixingFrom=n,n.mixingTo=e,e.mixTime=0,n.mixingFrom&&n.mixDuration>0&&(e.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,s=!1){const n=this.data.skeletonData.findAnimation(e);if(!n)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,n,s)}setAnimationWith(t,e,s=!1){if(!e)throw new Error("animation cannot be null.");let n=!0,r=this.expandToIndex(t);r&&(r.nextTrackLast==-1?(this.tracks[t]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.clearNext(r),r=r.mixingFrom,n=!1):this.clearNext(r));const c=this.trackEntry(t,e,s,r);return this.setCurrent(t,c,n),this.queue.drain(),c}addAnimation(t,e,s=!1,n=0){const r=this.data.skeletonData.findAnimation(e);if(!r)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,r,s,n)}addAnimationWith(t,e,s=!1,n=0){if(!e)throw new Error("animation cannot be null.");let r=this.expandToIndex(t);if(r)for(;r.next;)r=r.next;const c=this.trackEntry(t,e,s,r);return r?(r.next=c,c.previous=r,n<=0&&(n+=r.getTrackComplete()-c.mixDuration)):(this.setCurrent(t,c,!0),this.queue.drain()),c.delay=n,c}setEmptyAnimation(t,e=0){const s=this.setAnimationWith(t,Yl.emptyAnimation(),!1);return s.mixDuration=e,s.trackEnd=e,s}addEmptyAnimation(t,e=0,s=0){const n=this.addAnimationWith(t,Yl.emptyAnimation(),!1,s);return s<=0&&(n.delay+=n.mixDuration-e),n.mixDuration=e,n.trackEnd=e,n}setEmptyAnimations(t=0){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,n=this.tracks.length;s<n;s++){const r=this.tracks[s];r&&this.setEmptyAnimation(r.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(nt.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,s,n){const r=this.trackEntryPool.obtain();return r.reset(),r.trackIndex=t,r.animation=e,r.loop=s,r.holdPrevious=!1,r.reverse=!1,r.shortestRotation=!1,r.eventThreshold=0,r.alphaAttachmentThreshold=0,r.mixAttachmentThreshold=0,r.mixDrawOrderThreshold=0,r.animationStart=0,r.animationEnd=e.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.mixTime=0,r.mixDuration=n?this.data.getMix(n.animation,e):0,r.interruptAlpha=1,r.totalAlpha=0,r.mixBlend=Ae.replace,r}clearNext(t){let e=t.next;for(;e;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const t=this.tracks;for(let e=0,s=t.length;e<s;e++){let n=t[e];if(n){for(;n.mixingFrom;)n=n.mixingFrom;do(!n.mixingTo||n.mixBlend!=Ae.add)&&this.computeHold(n),n=n.mixingTo;while(n)}}}computeHold(t){const e=t.mixingTo,s=t.animation.timelines,n=t.animation.timelines.length,r=t.timelineMode;r.length=n;const c=t.timelineHoldMix;c.length=0;const h=this.propertyIDs;if(e&&e.holdPrevious){for(let i=0;i<n;i++)r[i]=h.addAll(s[i].getPropertyIds())?yl:Lh;return}t:for(let i=0;i<n;i++){const a=s[i],o=a.getPropertyIds();if(!h.addAll(o))r[i]=wl;else if(!e||a instanceof oa||a instanceof Ra||a instanceof bl||!e.animation.hasTimeline(o))r[i]=Dh;else{for(let d=e.mixingTo;d;d=d.mixingTo)if(!d.animation.hasTimeline(o)){if(t.mixDuration>0){r[i]=dm,c[i]=d;continue t}break}r[i]=yl}}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(!t)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}hasAnimation(t){return this.data.skeletonData.findAnimation(t)!==null}};xt(am,"_emptyAnimation",new gl("<empty>",[],0));let om=am,lm=class{constructor(){xt(this,"animation",null),xt(this,"previous",null),xt(this,"next",null),xt(this,"mixingFrom",null),xt(this,"mixingTo",null),xt(this,"listener",null),xt(this,"trackIndex",0),xt(this,"loop",!1),xt(this,"holdPrevious",!1),xt(this,"reverse",!1),xt(this,"shortestRotation",!1),xt(this,"eventThreshold",0),xt(this,"mixAttachmentThreshold",0),xt(this,"alphaAttachmentThreshold",0),xt(this,"mixDrawOrderThreshold",0),xt(this,"animationStart",0),xt(this,"animationEnd",0),xt(this,"animationLast",0),xt(this,"nextAnimationLast",0),xt(this,"delay",0),xt(this,"trackTime",0),xt(this,"trackLast",0),xt(this,"nextTrackLast",0),xt(this,"trackEnd",0),xt(this,"timeScale",0),xt(this,"alpha",0),xt(this,"mixTime",0),xt(this,"_mixDuration",0),xt(this,"interruptAlpha",0),xt(this,"totalAlpha",0),xt(this,"mixBlend",Ae.replace),xt(this,"timelineMode",new Array),xt(this,"timelineHoldMix",new Array),xt(this,"timelinesRotation",new Array)}get mixDuration(){return this._mixDuration}set mixDuration(t){this._mixDuration=t}setMixDurationWithDelay(t,e){this._mixDuration=t,this.previous!=null&&e<=0&&(e+=this.previous.getTrackComplete()-t),this.delay=e}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const t=this.animationEnd-this.animationStart;if(t!=0){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}wasApplied(){return this.nextTrackLast!=-1}isNextReady(){return this.next!=null&&this.nextTrackLast-this.next.delay>=0}},cm=class{constructor(t){xt(this,"objects",[]),xt(this,"drainDisabled",!1),xt(this,"animState"),this.animState=t}start(t){this.objects.push(0),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(1),this.objects.push(t)}end(t){this.objects.push(2),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(3),this.objects.push(t)}complete(t){this.objects.push(4),this.objects.push(t)}event(t,e){this.objects.push(5),this.objects.push(t),this.objects.push(e)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let s=0;s<t.length;s+=2){const n=t[s],r=t[s+1];switch(n){case 0:r.listener&&r.listener.start&&r.listener.start(r);for(let h=0;h<e.length;h++){const i=e[h];i.start&&i.start(r)}break;case 1:r.listener&&r.listener.interrupt&&r.listener.interrupt(r);for(let h=0;h<e.length;h++){const i=e[h];i.interrupt&&i.interrupt(r)}break;case 2:r.listener&&r.listener.end&&r.listener.end(r);for(let h=0;h<e.length;h++){const i=e[h];i.end&&i.end(r)}case 3:r.listener&&r.listener.dispose&&r.listener.dispose(r);for(let h=0;h<e.length;h++){const i=e[h];i.dispose&&i.dispose(r)}this.animState.trackEntryPool.free(r);break;case 4:r.listener&&r.listener.complete&&r.listener.complete(r);for(let h=0;h<e.length;h++){const i=e[h];i.complete&&i.complete(r)}break;case 5:const c=t[s+++2];r.listener&&r.listener.event&&r.listener.event(r,c);for(let h=0;h<e.length;h++){const i=e[h];i.event&&i.event(r,c)}break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};var hm=(u=>(u[u.start=0]="start",u[u.interrupt=1]="interrupt",u[u.end=2]="end",u[u.dispose=3]="dispose",u[u.complete=4]="complete",u[u.event=5]="event",u))(hm||{});let oy=class{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}};const wl=0,Dh=1,Lh=2,yl=3,dm=4,Oh=1,um=2;var ly=Object.defineProperty,cy=(u,t,e)=>t in u?ly(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,hy=(u,t,e)=>cy(u,typeof t!="symbol"?t+"":t,e);let Wh=class Ap extends hr{constructor(t){super(t),hy(this,"color",new Pt(1,1,1,1))}copy(){const t=new Ap(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}};var dy=Object.defineProperty,uy=(u,t,e)=>t in u?dy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,fm=(u,t,e)=>uy(u,typeof t!="symbol"?t+"":t,e);let Uh=class vp extends hr{constructor(t){super(t),fm(this,"endSlot",null),fm(this,"color",new Pt(.2275,.2275,.8078,1))}copy(){const t=new vp(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}};var fy=Object.defineProperty,my=(u,t,e)=>t in u?fy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,cn=(u,t,e)=>my(u,typeof t!="symbol"?t+"":t,e);let Sl=class Vd extends hr{constructor(t,e){super(t),cn(this,"region",null),cn(this,"path"),cn(this,"regionUVs"),cn(this,"uvs",[]),cn(this,"triangles",[]),cn(this,"color",new Pt(1,1,1,1)),cn(this,"width",0),cn(this,"height",0),cn(this,"hullLength",0),cn(this,"edges",[]),cn(this,"parentMesh",null),cn(this,"sequence",null),cn(this,"tempColor",new Pt(0,0,0,0)),this.path=e}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new Vd(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),nt.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.uvs=new Array(this.uvs.length),nt.arrayCopy(this.uvs,0,t.uvs,0,this.uvs.length),t.triangles=new Array(this.triangles.length),nt.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,t.sequence=this.sequence!=null?this.sequence.copy():null,this.edges&&(t.edges=new Array(this.edges.length),nt.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}computeWorldVertices(t,e,s,n,r,c){this.sequence!=null&&this.sequence.apply(t,this),super.computeWorldVertices(t,e,s,n,r,c)}newLinkedMesh(){const t=new Vd(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),t.timelineAttachment=this.timelineAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}};var gy=Object.defineProperty,py=(u,t,e)=>t in u?gy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Cl=(u,t,e)=>py(u,typeof t!="symbol"?t+"":t,e);let To=class Mp extends hr{constructor(t){super(t),Cl(this,"lengths",[]),Cl(this,"closed",!1),Cl(this,"constantSpeed",!1),Cl(this,"color",new Pt(1,1,1,1))}copy(){const t=new Mp(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),nt.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}};var by=Object.defineProperty,xy=(u,t,e)=>t in u?by(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Al=(u,t,e)=>xy(u,typeof t!="symbol"?t+"":t,e);let mm=class Ep extends hr{constructor(t){super(t),Al(this,"x",0),Al(this,"y",0),Al(this,"rotation",0),Al(this,"color",new Pt(.38,.94,0,1))}computeWorldPosition(t,e){return e.x=this.x*t.a+this.y*t.b+t.worldX,e.y=this.x*t.c+this.y*t.d+t.worldY,e}computeWorldRotation(t){const e=this.rotation*st.degRad,s=Math.cos(e),n=Math.sin(e),r=s*t.a+n*t.b,c=s*t.c+n*t.d;return st.atan2Deg(c,r)}copy(){const t=new Ep(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}};var wy=Object.defineProperty,yy=(u,t,e)=>t in u?wy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,St=(u,t,e)=>yy(u,typeof t!="symbol"?t+"":t,e);const Gt=class Tp extends oh{constructor(t,e){super(t),St(this,"x",0),St(this,"y",0),St(this,"scaleX",1),St(this,"scaleY",1),St(this,"rotation",0),St(this,"width",0),St(this,"height",0),St(this,"color",new Pt(1,1,1,1)),St(this,"path"),St(this,"region",null),St(this,"sequence",null),St(this,"offset",nt.newFloatArray(8)),St(this,"uvs",nt.newFloatArray(8)),St(this,"tempColor",new Pt(1,1,1,1)),this.path=e}updateRegion(){if(!this.region)throw new Error("Region not set.");const t=this.region,e=this.uvs;if(t==null){e[0]=0,e[1]=0,e[2]=0,e[3]=1,e[4]=1,e[5]=1,e[6]=1,e[7]=0;return}const s=this.width/this.region.originalWidth*this.scaleX,n=this.height/this.region.originalHeight*this.scaleY,r=-this.width/2*this.scaleX+this.region.offsetX*s,c=-this.height/2*this.scaleY+this.region.offsetY*n,h=r+this.region.width*s,i=c+this.region.height*n,a=this.rotation*st.degRad,o=Math.cos(a),d=Math.sin(a),f=this.x,m=this.y,l=r*o+f,g=r*d,p=c*o+m,y=c*d,w=h*o+f,b=h*d,x=i*o+m,S=i*d,C=this.offset;C[0]=l-y,C[1]=p+g,C[2]=l-S,C[3]=x+g,C[4]=w-S,C[5]=x+b,C[6]=w-y,C[7]=p+b,t.degrees==90?(e[0]=t.u2,e[1]=t.v2,e[2]=t.u,e[3]=t.v2,e[4]=t.u,e[5]=t.v,e[6]=t.u2,e[7]=t.v):(e[0]=t.u,e[1]=t.v2,e[2]=t.u,e[3]=t.v,e[4]=t.u2,e[5]=t.v,e[6]=t.u2,e[7]=t.v2)}computeWorldVertices(t,e,s,n){this.sequence!=null&&this.sequence.apply(t,this);const r=t.bone,c=this.offset,h=r.worldX,i=r.worldY,a=r.a,o=r.b,d=r.c,f=r.d;let m=0,l=0;m=c[0],l=c[1],e[s]=m*a+l*o+h,e[s+1]=m*d+l*f+i,s+=n,m=c[2],l=c[3],e[s]=m*a+l*o+h,e[s+1]=m*d+l*f+i,s+=n,m=c[4],l=c[5],e[s]=m*a+l*o+h,e[s+1]=m*d+l*f+i,s+=n,m=c[6],l=c[7],e[s]=m*a+l*o+h,e[s+1]=m*d+l*f+i}copy(){const t=new Tp(this.name,this.path);return t.region=this.region,t.x=this.x,t.y=this.y,t.scaleX=this.scaleX,t.scaleY=this.scaleY,t.rotation=this.rotation,t.width=this.width,t.height=this.height,nt.arrayCopy(this.uvs,0,t.uvs,0,8),nt.arrayCopy(this.offset,0,t.offset,0,8),t.color.setFromColor(this.color),t.sequence=this.sequence!=null?this.sequence.copy():null,t}};St(Gt,"X1",0),St(Gt,"Y1",1),St(Gt,"C1R",2),St(Gt,"C1G",3),St(Gt,"C1B",4),St(Gt,"C1A",5),St(Gt,"U1",6),St(Gt,"V1",7),St(Gt,"X2",8),St(Gt,"Y2",9),St(Gt,"C2R",10),St(Gt,"C2G",11),St(Gt,"C2B",12),St(Gt,"C2A",13),St(Gt,"U2",14),St(Gt,"V2",15),St(Gt,"X3",16),St(Gt,"Y3",17),St(Gt,"C3R",18),St(Gt,"C3G",19),St(Gt,"C3B",20),St(Gt,"C3A",21),St(Gt,"U3",22),St(Gt,"V3",23),St(Gt,"X4",24),St(Gt,"Y4",25),St(Gt,"C4R",26),St(Gt,"C4G",27),St(Gt,"C4B",28),St(Gt,"C4A",29),St(Gt,"U4",30),St(Gt,"V4",31);let qh=Gt;var Sy=Object.defineProperty,Cy=(u,t,e)=>t in u?Sy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ay=(u,t,e)=>Cy(u,typeof t!="symbol"?t+"":t,e);let Gh=class{constructor(t){Ay(this,"atlas"),this.atlas=t}loadSequence(t,e,s){const n=s.regions;for(let r=0,c=n.length;r<c;r++){const h=s.getPath(e,r),i=this.atlas.findRegion(h);if(i==null)throw new Error(`Region not found in atlas: ${h} (sequence: ${t})`);n[r]=i}}newRegionAttachment(t,e,s,n){const r=new qh(e,s);if(n!=null)this.loadSequence(e,s,n);else{const c=this.atlas.findRegion(s);if(!c)throw new Error(`Region not found in atlas: ${s} (region attachment: ${e})`);r.region=c}return r}newMeshAttachment(t,e,s,n){const r=new Sl(e,s);if(n!=null)this.loadSequence(e,s,n);else{const c=this.atlas.findRegion(s);if(!c)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${e})`);r.region=c}return r}newBoundingBoxAttachment(t,e){return new Wh(e)}newPathAttachment(t,e){return new To(e)}newPointAttachment(t,e){return new mm(e)}newClippingAttachment(t,e){return new Uh(e)}},Io=class{constructor(t,e,s){this.name=t,this.order=e,this.skinRequired=s}};var vy=Object.defineProperty,My=(u,t,e)=>t in u?vy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Vn=(u,t,e)=>My(u,typeof t!="symbol"?t+"":t,e);let zh=class extends Io{constructor(t){super(t,0,!1),Vn(this,"bones",new Array),Vn(this,"_target",null),Vn(this,"positionMode",0),Vn(this,"spacingMode",1),Vn(this,"rotateMode",1),Vn(this,"offsetRotation",0),Vn(this,"position",0),Vn(this,"spacing",0),Vn(this,"mixRotate",0),Vn(this,"mixX",0),Vn(this,"mixY",0)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}};var Pr=(u=>(u[u.Fixed=0]="Fixed",u[u.Percent=1]="Percent",u))(Pr||{}),qe=(u=>(u[u.Length=0]="Length",u[u.Fixed=1]="Fixed",u[u.Percent=2]="Percent",u[u.Proportional=3]="Proportional",u))(qe||{}),Pa=(u=>(u[u.Tangent=0]="Tangent",u[u.Chain=1]="Chain",u[u.ChainScale=2]="ChainScale",u))(Pa||{}),Ey=Object.defineProperty,Ty=(u,t,e)=>t in u?Ey(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ve=(u,t,e)=>Ty(u,typeof t!="symbol"?t+"":t,e);const Ro=class Pi{constructor(t,e){if(Ve(this,"data"),Ve(this,"bones"),Ve(this,"target"),Ve(this,"position",0),Ve(this,"spacing",0),Ve(this,"mixRotate",0),Ve(this,"mixX",0),Ve(this,"mixY",0),Ve(this,"spaces",new Array),Ve(this,"positions",new Array),Ve(this,"world",new Array),Ve(this,"curves",new Array),Ve(this,"lengths",new Array),Ve(this,"segments",new Array),Ve(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let n=0,r=t.bones.length;n<r;n++){const c=e.findBone(t.bones[n].name);if(!c)throw new Error(`Couldn't find bone ${t.bones[n].name}.`);this.bones.push(c)}const s=e.findSlot(t.target.name);if(!s)throw new Error(`Couldn't find target bone ${t.target.name}`);this.target=s,this.position=t.position,this.spacing=t.spacing,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY}isActive(){return this.active}setToSetupPose(){const t=this.data;this.position=t.position,this.spacing=t.spacing,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY}update(t){const e=this.target.getAttachment();if(!(e instanceof To))return;const s=this.mixRotate,n=this.mixX,r=this.mixY;if(s==0&&n==0&&r==0)return;const c=this.data,h=c.rotateMode==Pa.Tangent,i=c.rotateMode==Pa.ChainScale,a=this.bones,o=a.length,d=h?o:o+1,f=nt.setArraySize(this.spaces,d),m=i?this.lengths=nt.setArraySize(this.lengths,o):[],l=this.spacing;switch(c.spacingMode){case qe.Percent:if(i)for(let C=0,A=d-1;C<A;C++){const v=a[C],M=v.data.length,E=M*v.a,T=M*v.c;m[C]=Math.sqrt(E*E+T*T)}nt.arrayFill(f,1,d,l);break;case qe.Proportional:let x=0;for(let C=0,A=d-1;C<A;){const v=a[C],M=v.data.length;if(M<Pi.epsilon)i&&(m[C]=0),f[++C]=l;else{const E=M*v.a,T=M*v.c,R=Math.sqrt(E*E+T*T);i&&(m[C]=R),f[++C]=R,x+=R}}if(x>0){x=d/x*l;for(let C=1;C<d;C++)f[C]*=x}break;default:const S=c.spacingMode==qe.Length;for(let C=0,A=d-1;C<A;){const v=a[C],M=v.data.length;if(M<Pi.epsilon)i&&(m[C]=0),f[++C]=l;else{const E=M*v.a,T=M*v.c,R=Math.sqrt(E*E+T*T);i&&(m[C]=R),f[++C]=(S?M+l:l)*R/M}}}const g=this.computeWorldPositions(e,d,h);let p=g[0],y=g[1],w=c.offsetRotation,b=!1;if(w==0)b=c.rotateMode==Pa.Chain;else{b=!1;const x=this.target.bone;w*=x.a*x.d-x.b*x.c>0?st.degRad:-st.degRad}for(let x=0,S=3;x<o;x++,S+=3){const C=a[x];C.worldX+=(p-C.worldX)*n,C.worldY+=(y-C.worldY)*r;const A=g[S],v=g[S+1],M=A-p,E=v-y;if(i){const T=m[x];if(T!=0){const R=(Math.sqrt(M*M+E*E)/T-1)*s+1;C.a*=R,C.c*=R}}if(p=A,y=v,s>0){const T=C.a,R=C.b,k=C.c,I=C.d;let P=0,F=0,X=0;if(h?P=g[S-1]:f[x+1]==0?P=g[S+2]:P=Math.atan2(E,M),P-=Math.atan2(k,T),b){F=Math.cos(P),X=Math.sin(P);const W=C.data.length;p+=(W*(F*T-X*k)-M)*s,y+=(W*(X*T+F*k)-E)*s}else P+=w;P>st.PI?P-=st.PI2:P<-st.PI&&(P+=st.PI2),P*=s,F=Math.cos(P),X=Math.sin(P),C.a=F*T-X*k,C.b=F*R-X*I,C.c=X*T+F*k,C.d=X*R+F*I}C.updateAppliedTransform()}}computeWorldPositions(t,e,s){const n=this.target;let r=this.position;const c=this.spaces,h=nt.setArraySize(this.positions,e*3+2);let i=this.world;const a=t.closed;let o=t.worldVerticesLength,d=o/6,f=Pi.NONE;if(!t.constantSpeed){const W=t.lengths;d-=a?1:2;const Y=W[d];this.data.positionMode==Pr.Percent&&(r*=Y);let _;switch(this.data.spacingMode){case qe.Percent:_=Y;break;case qe.Proportional:_=Y/e;break;default:_=1}i=nt.setArraySize(this.world,8);for(let O=0,z=0,$=0;O<e;O++,z+=3){const N=c[O]*_;r+=N;let V=r;if(a)V%=Y,V<0&&(V+=Y),$=0;else if(V<0){f!=Pi.BEFORE&&(f=Pi.BEFORE,t.computeWorldVertices(n,2,4,i,0,2)),this.addBeforePosition(V,i,0,h,z);continue}else if(V>Y){f!=Pi.AFTER&&(f=Pi.AFTER,t.computeWorldVertices(n,o-6,4,i,0,2)),this.addAfterPosition(V-Y,i,0,h,z);continue}for(;;$++){const rt=W[$];if(!(V>rt)){if($==0)V/=rt;else{const gt=W[$-1];V=(V-gt)/(rt-gt)}break}}$!=f&&(f=$,a&&$==d?(t.computeWorldVertices(n,o-4,4,i,0,2),t.computeWorldVertices(n,0,4,i,4,2)):t.computeWorldVertices(n,$*6+2,8,i,0,2)),this.addCurvePosition(V,i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7],h,z,s||O>0&&N==0)}return h}a?(o+=2,i=nt.setArraySize(this.world,o),t.computeWorldVertices(n,2,o-4,i,0,2),t.computeWorldVertices(n,0,2,i,o-4,2),i[o-2]=i[0],i[o-1]=i[1]):(d--,o-=4,i=nt.setArraySize(this.world,o),t.computeWorldVertices(n,2,o,i,0,2));const m=nt.setArraySize(this.curves,d);let l=0,g=i[0],p=i[1],y=0,w=0,b=0,x=0,S=0,C=0,A=0,v=0,M=0,E=0,T=0,R=0,k=0,I=0;for(let W=0,Y=2;W<d;W++,Y+=6)y=i[Y],w=i[Y+1],b=i[Y+2],x=i[Y+3],S=i[Y+4],C=i[Y+5],A=(g-y*2+b)*.1875,v=(p-w*2+x)*.1875,M=((y-b)*3-g+S)*.09375,E=((w-x)*3-p+C)*.09375,T=A*2+M,R=v*2+E,k=(y-g)*.75+A+M*.16666667,I=(w-p)*.75+v+E*.16666667,l+=Math.sqrt(k*k+I*I),k+=T,I+=R,T+=M,R+=E,l+=Math.sqrt(k*k+I*I),k+=T,I+=R,l+=Math.sqrt(k*k+I*I),k+=T+M,I+=R+E,l+=Math.sqrt(k*k+I*I),m[W]=l,g=S,p=C;this.data.positionMode==Pr.Percent&&(r*=l);let P;switch(this.data.spacingMode){case qe.Percent:P=l;break;case qe.Proportional:P=l/e;break;default:P=1}const F=this.segments;let X=0;for(let W=0,Y=0,_=0,O=0;W<e;W++,Y+=3){const z=c[W]*P;r+=z;let $=r;if(a)$%=l,$<0&&($+=l),_=0;else if($<0){this.addBeforePosition($,i,0,h,Y);continue}else if($>l){this.addAfterPosition($-l,i,o-4,h,Y);continue}for(;;_++){const N=m[_];if(!($>N)){if(_==0)$/=N;else{const V=m[_-1];$=($-V)/(N-V)}break}}if(_!=f){f=_;let N=_*6;for(g=i[N],p=i[N+1],y=i[N+2],w=i[N+3],b=i[N+4],x=i[N+5],S=i[N+6],C=i[N+7],A=(g-y*2+b)*.03,v=(p-w*2+x)*.03,M=((y-b)*3-g+S)*.006,E=((w-x)*3-p+C)*.006,T=A*2+M,R=v*2+E,k=(y-g)*.3+A+M*.16666667,I=(w-p)*.3+v+E*.16666667,X=Math.sqrt(k*k+I*I),F[0]=X,N=1;N<8;N++)k+=T,I+=R,T+=M,R+=E,X+=Math.sqrt(k*k+I*I),F[N]=X;k+=T,I+=R,X+=Math.sqrt(k*k+I*I),F[8]=X,k+=T+M,I+=R+E,X+=Math.sqrt(k*k+I*I),F[9]=X,O=0}for($*=X;;O++){const N=F[O];if(!($>N)){if(O==0)$/=N;else{const V=F[O-1];$=O+($-V)/(N-V)}break}}this.addCurvePosition($*.1,g,p,y,w,b,x,S,C,h,Y,s||W>0&&z==0)}return h}addBeforePosition(t,e,s,n,r){const c=e[s],h=e[s+1],i=e[s+2]-c,a=e[s+3]-h,o=Math.atan2(a,i);n[r]=c+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addAfterPosition(t,e,s,n,r){const c=e[s+2],h=e[s+3],i=c-e[s],a=h-e[s+1],o=Math.atan2(a,i);n[r]=c+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addCurvePosition(t,e,s,n,r,c,h,i,a,o,d,f){if(t==0||isNaN(t)){o[d]=e,o[d+1]=s,o[d+2]=Math.atan2(r-s,n-e);return}const m=t*t,l=m*t,g=1-t,p=g*g,y=p*g,w=g*t,b=w*3,x=g*b,S=b*t,C=e*y+n*x+c*S+i*l,A=s*y+r*x+h*S+a*l;o[d]=C,o[d+1]=A,f&&(t<.001?o[d+2]=Math.atan2(r-s,n-e):o[d+2]=Math.atan2(A-(s*p+r*w*2+h*m),C-(e*p+n*w*2+c*m)))}};Ve(Ro,"NONE",-1),Ve(Ro,"BEFORE",-2),Ve(Ro,"AFTER",-3),Ve(Ro,"epsilon",1e-5);let gm=Ro;var Iy=Object.defineProperty,Ry=(u,t,e)=>t in u?Iy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ee=(u,t,e)=>Ry(u,typeof t!="symbol"?t+"":t,e);let Hh=class{constructor(t,e,s){if(ee(this,"data"),ee(this,"skeleton"),ee(this,"parent",null),ee(this,"children",new Array),ee(this,"x",0),ee(this,"y",0),ee(this,"rotation",0),ee(this,"scaleX",0),ee(this,"scaleY",0),ee(this,"shearX",0),ee(this,"shearY",0),ee(this,"ax",0),ee(this,"ay",0),ee(this,"arotation",0),ee(this,"ascaleX",0),ee(this,"ascaleY",0),ee(this,"ashearX",0),ee(this,"ashearY",0),ee(this,"a",0),ee(this,"b",0),ee(this,"c",0),ee(this,"d",0),ee(this,"worldY",0),ee(this,"worldX",0),ee(this,"transformMode",pe.Normal),ee(this,"sorted",!1),ee(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=s,this.setToSetupPose()}isActive(){return this.active}update(t){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,s,n,r,c,h){this.ax=t,this.ay=e,this.arotation=s,this.ascaleX=n,this.ascaleY=r,this.ashearX=c,this.ashearY=h;const i=this.parent;if(!i){const m=this.skeleton,l=m.scaleX,g=m.scaleY,p=(s+c)*st.degRad,y=(s+90+h)*st.degRad;this.a=Math.cos(p)*n*l,this.b=Math.cos(y)*r*l,this.c=Math.sin(p)*n*g,this.d=Math.sin(y)*r*g,this.worldX=t*l+m.x,this.worldY=e*g+m.y;return}let a=i.a,o=i.b,d=i.c,f=i.d;switch(this.worldX=a*t+o*e+i.worldX,this.worldY=d*t+f*e+i.worldY,this.transformMode){case pe.Normal:{const m=(s+c)*st.degRad,l=(s+90+h)*st.degRad,g=Math.cos(m)*n,p=Math.cos(l)*r,y=Math.sin(m)*n,w=Math.sin(l)*r;this.a=a*g+o*y,this.b=a*p+o*w,this.c=d*g+f*y,this.d=d*p+f*w;return}case pe.OnlyTranslation:{const m=(s+c)*st.degRad,l=(s+90+h)*st.degRad;this.a=Math.cos(m)*n,this.b=Math.cos(l)*r,this.c=Math.sin(m)*n,this.d=Math.sin(l)*r;break}case pe.NoRotationOrReflection:{const m=1/this.skeleton.scaleX,l=1/this.skeleton.scaleY;a*=m,d*=l;let g=a*a+d*d,p=0;g>1e-4?(g=Math.abs(a*f*l-o*m*d)/g,o=d*g,f=a*g,p=Math.atan2(d,a)*st.radDeg):(a=0,d=0,p=90-Math.atan2(f,o)*st.radDeg);const y=(s+c-p)*st.degRad,w=(s+h-p+90)*st.degRad,b=Math.cos(y)*n,x=Math.cos(w)*r,S=Math.sin(y)*n,C=Math.sin(w)*r;this.a=a*b-o*S,this.b=a*x-o*C,this.c=d*b+f*S,this.d=d*x+f*C;break}case pe.NoScale:case pe.NoScaleOrReflection:{s*=st.degRad;const m=Math.cos(s),l=Math.sin(s);let g=(a*m+o*l)/this.skeleton.scaleX,p=(d*m+f*l)/this.skeleton.scaleY,y=Math.sqrt(g*g+p*p);y>1e-5&&(y=1/y),g*=y,p*=y,y=Math.sqrt(g*g+p*p),this.transformMode==pe.NoScale&&a*f-o*d<0!=(this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(y=-y),s=Math.PI/2+Math.atan2(p,g);const w=Math.cos(s)*y,b=Math.sin(s)*y;c*=st.degRad,h=(90+h)*st.degRad;const x=Math.cos(c)*n,S=Math.cos(h)*r,C=Math.sin(c)*n,A=Math.sin(h)*r;this.a=g*x+w*C,this.b=g*S+w*A,this.c=p*x+b*C,this.d=p*S+b*A;break}}this.a*=this.skeleton.scaleX,this.b*=this.skeleton.scaleX,this.c*=this.skeleton.scaleY,this.d*=this.skeleton.scaleY}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY,this.transformMode=t.transformMode}updateAppliedTransform(){const t=this.parent;if(!t){this.ax=this.worldX-this.skeleton.x,this.ay=this.worldY-this.skeleton.y,this.arotation=Math.atan2(this.c,this.a)*st.radDeg,this.ascaleX=Math.sqrt(this.a*this.a+this.c*this.c),this.ascaleY=Math.sqrt(this.b*this.b+this.d*this.d),this.ashearX=0,this.ashearY=Math.atan2(this.a*this.b+this.c*this.d,this.a*this.d-this.b*this.c)*st.radDeg;return}let e=t.a,s=t.b,n=t.c,r=t.d,c=1/(e*r-s*n),h=r*c,i=s*c,a=n*c,o=e*c;const d=this.worldX-t.worldX,f=this.worldY-t.worldY;this.ax=d*h-f*i,this.ay=f*o-d*a;let m,l,g,p;if(this.transformMode==pe.OnlyTranslation)m=this.a,l=this.b,g=this.c,p=this.d;else{switch(this.transformMode){case pe.NoRotationOrReflection:{const S=Math.abs(e*r-s*n)/(e*e+n*n);s=-n*this.skeleton.scaleX*S/this.skeleton.scaleY,r=e*this.skeleton.scaleY*S/this.skeleton.scaleX,c=1/(e*r-s*n),h=r*c,i=s*c;break}case pe.NoScale:case pe.NoScaleOrReflection:const y=st.cosDeg(this.rotation),w=st.sinDeg(this.rotation);e=(e*y+s*w)/this.skeleton.scaleX,n=(n*y+r*w)/this.skeleton.scaleY;let b=Math.sqrt(e*e+n*n);b>1e-5&&(b=1/b),e*=b,n*=b,b=Math.sqrt(e*e+n*n),this.transformMode==pe.NoScale&&c<0!=(this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(b=-b);const x=st.PI/2+Math.atan2(n,e);s=Math.cos(x)*b,r=Math.sin(x)*b,c=1/(e*r-s*n),h=r*c,i=s*c,a=n*c,o=e*c}m=h*this.a-i*this.c,l=h*this.b-i*this.d,g=o*this.c-a*this.a,p=o*this.d-a*this.b}if(this.ashearX=0,this.ascaleX=Math.sqrt(m*m+g*g),this.ascaleX>1e-4){const y=m*p-l*g;this.ascaleY=y/this.ascaleX,this.ashearY=-Math.atan2(m*l+g*p,y)*st.radDeg,this.arotation=Math.atan2(g,m)*st.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(l*l+p*p),this.ashearY=0,this.arotation=90-Math.atan2(p,l)*st.radDeg}getWorldRotationX(){return Math.atan2(this.c,this.a)*st.radDeg}getWorldRotationY(){return Math.atan2(this.d,this.b)*st.radDeg}getWorldScaleX(){return Math.sqrt(this.a*this.a+this.c*this.c)}getWorldScaleY(){return Math.sqrt(this.b*this.b+this.d*this.d)}worldToLocal(t){const e=1/(this.a*this.d-this.b*this.c),s=t.x-this.worldX,n=t.y-this.worldY;return t.x=s*this.d*e-n*this.b*e,t.y=n*this.a*e-s*this.c*e,t}localToWorld(t){const e=t.x,s=t.y;return t.x=e*this.a+s*this.b+this.worldX,t.y=e*this.c+s*this.d+this.worldY,t}worldToParent(t){if(t==null)throw new Error("world cannot be null.");return this.parent==null?t:this.parent.worldToLocal(t)}parentToWorld(t){if(t==null)throw new Error("world cannot be null.");return this.parent==null?t:this.parent.localToWorld(t)}worldToLocalRotation(t){const e=st.sinDeg(t),s=st.cosDeg(t);return Math.atan2(this.a*e-this.c*s,this.d*s-this.b*e)*st.radDeg+this.rotation-this.shearX}localToWorldRotation(t){t-=this.rotation-this.shearX;const e=st.sinDeg(t),s=st.cosDeg(t);return Math.atan2(s*this.c+e*this.d,s*this.a+e*this.b)*st.radDeg}rotateWorld(t){t*=st.degRad;const e=Math.sin(t),s=Math.cos(t),n=this.a,r=this.b;this.a=s*n-e*this.c,this.b=s*r-e*this.d,this.c=e*n+s*this.c,this.d=e*r+s*this.d}};var Py=Object.defineProperty,ky=(u,t,e)=>t in u?Py(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,kr=(u,t,e)=>ky(u,typeof t!="symbol"?t+"":t,e);let pm=class{constructor(t,e){if(kr(this,"data"),kr(this,"bones"),kr(this,"target"),kr(this,"bendDirection",0),kr(this,"compress",!1),kr(this,"stretch",!1),kr(this,"mix",1),kr(this,"softness",0),kr(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let n=0;n<t.bones.length;n++){const r=e.findBone(t.bones[n].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[n].name}`);this.bones.push(r)}const s=e.findBone(t.target.name);if(!s)throw new Error(`Couldn't find bone ${t.target.name}`);this.target=s,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch}isActive(){return this.active}setToSetupPose(){const t=this.data;this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch}update(t){if(this.mix==0)return;const e=this.target,s=this.bones;switch(s.length){case 1:this.apply1(s[0],e.worldX,e.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(s[0],s[1],e.worldX,e.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,e,s,n,r,c,h){const i=t.parent;if(!i)throw new Error("IK bone must have parent.");const a=i.a;let o=i.b;const d=i.c;let f=i.d,m=-t.ashearX-t.arotation,l=0,g=0;switch(t.transformMode){case pe.OnlyTranslation:l=(e-t.worldX)*st.signum(t.skeleton.scaleX),g=(s-t.worldY)*st.signum(t.skeleton.scaleY);break;case pe.NoRotationOrReflection:const w=Math.abs(a*f-o*d)/Math.max(1e-4,a*a+d*d),b=a/t.skeleton.scaleX,x=d/t.skeleton.scaleY;o=-x*w*t.skeleton.scaleX,f=b*w*t.skeleton.scaleY,m+=Math.atan2(x,b)*st.radDeg;default:const S=e-i.worldX,C=s-i.worldY,A=a*f-o*d;Math.abs(A)<=1e-4?(l=0,g=0):(l=(S*f-C*o)/A-t.ax,g=(C*a-S*d)/A-t.ay)}m+=Math.atan2(g,l)*st.radDeg,t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let p=t.ascaleX,y=t.ascaleY;if(n||r){switch(t.transformMode){case pe.NoScale:case pe.NoScaleOrReflection:l=e-t.worldX,g=s-t.worldY}const w=t.data.length*p;if(w>1e-4){const b=l*l+g*g;if(n&&b<w*w||r&&b>w*w){const x=(Math.sqrt(b)/w-1)*h+1;p*=x,c&&(y*=x)}}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*h,p,y,t.ashearX,t.ashearY)}apply2(t,e,s,n,r,c,h,i,a){if(t.transformMode!=pe.Normal||e.transformMode!=pe.Normal)return;const o=t.ax,d=t.ay;let f=t.ascaleX,m=t.ascaleY,l=f,g=m,p=e.ascaleX,y=0,w=0,b=0;f<0?(f=-f,y=180,b=-1):(y=0,b=1),m<0&&(m=-m,b=-b),p<0?(p=-p,w=180):w=0;const x=e.ax;let S=0,C=0,A=0,v=t.a,M=t.b,E=t.c,T=t.d;const R=Math.abs(f-m)<=1e-4;!R||c?(S=0,C=v*x+t.worldX,A=E*x+t.worldY):(S=e.ay,C=v*x+M*S+t.worldX,A=E*x+T*S+t.worldY);const k=t.parent;if(!k)throw new Error("IK parent must itself have a parent.");v=k.a,M=k.b,E=k.c,T=k.d;let I=v*T-M*E,P=C-k.worldX,F=A-k.worldY;I=Math.abs(I)<=1e-4?0:1/I;const X=(P*T-F*M)*I-o,W=(F*v-P*E)*I-d,Y=Math.sqrt(X*X+W*W);let _=e.data.length*p,O,z;if(Y<1e-4){this.apply1(t,s,n,!1,c,!1,a),e.updateWorldTransformWith(x,S,0,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY);return}P=s-k.worldX,F=n-k.worldY;let $=(P*T-F*M)*I-o,N=(F*v-P*E)*I-d,V=$*$+N*N;if(i!=0){i*=f*(p+1)*.5;const yt=Math.sqrt(V),lt=yt-Y-_*f+i;if(lt>0){let At=Math.min(1,lt/(i*2))-1;At=(lt-i*(1-At*At))/yt,$-=At*$,N-=At*N,V=$*$+N*N}}t:if(R){_*=f;let yt=(V-Y*Y-_*_)/(2*Y*_);yt<-1?(yt=-1,z=Math.PI*r):yt>1?(yt=1,z=0,c&&(v=(Math.sqrt(V)/(Y+_)-1)*a+1,l*=v,h&&(g*=v))):z=Math.acos(yt)*r,v=Y+_*yt,M=_*Math.sin(z),O=Math.atan2(N*v-$*M,$*v+N*M)}else{v=f*_,M=m*_;const yt=v*v,lt=M*M,At=Math.atan2(N,$);E=lt*Y*Y+yt*V-yt*lt;const Ot=-2*lt*Y,ie=lt-yt;if(T=Ot*Ot-4*ie*E,T>=0){let He=Math.sqrt(T);Ot<0&&(He=-He),He=-(Ot+He)*.5;let Qt=He/ie;const $s=E/He,xr=Math.abs(Qt)<Math.abs($s)?Qt:$s;if(Qt=V-xr*xr,Qt>=0){F=Math.sqrt(Qt)*r,O=At-Math.atan2(F,xr),z=Math.atan2(F/m,(xr-Y)/f);break t}}let bs=st.PI,xs=Y-v,Le=xs*xs,ze=0,ws=0,ys=Y+v,ae=ys*ys,Fe=0;E=-v*Y/(yt-lt),E>=-1&&E<=1&&(E=Math.acos(E),P=v*Math.cos(E)+Y,F=M*Math.sin(E),T=P*P+F*F,T<Le&&(bs=E,Le=T,xs=P,ze=F),T>ae&&(ws=E,ae=T,ys=P,Fe=F)),V<=(Le+ae)*.5?(O=At-Math.atan2(ze*r,xs),z=bs*r):(O=At-Math.atan2(Fe*r,ys),z=ws*r)}const rt=Math.atan2(S,x)*b;let gt=t.arotation;O=(O-rt)*st.radDeg+y-gt,O>180?O-=360:O<-180&&(O+=360),t.updateWorldTransformWith(o,d,gt+O*a,l,g,0,0),gt=e.arotation,z=((z+rt)*st.radDeg-e.ashearX)*b+w-gt,z>180?z-=360:z<-180&&(z+=360),e.updateWorldTransformWith(x,S,gt+z*a,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}};var Fy=Object.defineProperty,Yy=(u,t,e)=>t in u?Fy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Jt=(u,t,e)=>Yy(u,typeof t!="symbol"?t+"":t,e);class bm{constructor(t,e){Jt(this,"data"),Jt(this,"_bone",null),Jt(this,"inertia",0),Jt(this,"strength",0),Jt(this,"damping",0),Jt(this,"massInverse",0),Jt(this,"wind",0),Jt(this,"gravity",0),Jt(this,"mix",0),Jt(this,"_reset",!0),Jt(this,"ux",0),Jt(this,"uy",0),Jt(this,"cx",0),Jt(this,"cy",0),Jt(this,"tx",0),Jt(this,"ty",0),Jt(this,"xOffset",0),Jt(this,"xVelocity",0),Jt(this,"yOffset",0),Jt(this,"yVelocity",0),Jt(this,"rotateOffset",0),Jt(this,"rotateVelocity",0),Jt(this,"scaleOffset",0),Jt(this,"scaleVelocity",0),Jt(this,"active",!1),Jt(this,"skeleton"),Jt(this,"remaining",0),Jt(this,"lastTime",0),this.data=t,this.skeleton=e,this.bone=e.bones[t.bone.index],this.inertia=t.inertia,this.strength=t.strength,this.damping=t.damping,this.massInverse=t.massInverse,this.wind=t.wind,this.gravity=t.gravity,this.mix=t.mix}set bone(t){this._bone=t}get bone(){if(this._bone)return this._bone;throw new Error("Bone not set.")}reset(){this.remaining=0,this.lastTime=this.skeleton.time,this._reset=!0,this.xOffset=0,this.xVelocity=0,this.yOffset=0,this.yVelocity=0,this.rotateOffset=0,this.rotateVelocity=0,this.scaleOffset=0,this.scaleVelocity=0}setToSetupPose(){const t=this.data;this.inertia=t.inertia,this.strength=t.strength,this.damping=t.damping,this.massInverse=t.massInverse,this.wind=t.wind,this.gravity=t.gravity,this.mix=t.mix}isActive(){return this.active}update(t){const e=this.mix;if(e==0)return;const s=this.data.x>0,n=this.data.y>0,r=this.data.rotate>0||this.data.shearX>0,c=this.data.scaleX>0,h=this.bone,i=h.data.length;switch(t){case li.none:return;case li.reset:this.reset();case li.update:const a=this.skeleton,o=Math.max(this.skeleton.time-this.lastTime,0);this.remaining+=o,this.lastTime=a.time;const d=h.worldX,f=h.worldY;if(this._reset)this._reset=!1,this.ux=d,this.uy=f;else{let m=this.remaining;const l=this.inertia,g=this.data.step,p=this.skeleton.data.referenceScale;let y=-1,w=this.data.limit*o;const b=w*Math.abs(a.scaleY);if(w*=Math.abs(a.scaleX),s||n){if(s){const x=(this.ux-d)*l;this.xOffset+=x>w?w:x<-w?-w:x,this.ux=d}if(n){const x=(this.uy-f)*l;this.yOffset+=x>b?b:x<-b?-b:x,this.uy=f}if(m>=g){y=Math.pow(this.damping,60*g);const x=this.massInverse*g,S=this.strength,C=this.wind*p,A=(vl.yDown?-this.gravity:this.gravity)*p;do s&&(this.xVelocity+=(C-this.xOffset*S)*x,this.xOffset+=this.xVelocity*g,this.xVelocity*=y),n&&(this.yVelocity-=(A+this.yOffset*S)*x,this.yOffset+=this.yVelocity*g,this.yVelocity*=y),m-=g;while(m>=g)}s&&(h.worldX+=this.xOffset*e*this.data.x),n&&(h.worldY+=this.yOffset*e*this.data.y)}if(r||c){const x=Math.atan2(h.c,h.a);let S=0,C=0,A=0,v=this.cx-h.worldX,M=this.cy-h.worldY;if(v>w?v=w:v<-w&&(v=-w),M>b?M=b:M<-b&&(M=-b),r){A=(this.data.rotate+this.data.shearX)*e;let E=Math.atan2(M+this.ty,v+this.tx)-x-this.rotateOffset*A;this.rotateOffset+=(E-Math.ceil(E*st.invPI2-.5)*st.PI2)*l,E=this.rotateOffset*A+x,S=Math.cos(E),C=Math.sin(E),c&&(E=i*h.getWorldScaleX(),E>0&&(this.scaleOffset+=(v*S+M*C)*l/E))}else{S=Math.cos(x),C=Math.sin(x);const E=i*h.getWorldScaleX();E>0&&(this.scaleOffset+=(v*S+M*C)*l/E)}if(m=this.remaining,m>=g){y==-1&&(y=Math.pow(this.damping,60*g));const E=this.massInverse*g,T=this.strength,R=this.wind,k=vl.yDown?-this.gravity:this.gravity,I=i/p;for(;;)if(m-=g,c&&(this.scaleVelocity+=(R*S-k*C-this.scaleOffset*T)*E,this.scaleOffset+=this.scaleVelocity*g,this.scaleVelocity*=y),r){if(this.rotateVelocity-=((R*C+k*S)*I+this.rotateOffset*T)*E,this.rotateOffset+=this.rotateVelocity*g,this.rotateVelocity*=y,m<g)break;const P=this.rotateOffset*A+x;S=Math.cos(P),C=Math.sin(P)}else if(m<g)break}}this.remaining=m}this.cx=h.worldX,this.cy=h.worldY;break;case li.pose:s&&(h.worldX+=this.xOffset*e*this.data.x),n&&(h.worldY+=this.yOffset*e*this.data.y)}if(r){let a=this.rotateOffset*e,o=0,d=0,f=0;if(this.data.shearX>0){let m=0;this.data.rotate>0&&(m=a*this.data.rotate,o=Math.sin(m),d=Math.cos(m),f=h.b,h.b=d*f-o*h.d,h.d=o*f+d*h.d),m+=a*this.data.shearX,o=Math.sin(m),d=Math.cos(m),f=h.a,h.a=d*f-o*h.c,h.c=o*f+d*h.c}else a*=this.data.rotate,o=Math.sin(a),d=Math.cos(a),f=h.a,h.a=d*f-o*h.c,h.c=o*f+d*h.c,f=h.b,h.b=d*f-o*h.d,h.d=o*f+d*h.d}if(c){const a=1+this.scaleOffset*e*this.data.scaleX;h.a*=a,h.c*=a}t!=li.pose&&(this.tx=i*h.a,this.ty=i*h.c),h.updateAppliedTransform()}translate(t,e){this.ux-=t,this.uy-=e,this.cx-=t,this.cy-=e}rotate(t,e,s){const n=s*st.degRad,r=Math.cos(n),c=Math.sin(n),h=this.cx-t,i=this.cy-e;this.translate(h*r-i*c-h,h*c+i*r-i)}}var $y=Object.defineProperty,_y=(u,t,e)=>t in u?$y(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Fr=(u,t,e)=>_y(u,typeof t!="symbol"?t+"":t,e);let xm=class{constructor(t,e){if(Fr(this,"blendMode"),Fr(this,"data"),Fr(this,"bone"),Fr(this,"color"),Fr(this,"darkColor",null),Fr(this,"attachment",null),Fr(this,"attachmentState",0),Fr(this,"sequenceIndex",-1),Fr(this,"deform",new Array),!t)throw new Error("data cannot be null.");if(!e)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new Pt,this.darkColor=t.darkColor?new Pt:null,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&((!(t instanceof hr)||!(this.attachment instanceof hr)||t.timelineAttachment!=this.attachment.timelineAttachment)&&(this.deform.length=0),this.attachment=t,this.sequenceIndex=-1)}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName?(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName))):this.attachment=null}};var Xy=Object.defineProperty,By=(u,t,e)=>t in u?Xy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Nn=(u,t,e)=>By(u,typeof t!="symbol"?t+"":t,e);let wm=class{constructor(t,e){if(Nn(this,"data"),Nn(this,"bones"),Nn(this,"target"),Nn(this,"mixRotate",0),Nn(this,"mixX",0),Nn(this,"mixY",0),Nn(this,"mixScaleX",0),Nn(this,"mixScaleY",0),Nn(this,"mixShearY",0),Nn(this,"temp",new ah),Nn(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let n=0;n<t.bones.length;n++){const r=e.findBone(t.bones[n].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[n].name}.`);this.bones.push(r)}const s=e.findBone(t.target.name);if(!s)throw new Error(`Couldn't find target bone ${t.target.name}.`);this.target=s,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY}isActive(){return this.active}setToSetupPose(){const t=this.data;this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY}update(t){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleY==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,c=this.mixShearY,h=e!=0||s!=0,i=this.target,a=i.a,o=i.b,d=i.c,f=i.d,m=a*f-o*d>0?st.degRad:-st.degRad,l=this.data.offsetRotation*m,g=this.data.offsetShearY*m,p=this.bones;for(let y=0,w=p.length;y<w;y++){const b=p[y];if(t!=0){const x=b.a,S=b.b,C=b.c,A=b.d;let v=Math.atan2(d,a)-Math.atan2(C,x)+l;v>st.PI?v-=st.PI2:v<-st.PI&&(v+=st.PI2),v*=t;const M=Math.cos(v),E=Math.sin(v);b.a=M*x-E*C,b.b=M*S-E*A,b.c=E*x+M*C,b.d=E*S+M*A}if(h){const x=this.temp;i.localToWorld(x.set(this.data.offsetX,this.data.offsetY)),b.worldX+=(x.x-b.worldX)*e,b.worldY+=(x.y-b.worldY)*s}if(n!=0){let x=Math.sqrt(b.a*b.a+b.c*b.c);x!=0&&(x=(x+(Math.sqrt(a*a+d*d)-x+this.data.offsetScaleX)*n)/x),b.a*=x,b.c*=x}if(r!=0){let x=Math.sqrt(b.b*b.b+b.d*b.d);x!=0&&(x=(x+(Math.sqrt(o*o+f*f)-x+this.data.offsetScaleY)*r)/x),b.b*=x,b.d*=x}if(c>0){const x=b.b,S=b.d,C=Math.atan2(S,x);let A=Math.atan2(f,o)-Math.atan2(d,a)-(C-Math.atan2(b.c,b.a));A>st.PI?A-=st.PI2:A<-st.PI&&(A+=st.PI2),A=C+(A+g)*c;const v=Math.sqrt(x*x+S*S);b.b=Math.cos(A)*v,b.d=Math.sin(A)*v}b.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,c=this.mixShearY,h=e!=0||s!=0,i=this.target,a=i.a,o=i.b,d=i.c,f=i.d,m=a*f-o*d>0?st.degRad:-st.degRad,l=this.data.offsetRotation*m,g=this.data.offsetShearY*m,p=this.bones;for(let y=0,w=p.length;y<w;y++){const b=p[y];if(t!=0){const x=b.a,S=b.b,C=b.c,A=b.d;let v=Math.atan2(d,a)+l;v>st.PI?v-=st.PI2:v<-st.PI&&(v+=st.PI2),v*=t;const M=Math.cos(v),E=Math.sin(v);b.a=M*x-E*C,b.b=M*S-E*A,b.c=E*x+M*C,b.d=E*S+M*A}if(h){const x=this.temp;i.localToWorld(x.set(this.data.offsetX,this.data.offsetY)),b.worldX+=x.x*e,b.worldY+=x.y*s}if(n!=0){const x=(Math.sqrt(a*a+d*d)-1+this.data.offsetScaleX)*n+1;b.a*=x,b.c*=x}if(r!=0){const x=(Math.sqrt(o*o+f*f)-1+this.data.offsetScaleY)*r+1;b.b*=x,b.d*=x}if(c>0){let x=Math.atan2(f,o)-Math.atan2(d,a);x>st.PI?x-=st.PI2:x<-st.PI&&(x+=st.PI2);const S=b.b,C=b.d;x=Math.atan2(C,S)+(x-st.PI/2+g)*c;const A=Math.sqrt(S*S+C*C);b.b=Math.cos(x)*A,b.d=Math.sin(x)*A}b.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,c=this.mixShearY,h=this.target,i=this.bones;for(let a=0,o=i.length;a<o;a++){const d=i[a];let f=d.arotation;t!=0&&(f+=(h.arotation-f+this.data.offsetRotation)*t);let m=d.ax,l=d.ay;m+=(h.ax-m+this.data.offsetX)*e,l+=(h.ay-l+this.data.offsetY)*s;let g=d.ascaleX,p=d.ascaleY;n!=0&&g!=0&&(g=(g+(h.ascaleX-g+this.data.offsetScaleX)*n)/g),r!=0&&p!=0&&(p=(p+(h.ascaleY-p+this.data.offsetScaleY)*r)/p);let y=d.ashearY;c!=0&&(y+=(h.ashearY-y+this.data.offsetShearY)*c),d.updateWorldTransformWith(m,l,f,g,p,d.ashearX,y)}}applyRelativeLocal(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,c=this.mixShearY,h=this.target,i=this.bones;for(let a=0,o=i.length;a<o;a++){const d=i[a],f=d.arotation+(h.arotation+this.data.offsetRotation)*t,m=d.ax+(h.ax+this.data.offsetX)*e,l=d.ay+(h.ay+this.data.offsetY)*s,g=d.ascaleX*((h.ascaleX-1+this.data.offsetScaleX)*n+1),p=d.ascaleY*((h.ascaleY-1+this.data.offsetScaleY)*r+1),y=d.ashearY+(h.ashearY+this.data.offsetShearY)*c;d.updateWorldTransformWith(m,l,f,g,p,d.ashearX,y)}}};var Vy=Object.defineProperty,Ny=(u,t,e)=>t in u?Vy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ge=(u,t,e)=>Ny(u,typeof t!="symbol"?t+"":t,e);const Kh=class Nd{constructor(t){if(Ge(this,"data"),Ge(this,"bones"),Ge(this,"slots"),Ge(this,"drawOrder"),Ge(this,"ikConstraints"),Ge(this,"transformConstraints"),Ge(this,"pathConstraints"),Ge(this,"physicsConstraints"),Ge(this,"_updateCache",new Array),Ge(this,"skin",null),Ge(this,"color"),Ge(this,"scaleX",1),Ge(this,"_scaleY",1),Ge(this,"x",0),Ge(this,"y",0),Ge(this,"time",0),!t)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const s=t.bones[e];let n;if(!s.parent)n=new Hh(s,this,null);else{const r=this.bones[s.parent.index];n=new Hh(s,this,r),r.children.push(n)}this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const s=t.slots[e],n=this.bones[s.boneData.index],r=new xm(s,n);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const s=t.ikConstraints[e];this.ikConstraints.push(new pm(s,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const s=t.transformConstraints[e];this.transformConstraints.push(new wm(s,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const s=t.pathConstraints[e];this.pathConstraints.push(new gm(s,this))}this.physicsConstraints=new Array,console.log("data ",t,t.physicsConstraints);for(let e=0;e<t.physicsConstraints.length;e++){const s=t.physicsConstraints[e];this.physicsConstraints.push(new bm(s,this))}this.color=new Pt(1,1,1,1),this.updateCache()}get scaleY(){return Nd.yDown?-this._scaleY:this._scaleY}set scaleY(t){this._scaleY=t}updateCache(){const t=this._updateCache;t.length=0;const e=this.bones;for(let f=0,m=e.length;f<m;f++){const l=e[f];l.sorted=l.data.skinRequired,l.active=!l.sorted}if(this.skin){const f=this.skin.bones;for(let m=0,l=this.skin.bones.length;m<l;m++){let g=this.bones[f[m].index];do g.sorted=!1,g.active=!0,g=g.parent;while(g)}}const s=this.ikConstraints,n=this.transformConstraints,r=this.pathConstraints,c=this.physicsConstraints,h=s.length,i=n.length,a=r.length,o=this.physicsConstraints.length,d=h+i+a+o;t:for(let f=0;f<d;f++){for(let m=0;m<h;m++){const l=s[m];if(l.data.order==f){this.sortIkConstraint(l);continue t}}for(let m=0;m<i;m++){const l=n[m];if(l.data.order==f){this.sortTransformConstraint(l);continue t}}for(let m=0;m<a;m++){const l=r[m];if(l.data.order==f){this.sortPathConstraint(l);continue t}}for(let m=0;m<o;m++){const l=c[m];if(l.data.order==f){this.sortPhysicsConstraint(l);continue t}}}for(let f=0,m=e.length;f<m;f++)this.sortBone(e[f])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&nt.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target;this.sortBone(e);const s=t.bones,n=s[0];if(this.sortBone(n),s.length==1)this._updateCache.push(t),this.sortReset(n.children);else{const r=s[s.length-1];this.sortBone(r),this._updateCache.push(t),this.sortReset(n.children),r.sorted=!0}}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||this.skin&&nt.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target,s=e.data.index,n=e.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,s,n),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,n);for(let i=0,a=this.data.skins.length;i<a;i++)this.sortPathConstraintAttachment(this.data.skins[i],s,n);const r=e.getAttachment();r instanceof To&&this.sortPathConstraintAttachmentWith(r,n);const c=t.bones,h=c.length;for(let i=0;i<h;i++)this.sortBone(c[i]);this._updateCache.push(t);for(let i=0;i<h;i++)this.sortReset(c[i].children);for(let i=0;i<h;i++)c[i].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&nt.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);const e=t.bones,s=e.length;if(t.data.local)for(let n=0;n<s;n++){const r=e[n];this.sortBone(r.parent),this.sortBone(r)}else for(let n=0;n<s;n++)this.sortBone(e[n]);this._updateCache.push(t);for(let n=0;n<s;n++)this.sortReset(e[n].children);for(let n=0;n<s;n++)e[n].sorted=!0}sortPathConstraintAttachment(t,e,s){const n=t.attachments[e];if(n)for(const r in n)this.sortPathConstraintAttachmentWith(n[r],s)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof To))return;const s=t.bones;if(!s)this.sortBone(e);else{const n=this.bones;for(let r=0,c=s.length;r<c;){let h=s[r++];for(h+=r;r<h;)this.sortBone(n[s[r++]])}}}sortPhysicsConstraint(t){const e=t.bone;t.active=e.active&&(!t.data.skinRequired||this.skin!=null&&nt.contains(this.skin.constraints,t.data,!0)),t.active&&(this.sortBone(e),this._updateCache.push(t),this.sortReset(e.children),e.sorted=!0)}sortBone(t){if(!t||t.sorted)return;const e=t.parent;e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,s=t.length;e<s;e++){const n=t[e];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(t){if(t==null)throw new Error("physics is undefined");const e=this.bones;for(let n=0,r=e.length;n<r;n++){const c=e[n];c.ax=c.x,c.ay=c.y,c.arotation=c.rotation,c.ascaleX=c.scaleX,c.ascaleY=c.scaleY,c.ashearX=c.shearX,c.ashearY=c.shearY}const s=this._updateCache;for(let n=0,r=s.length;n<r;n++)s[n].update(t)}updateWorldTransformWith(t,e){const s=this.getRootBone();if(!s)throw new Error("Root bone must not be null.");const n=e.a,r=e.b,c=e.c,h=e.d;s.worldX=n*this.x+r*this.y+e.worldX,s.worldY=c*this.x+h*this.y+e.worldY;const i=(s.rotation+s.shearX)*st.degRad,a=(s.rotation+90+s.shearY)*st.degRad,o=Math.cos(i)*s.scaleX,d=Math.cos(a)*s.scaleY,f=Math.sin(i)*s.scaleX,m=Math.sin(a)*s.scaleY;s.a=(n*o+r*f)*this.scaleX,s.b=(n*d+r*m)*this.scaleX,s.c=(c*o+h*f)*this.scaleY,s.d=(c*d+h*m)*this.scaleY;const l=this._updateCache;for(let g=0,p=l.length;g<p;g++){const y=l[g];y!=s&&y.update(t)}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){for(const t of this.bones)t.setToSetupPose();for(const t of this.ikConstraints)t.setToSetupPose();for(const t of this.transformConstraints)t.setToSetupPose();for(const t of this.pathConstraints)t.setToSetupPose();for(const t of this.physicsConstraints)t.setToSetupPose()}setSlotsToSetupPose(){const t=this.slots;nt.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,s=t.length;e<s;e++)t[e].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(!e)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(t)if(this.skin)t.attachAll(this,this.skin);else{const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s],c=r.data.attachmentName;if(c){const h=t.getAttachment(s,c);h&&r.setAttachment(h)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){const s=this.data.findSlot(t);if(!s)throw new Error(`Can't find slot with name ${t}`);return this.getAttachment(s.index,e)}getAttachment(t,e){if(!e)throw new Error("attachmentName cannot be null.");if(this.skin){const s=this.skin.getAttachment(t,e);if(s)return s}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(!t)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,r=s.length;n<r;n++){const c=s[n];if(c.data.name==t){let h=null;if(e&&(h=this.getAttachment(n,e),!h))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);c.setAttachment(h);return}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){var e;if(!t)throw new Error("constraintName cannot be null.");return(e=this.ikConstraints.find(s=>s.data.name==t))!=null?e:null}findTransformConstraint(t){var e;if(!t)throw new Error("constraintName cannot be null.");return(e=this.transformConstraints.find(s=>s.data.name==t))!=null?e:null}findPathConstraint(t){var e;if(!t)throw new Error("constraintName cannot be null.");return(e=this.pathConstraints.find(s=>s.data.name==t))!=null?e:null}findPhysicsConstraint(t){var e;if(t==null)throw new Error("constraintName cannot be null.");return(e=this.physicsConstraints.find(s=>s.data.name==t))!=null?e:null}getBoundsRect(){const t=new ah,e=new ah;return this.getBounds(t,e),{x:t.x,y:t.y,width:e.x,height:e.y}}getBounds(t,e,s=new Array(2),n=null){if(!t)throw new Error("offset cannot be null.");if(!e)throw new Error("size cannot be null.");const r=this.drawOrder;let c=Number.POSITIVE_INFINITY,h=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,a=Number.NEGATIVE_INFINITY;for(let o=0,d=r.length;o<d;o++){const f=r[o];if(!f.bone.active)continue;let m=0,l=null,g=null;const p=f.getAttachment();if(p instanceof qh)m=8,l=nt.setArraySize(s,m,0),p.computeWorldVertices(f,l,0,2),g=Nd.quadTriangles;else if(p instanceof Sl){const y=p;m=y.worldVerticesLength,l=nt.setArraySize(s,m,0),y.computeWorldVertices(f,0,m,l,0,2),g=y.triangles}else if(p instanceof Uh&&n!=null){n.clipStart(f,p);continue}if(l&&g){n!=null&&n.isClipping()&&(n.clipTriangles(l,g,g.length),l=n.clippedVertices,m=n.clippedVertices.length);for(let y=0,w=l.length;y<w;y+=2){const b=l[y],x=l[y+1];c=Math.min(c,b),h=Math.min(h,x),i=Math.max(i,b),a=Math.max(a,x)}}n!=null&&n.clipEndWithSlot(f)}n!=null&&n.clipEnd(),t.set(c,h),e.set(i-c,a-h)}update(t){this.time+=t}physicsTranslate(t,e){const s=this.physicsConstraints;for(let n=0,r=s.length;n<r;n++)s[n].translate(t,e)}physicsRotate(t,e,s){const n=this.physicsConstraints;for(let r=0,c=n.length;r<c;r++)n[r].rotate(t,e,s)}};Ge(Kh,"quadTriangles",[0,1,2,2,3,0]),Ge(Kh,"yDown",!1);let vl=Kh;typeof Math.fround=="undefined"&&(Math.fround=function(u){return function(t){return u[0]=t,u[0]}}(new Float32Array(1)));var Dy=Object.defineProperty,Ly=(u,t,e)=>t in u?Dy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Es=(u,t,e)=>Ly(u,typeof t!="symbol"?t+"":t,e);let Zh=class{constructor(t,e,s){if(Es(this,"index",0),Es(this,"name"),Es(this,"parent",null),Es(this,"length",0),Es(this,"x",0),Es(this,"y",0),Es(this,"rotation",0),Es(this,"scaleX",1),Es(this,"scaleY",1),Es(this,"shearX",0),Es(this,"shearY",0),Es(this,"transformMode",pe.Normal),Es(this,"skinRequired",!1),Es(this,"color",new Pt),Es(this,"icon"),Es(this,"visible",!1),t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=s}};var Oy=Object.defineProperty,Wy=(u,t,e)=>t in u?Oy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,la=(u,t,e)=>Wy(u,typeof t!="symbol"?t+"":t,e);let Qh=class{constructor(t,e){if(la(this,"data"),la(this,"intValue",0),la(this,"floatValue",0),la(this,"stringValue",null),la(this,"time",0),la(this,"volume",0),la(this,"balance",0),!e)throw new Error("data cannot be null.");this.time=t,this.data=e}};var Uy=Object.defineProperty,qy=(u,t,e)=>t in u?Uy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ca=(u,t,e)=>qy(u,typeof t!="symbol"?t+"":t,e);let Jh=class{constructor(t){ca(this,"name"),ca(this,"intValue",0),ca(this,"floatValue",0),ca(this,"stringValue",null),ca(this,"audioPath",null),ca(this,"volume",0),ca(this,"balance",0),this.name=t}};var Gy=Object.defineProperty,zy=(u,t,e)=>t in u?Gy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,fi=(u,t,e)=>zy(u,typeof t!="symbol"?t+"":t,e);let jh=class extends Io{constructor(t){super(t,0,!1),fi(this,"bones",new Array),fi(this,"_target",null),fi(this,"bendDirection",0),fi(this,"compress",!1),fi(this,"stretch",!1),fi(this,"uniform",!1),fi(this,"mix",0),fi(this,"softness",0)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}};var Hy=Object.defineProperty,Ky=(u,t,e)=>t in u?Hy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,be=(u,t,e)=>Ky(u,typeof t!="symbol"?t+"":t,e);class td extends Io{constructor(t){super(t,0,!1),be(this,"_bone",null),be(this,"x",0),be(this,"y",0),be(this,"rotate",0),be(this,"scaleX",0),be(this,"shearX",0),be(this,"limit",0),be(this,"step",0),be(this,"inertia",0),be(this,"strength",0),be(this,"damping",0),be(this,"massInverse",0),be(this,"wind",0),be(this,"gravity",0),be(this,"mix",0),be(this,"inertiaGlobal",!1),be(this,"strengthGlobal",!1),be(this,"dampingGlobal",!1),be(this,"massGlobal",!1),be(this,"windGlobal",!1),be(this,"gravityGlobal",!1),be(this,"mixGlobal",!1)}set bone(t){this._bone=t}get bone(){if(this._bone)return this._bone;throw new Error("BoneData not set.")}}var Zy=Object.defineProperty,Qy=(u,t,e)=>t in u?Zy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ve=(u,t,e)=>Qy(u,typeof t!="symbol"?t+"":t,e);let ed=class{constructor(){ve(this,"name",null),ve(this,"bones",new Array),ve(this,"slots",new Array),ve(this,"skins",new Array),ve(this,"defaultSkin",null),ve(this,"events",new Array),ve(this,"animations",new Array),ve(this,"ikConstraints",new Array),ve(this,"transformConstraints",new Array),ve(this,"pathConstraints",new Array),ve(this,"physicsConstraints",new Array),ve(this,"x",0),ve(this,"y",0),ve(this,"width",0),ve(this,"height",0),ve(this,"referenceScale",100),ve(this,"version",null),ve(this,"hash",null),ve(this,"fps",0),ve(this,"imagesPath",null),ve(this,"audioPath",null)}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const e=this.skins;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const e=this.events;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const e=this.animations;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPhysicsConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.physicsConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}};var Jy=Object.defineProperty,jy=(u,t,e)=>t in u?Jy(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Po=(u,t,e)=>jy(u,typeof t!="symbol"?t+"":t,e);let sd=class{constructor(t=0,e,s){this.slotIndex=t,this.name=e,this.attachment=s}},Ml=class{constructor(t){if(Po(this,"name"),Po(this,"attachments",new Array),Po(this,"bones",Array()),Po(this,"constraints",new Array),Po(this,"color",new Pt(.99607843,.61960787,.30980393,1)),!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,e,s){if(!s)throw new Error("attachment cannot be null.");const n=this.attachments;t>=n.length&&(n.length=t+1),n[t]||(n[t]={}),n[t][e]=s}addSkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];this.setAttachment(n.slotIndex,n.name,n.attachment)}}copySkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];n.attachment&&(n.attachment instanceof Sl?(n.attachment=n.attachment.newLinkedMesh(),this.setAttachment(n.slotIndex,n.name,n.attachment)):(n.attachment=n.attachment.copy(),this.setAttachment(n.slotIndex,n.name,n.attachment)))}}getAttachment(t,e){const s=this.attachments[t];return s?s[e]:null}removeAttachment(t,e){const s=this.attachments[t];s&&delete s[e]}getAttachments(){const t=new Array;for(let e=0;e<this.attachments.length;e++){const s=this.attachments[e];if(s)for(const n in s){const r=s[n];r&&t.push(new sd(e,n,r))}}return t}getAttachmentsForSlot(t,e){const s=this.attachments[t];if(s)for(const n in s){const r=s[n];r&&e.push(new sd(t,n,r))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,e){let s=0;for(let n=0;n<t.slots.length;n++){const r=t.slots[n],c=r.getAttachment();if(c&&s<e.attachments.length){const h=e.attachments[s];for(const i in h){const a=h[i];if(c==a){const o=this.getAttachment(s,i);o&&r.setAttachment(o);break}}}s++}}};var tS=Object.defineProperty,eS=(u,t,e)=>t in u?tS(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,mi=(u,t,e)=>eS(u,typeof t!="symbol"?t+"":t,e);let nd=class{constructor(t,e,s){if(mi(this,"index",0),mi(this,"name"),mi(this,"boneData"),mi(this,"color",new Pt(1,1,1,1)),mi(this,"darkColor",null),mi(this,"attachmentName",null),mi(this,"blendMode",G.BLEND_MODES.NORMAL),mi(this,"visible",!0),t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");if(!s)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=s}};var sS=Object.defineProperty,nS=(u,t,e)=>t in u?sS(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ts=(u,t,e)=>nS(u,typeof t!="symbol"?t+"":t,e);let rd=class extends Io{constructor(t){super(t,0,!1),Ts(this,"bones",new Array),Ts(this,"_target",null),Ts(this,"mixRotate",0),Ts(this,"mixX",0),Ts(this,"mixY",0),Ts(this,"mixScaleX",0),Ts(this,"mixScaleY",0),Ts(this,"mixShearY",0),Ts(this,"offsetRotation",0),Ts(this,"offsetX",0),Ts(this,"offsetY",0),Ts(this,"offsetScaleX",0),Ts(this,"offsetScaleY",0),Ts(this,"offsetShearY",0),Ts(this,"relative",!1),Ts(this,"local",!1)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}};var rS=Object.defineProperty,iS=(u,t,e)=>t in u?rS(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,gi=(u,t,e)=>iS(u,typeof t!="symbol"?t+"":t,e);let ym=class{constructor(t){gi(this,"scale",1),gi(this,"attachmentLoader"),gi(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){var o;const e=this.scale,s=new ed;s.name="";const n=new Sm(t),r=n.readInt32(),c=n.readInt32();s.hash=c==0&&r==0?null:c.toString(16)+r.toString(16),s.version=n.readString(),s.x=n.readFloat(),s.y=n.readFloat(),s.width=n.readFloat(),s.height=n.readFloat(),s.referenceScale=n.readFloat()*e;const h=n.readBoolean();h&&(s.fps=n.readFloat(),s.imagesPath=n.readString(),s.audioPath=n.readString());let i=0;i=n.readInt(!0);for(let d=0;d<i;d++){const f=n.readString();if(!f)throw new Error("String in string table must not be null.");n.strings.push(f)}i=n.readInt(!0);for(let d=0;d<i;d++){const f=n.readString();if(!f)throw new Error("Bone name must not be null.");const m=d==0?null:s.bones[n.readInt(!0)],l=new Zh(d,f,m);l.rotation=n.readFloat(),l.x=n.readFloat()*e,l.y=n.readFloat()*e,l.scaleX=n.readFloat(),l.scaleY=n.readFloat(),l.shearX=n.readFloat(),l.shearY=n.readFloat(),l.length=n.readFloat()*e,l.transformMode=n.readByte(),l.skinRequired=n.readBoolean(),h&&(Pt.rgba8888ToColor(l.color,n.readInt32()),l.icon=(o=n.readString())!=null?o:void 0,l.visible=n.readBoolean()),s.bones.push(l)}i=n.readInt(!0);for(let d=0;d<i;d++){const f=n.readString();if(!f)throw new Error("Slot name must not be null.");const m=s.bones[n.readInt(!0)],l=new nd(d,f,m);Pt.rgba8888ToColor(l.color,n.readInt32());const g=n.readInt32();g!=-1&&Pt.rgb888ToColor(l.darkColor=new Pt,g),l.attachmentName=n.readStringRef(),l.blendMode=n.readInt(!0),h&&(l.visible=n.readBoolean()),s.slots.push(l)}i=n.readInt(!0);for(let d=0,f;d<i;d++){const m=n.readString();if(!m)throw new Error("IK constraint data name must not be null.");const l=new jh(m);l.order=n.readInt(!0),f=n.readInt(!0);for(let p=0;p<f;p++)l.bones.push(s.bones[n.readInt(!0)]);l.target=s.bones[n.readInt(!0)];const g=n.readByte();l.skinRequired=(g&1)!=0,l.bendDirection=g&2?1:-1,l.compress=(g&4)!=0,l.stretch=(g&8)!=0,l.uniform=(g&16)!=0,g&32&&(l.mix=g&64?n.readFloat():1),g&128&&(l.softness=n.readFloat()*e),s.ikConstraints.push(l)}i=n.readInt(!0);for(let d=0,f;d<i;d++){const m=n.readString();if(!m)throw new Error("Transform constraint data name must not be null.");const l=new rd(m);l.order=n.readInt(!0),f=n.readInt(!0);for(let p=0;p<f;p++)l.bones.push(s.bones[n.readInt(!0)]);l.target=s.bones[n.readInt(!0)];let g=n.readByte();l.skinRequired=(g&1)!=0,l.local=(g&2)!=0,l.relative=(g&4)!=0,g&8&&(l.offsetRotation=n.readFloat()),g&16&&(l.offsetX=n.readFloat()*e),g&32&&(l.offsetY=n.readFloat()*e),g&64&&(l.offsetScaleX=n.readFloat()),g&128&&(l.offsetScaleY=n.readFloat()),g=n.readByte(),g&1&&(l.offsetShearY=n.readFloat()),g&2&&(l.mixRotate=n.readFloat()),g&4&&(l.mixX=n.readFloat()),g&8&&(l.mixY=n.readFloat()),g&16&&(l.mixScaleX=n.readFloat()),g&32&&(l.mixScaleY=n.readFloat()),g&64&&(l.mixShearY=n.readFloat()),s.transformConstraints.push(l)}i=n.readInt(!0);for(let d=0,f;d<i;d++){const m=n.readString();if(!m)throw new Error("Path constraint data name must not be null.");const l=new zh(m);l.order=n.readInt(!0),l.skinRequired=n.readBoolean(),f=n.readInt(!0);for(let p=0;p<f;p++)l.bones.push(s.bones[n.readInt(!0)]);l.target=s.slots[n.readInt(!0)];const g=n.readByte();l.positionMode=g&1,l.spacingMode=g>>1&3,l.rotateMode=g>>3&3,g&128&&(l.offsetRotation=n.readFloat()),l.position=n.readFloat(),l.positionMode==Pr.Fixed&&(l.position*=e),l.spacing=n.readFloat(),(l.spacingMode==qe.Length||l.spacingMode==qe.Fixed)&&(l.spacing*=e),l.mixRotate=n.readFloat(),l.mixX=n.readFloat(),l.mixY=n.readFloat(),s.pathConstraints.push(l)}i=n.readInt(!0);for(let d=0;d<i;d++){const f=n.readString();if(!f)throw new Error("Physics constraint data name must not be null.");const m=new td(f);m.order=n.readInt(!0),m.bone=s.bones[n.readInt(!0)];let l=n.readByte();m.skinRequired=(l&1)!=0,l&2&&(m.x=n.readFloat()),l&4&&(m.y=n.readFloat()),l&8&&(m.rotate=n.readFloat()),l&16&&(m.scaleX=n.readFloat()),l&32&&(m.shearX=n.readFloat()),m.limit=(l&64?n.readFloat():5e3)*e,m.step=1/n.readUnsignedByte(),m.inertia=n.readFloat(),m.strength=n.readFloat(),m.damping=n.readFloat(),m.massInverse=l&128?n.readFloat():1,m.wind=n.readFloat(),m.gravity=n.readFloat(),l=n.readByte(),l&1&&(m.inertiaGlobal=!0),l&2&&(m.strengthGlobal=!0),l&4&&(m.dampingGlobal=!0),l&8&&(m.massGlobal=!0),l&16&&(m.windGlobal=!0),l&32&&(m.gravityGlobal=!0),l&64&&(m.mixGlobal=!0),m.mix=l&128?n.readFloat():1,s.physicsConstraints.push(m)}const a=this.readSkin(n,s,!0,h);a&&(s.defaultSkin=a,s.skins.push(a));{let d=s.skins.length;for(nt.setArraySize(s.skins,i=d+n.readInt(!0));d<i;d++){const f=this.readSkin(n,s,!1,h);if(!f)throw new Error("readSkin() should not have returned null.");s.skins[d]=f}}i=this.linkedMeshes.length;for(let d=0;d<i;d++){const f=this.linkedMeshes[d],m=s.skins[f.skinIndex];if(!f.parent)throw new Error("Linked mesh parent must not be null");const l=m.getAttachment(f.slotIndex,f.parent);if(!l)throw new Error(`Parent mesh not found: ${f.parent}`);f.mesh.timelineAttachment=f.inheritTimeline?l:f.mesh,f.mesh.setParentMesh(l)}this.linkedMeshes.length=0,i=n.readInt(!0);for(let d=0;d<i;d++){const f=n.readString();if(!f)throw new Error("Event data name must not be null");const m=new Jh(f);m.intValue=n.readInt(!1),m.floatValue=n.readFloat(),m.stringValue=n.readString(),m.audioPath=n.readString(),m.audioPath&&(m.volume=n.readFloat(),m.balance=n.readFloat()),s.events.push(m)}i=n.readInt(!0);for(let d=0;d<i;d++){const f=n.readString();if(!f)throw new Error("Animatio name must not be null.");s.animations.push(this.readAnimation(n,f,s))}return s}readSkin(t,e,s,n){let r=null,c=0;if(s){if(c=t.readInt(!0),c==0)return null;r=new Ml("default")}else{const h=t.readString();if(!h)throw new Error("Skin name must not be null.");r=new Ml(h),n&&Pt.rgba8888ToColor(r.color,t.readInt32()),r.bones.length=t.readInt(!0);for(let i=0,a=r.bones.length;i<a;i++)r.bones[i]=e.bones[t.readInt(!0)];for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.ikConstraints[t.readInt(!0)]);for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.transformConstraints[t.readInt(!0)]);for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.pathConstraints[t.readInt(!0)]);for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.physicsConstraints[t.readInt(!0)]);c=t.readInt(!0)}for(let h=0;h<c;h++){const i=t.readInt(!0);for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readStringRef();if(!d)throw new Error("Attachment name must not be null");const f=this.readAttachment(t,e,r,i,d,n);f&&r.setAttachment(i,d,f)}}return r}readAttachment(t,e,s,n,r,c){const h=this.scale,i=t.readByte(),a=i&8?t.readStringRef():r;if(!a)throw new Error("Attachment name must not be null");switch(i&7){case 0:{let o=i&16?t.readStringRef():null;const d=i&32?t.readInt32():4294967295,f=i&64?this.readSequence(t):null,m=i&128?t.readFloat():0,l=t.readFloat(),g=t.readFloat(),p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),b=t.readFloat();o||(o=a);const x=this.attachmentLoader.newRegionAttachment(s,a,o,f);return x?(x.path=o,x.x=l*h,x.y=g*h,x.scaleX=p,x.scaleY=y,x.rotation=m,x.width=w*h,x.height=b*h,Pt.rgba8888ToColor(x.color,d),x.sequence=f,f==null&&x.updateRegion(),x):null}case 1:{const o=this.readVertices(t,(i&16)!=0),d=c?t.readInt32():0,f=this.attachmentLoader.newBoundingBoxAttachment(s,a);return f?(f.worldVerticesLength=o.length,f.vertices=o.vertices,f.bones=o.bones,c&&Pt.rgba8888ToColor(f.color,d),f):null}case 2:{let o=i&16?t.readStringRef():a;const d=i&32?t.readInt32():4294967295,f=i&64?this.readSequence(t):null,m=t.readInt(!0),l=this.readVertices(t,(i&128)!=0),g=this.readFloatArray(t,l.length,1),p=this.readShortArray(t,(l.length-m-2)*3);let y=[],w=0,b=0;c&&(y=this.readShortArray(t,t.readInt(!0)),w=t.readFloat(),b=t.readFloat()),o||(o=a);const x=this.attachmentLoader.newMeshAttachment(s,a,o,f);return x?(x.path=o,Pt.rgba8888ToColor(x.color,d),x.bones=l.bones,x.vertices=l.vertices,x.worldVerticesLength=l.length,x.triangles=p,x.regionUVs=new Float32Array(g),x.hullLength=m<<1,x.sequence=f,c&&(x.edges=y,x.width=w*h,x.height=b*h),x):null}case 3:{const o=i&16?t.readStringRef():a;if(o==null)throw new Error("Path of linked mesh must not be null");const d=i&32?t.readInt32():4294967295,f=i&64?this.readSequence(t):null,m=(i&128)!=0,l=t.readInt(!0),g=t.readStringRef();let p=0,y=0;c&&(p=t.readFloat(),y=t.readFloat());const w=this.attachmentLoader.newMeshAttachment(s,a,o,f);return w?(w.path=o,Pt.rgba8888ToColor(w.color,d),w.sequence=f,c&&(w.width=p*h,w.height=y*h),this.linkedMeshes.push(new aS(w,l,n,g,m)),w):null}case 4:{const o=(i&16)!=0,d=(i&32)!=0,f=this.readVertices(t,(i&64)!=0),m=nt.newArray(f.length/6,0);for(let p=0,y=m.length;p<y;p++)m[p]=t.readFloat()*h;const l=c?t.readInt32():0,g=this.attachmentLoader.newPathAttachment(s,a);return g?(g.closed=o,g.constantSpeed=d,g.worldVerticesLength=f.length,g.vertices=f.vertices,g.bones=f.bones,g.lengths=m,c&&Pt.rgba8888ToColor(g.color,l),g):null}case 5:{const o=t.readFloat(),d=t.readFloat(),f=t.readFloat(),m=c?t.readInt32():0,l=this.attachmentLoader.newPointAttachment(s,a);return l?(l.x=d*h,l.y=f*h,l.rotation=o,c&&Pt.rgba8888ToColor(l.color,m),l):null}case 6:{const o=t.readInt(!0),d=this.readVertices(t,(i&16)!=0),f=c?t.readInt32():0,m=this.attachmentLoader.newClippingAttachment(s,a);return m?(m.endSlot=e.slots[o],m.worldVerticesLength=d.length,m.vertices=d.vertices,m.bones=d.bones,c&&Pt.rgba8888ToColor(m.color,f),m):null}}return null}readSequence(t){const e=new lh(t.readInt(!0));return e.start=t.readInt(!0),e.digits=t.readInt(!0),e.setupIndex=t.readInt(!0),e}readVertices(t,e){const s=this.scale,n=t.readInt(!0),r=new oS;if(r.length=n<<1,!e)return r.vertices=this.readFloatArray(t,r.length,s),r;const c=new Array,h=new Array;for(let i=0;i<n;i++){const a=t.readInt(!0);h.push(a);for(let o=0;o<a;o++)h.push(t.readInt(!0)),c.push(t.readFloat()*s),c.push(t.readFloat()*s),c.push(t.readFloat())}return r.vertices=nt.toFloatArray(c),r.bones=h,r}readFloatArray(t,e,s){const n=new Array(e);if(s==1)for(let r=0;r<e;r++)n[r]=t.readFloat();else for(let r=0;r<e;r++)n[r]=t.readFloat()*s;return n}readShortArray(t,e){const s=new Array(e);for(let n=0;n<e;n++)s[n]=t.readInt(!0);return s}readAnimation(t,e,s){t.readInt(!0);const n=new Array,r=this.scale;for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0);for(let f=0,m=t.readInt(!0);f<m;f++){const l=t.readByte(),g=t.readInt(!0),p=g-1;switch(l){case wS:{const y=new oa(g,d);for(let w=0;w<g;w++)y.setFrame(w,t.readFloat(),t.readStringRef());n.push(y);break}case yS:{const y=t.readInt(!0),w=new yh(g,y,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255;for(let v=0,M=0;w.setFrame(v,b,x,S,C,A),v!=p;v++){const E=t.readFloat(),T=t.readUnsignedByte()/255,R=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255;switch(t.readByte()){case ur:w.setStepped(v);break;case fr:$t(t,w,M++,v,0,b,E,x,T,1),$t(t,w,M++,v,1,b,E,S,R,1),$t(t,w,M++,v,2,b,E,C,k,1),$t(t,w,M++,v,3,b,E,A,I,1)}b=E,x=T,S=R,C=k,A=I}n.push(w);break}case SS:{const y=t.readInt(!0),w=new Sh(g,y,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255;for(let A=0,v=0;w.setFrame(A,b,x,S,C),A!=p;A++){const M=t.readFloat(),E=t.readUnsignedByte()/255,T=t.readUnsignedByte()/255,R=t.readUnsignedByte()/255;switch(t.readByte()){case ur:w.setStepped(A);break;case fr:$t(t,w,v++,A,0,b,M,x,E,1),$t(t,w,v++,A,1,b,M,S,T,1),$t(t,w,v++,A,2,b,M,C,R,1)}b=M,x=E,S=T,C=R}n.push(w);break}case CS:{const y=t.readInt(!0),w=new Ah(g,y,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255,E=t.readUnsignedByte()/255;for(let T=0,R=0;w.setFrame(T,b,x,S,C,A,v,M,E),T!=p;T++){const k=t.readFloat(),I=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,W=t.readUnsignedByte()/255,Y=t.readUnsignedByte()/255,_=t.readUnsignedByte()/255;switch(t.readByte()){case ur:w.setStepped(T);break;case fr:$t(t,w,R++,T,0,b,k,x,I,1),$t(t,w,R++,T,1,b,k,S,P,1),$t(t,w,R++,T,2,b,k,C,F,1),$t(t,w,R++,T,3,b,k,A,X,1),$t(t,w,R++,T,4,b,k,v,W,1),$t(t,w,R++,T,5,b,k,M,Y,1),$t(t,w,R++,T,6,b,k,E,_,1)}b=k,x=I,S=P,C=F,A=X,v=W,M=Y,E=_}n.push(w);break}case AS:{const y=t.readInt(!0),w=new vh(g,y,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255;for(let E=0,T=0;w.setFrame(E,b,x,S,C,A,v,M),E!=p;E++){const R=t.readFloat(),k=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,W=t.readUnsignedByte()/255;switch(t.readByte()){case ur:w.setStepped(E);break;case fr:$t(t,w,T++,E,0,b,R,x,k,1),$t(t,w,T++,E,1,b,R,S,I,1),$t(t,w,T++,E,2,b,R,C,P,1),$t(t,w,T++,E,3,b,R,A,F,1),$t(t,w,T++,E,4,b,R,v,X,1),$t(t,w,T++,E,5,b,R,M,W,1)}b=R,x=k,S=I,C=P,A=F,v=X,M=W}n.push(w);break}case vS:{const y=new Ch(g,t.readInt(!0),d);let w=t.readFloat(),b=t.readUnsignedByte()/255;for(let x=0,S=0;y.setFrame(x,w,b),x!=p;x++){const C=t.readFloat(),A=t.readUnsignedByte()/255;switch(t.readByte()){case ur:y.setStepped(x);break;case fr:$t(t,y,S++,x,0,w,C,b,A,1)}w=C,b=A}n.push(y)}}}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0);for(let f=0,m=t.readInt(!0);f<m;f++){const l=t.readByte(),g=t.readInt(!0);if(l==xS){const y=new wh(g,d);for(let w=0;w<g;w++)y.setFrame(w,t.readFloat(),t.readByte());n.push(y);continue}const p=t.readInt(!0);switch(l){case lS:n.push(Is(t,new Eo(g,p,d),1));break;case cS:n.push(id(t,new hh(g,p,d),r));break;case hS:n.push(Is(t,new dh(g,p,d),r));break;case dS:n.push(Is(t,new uh(g,p,d),r));break;case uS:n.push(id(t,new fh(g,p,d),1));break;case fS:n.push(Is(t,new mh(g,p,d),1));break;case mS:n.push(Is(t,new gh(g,p,d),1));break;case gS:n.push(id(t,new ph(g,p,d),1));break;case pS:n.push(Is(t,new bh(g,p,d),1));break;case bS:n.push(Is(t,new xh(g,p,d),1))}}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),f=t.readInt(!0),m=f-1,l=new Eh(f,t.readInt(!0),d);let g=t.readByte(),p=t.readFloat(),y=g&1?g&2?t.readFloat():1:0,w=g&4?t.readFloat()*r:0;for(let b=0,x=0;l.setFrame(b,p,y,w,g&8?1:-1,(g&16)!=0,(g&32)!=0),b!=m;b++){g=t.readByte();const S=t.readFloat(),C=g&1?g&2?t.readFloat():1:0,A=g&4?t.readFloat()*r:0;g&64?l.setStepped(b):g&128&&($t(t,l,x++,b,0,p,S,y,C,1),$t(t,l,x++,b,1,p,S,w,A,r)),p=S,y=C,w=A}n.push(l)}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),f=t.readInt(!0),m=f-1,l=new Th(f,t.readInt(!0),d);let g=t.readFloat(),p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),b=t.readFloat(),x=t.readFloat(),S=t.readFloat();for(let C=0,A=0;l.setFrame(C,g,p,y,w,b,x,S),C!=m;C++){const v=t.readFloat(),M=t.readFloat(),E=t.readFloat(),T=t.readFloat(),R=t.readFloat(),k=t.readFloat(),I=t.readFloat();switch(t.readByte()){case ur:l.setStepped(C);break;case fr:$t(t,l,A++,C,0,g,v,p,M,1),$t(t,l,A++,C,1,g,v,y,E,1),$t(t,l,A++,C,2,g,v,w,T,1),$t(t,l,A++,C,3,g,v,b,R,1),$t(t,l,A++,C,4,g,v,x,k,1),$t(t,l,A++,C,5,g,v,S,I,1)}g=v,p=M,y=E,w=T,b=R,x=k,S=I}n.push(l)}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),f=s.pathConstraints[d];for(let m=0,l=t.readInt(!0);m<l;m++){const g=t.readByte(),p=t.readInt(!0),y=t.readInt(!0);switch(g){case TS:n.push(Is(t,new Ih(p,y,d),f.positionMode==Pr.Fixed?r:1));break;case IS:n.push(Is(t,new Rh(p,y,d),f.spacingMode==qe.Length||f.spacingMode==qe.Fixed?r:1));break;case RS:const w=new Ph(p,y,d);let b=t.readFloat(),x=t.readFloat(),S=t.readFloat(),C=t.readFloat();for(let A=0,v=0,M=w.getFrameCount()-1;w.setFrame(A,b,x,S,C),A!=M;A++){const E=t.readFloat(),T=t.readFloat(),R=t.readFloat(),k=t.readFloat();switch(t.readByte()){case ur:w.setStepped(A);break;case fr:$t(t,w,v++,A,0,b,E,x,T,1),$t(t,w,v++,A,1,b,E,S,R,1),$t(t,w,v++,A,2,b,E,C,k,1)}b=E,x=T,S=R,C=k}n.push(w)}}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0)-1;for(let f=0,m=t.readInt(!0);f<m;f++){const l=t.readByte(),g=t.readInt(!0);if(l==BS){const y=new Vh(g,d);for(let w=0;w<g;w++)y.setFrame(w,t.readFloat());n.push(y);continue}const p=t.readInt(!0);switch(l){case PS:n.push(Is(t,new kh(g,p,d),1));break;case kS:n.push(Is(t,new Fh(g,p,d),1));break;case FS:n.push(Is(t,new Yh(g,p,d),1));break;case YS:n.push(Is(t,new $h(g,p,d),1));break;case $S:n.push(Is(t,new _h(g,p,d),1));break;case _S:n.push(Is(t,new Xh(g,p,d),1));break;case XS:n.push(Is(t,new Bh(g,p,d),1))}}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=s.skins[t.readInt(!0)];for(let f=0,m=t.readInt(!0);f<m;f++){const l=t.readInt(!0);for(let g=0,p=t.readInt(!0);g<p;g++){const y=t.readStringRef();if(!y)throw new Error("attachmentName must not be null.");const w=d.getAttachment(l,y),b=t.readByte(),x=t.readInt(!0),S=x-1;switch(b){case MS:{const C=w,A=C.bones,v=C.vertices,M=A?v.length/3*2:v.length,E=t.readInt(!0),T=new Mh(x,E,l,C);let R=t.readFloat();for(let k=0,I=0;;k++){let P,F=t.readInt(!0);if(F==0)P=A?nt.newFloatArray(M):v;else{P=nt.newFloatArray(M);const W=t.readInt(!0);if(F+=W,r==1)for(let Y=W;Y<F;Y++)P[Y]=t.readFloat();else for(let Y=W;Y<F;Y++)P[Y]=t.readFloat()*r;if(!A)for(let Y=0,_=P.length;Y<_;Y++)P[Y]+=v[Y]}if(T.setFrame(k,R,P),k==S)break;const X=t.readFloat();switch(t.readByte()){case ur:T.setStepped(k);break;case fr:$t(t,T,I++,k,0,R,X,0,1,1)}R=X}n.push(T);break}case ES:{const C=new Nh(x,l,w);for(let A=0;A<x;A++){const v=t.readFloat(),M=t.readInt32();C.setFrame(A,v,ch[M&15],M>>4,t.readFloat())}n.push(C);break}}}}}const c=t.readInt(!0);if(c>0){const a=new Ra(c),o=s.slots.length;for(let d=0;d<c;d++){const f=t.readFloat(),m=t.readInt(!0),l=nt.newArray(o,0);for(let w=o-1;w>=0;w--)l[w]=-1;const g=nt.newArray(o-m,0);let p=0,y=0;for(let w=0;w<m;w++){const b=t.readInt(!0);for(;p!=b;)g[y++]=p++;l[p+t.readInt(!0)]=p++}for(;p<o;)g[y++]=p++;for(let w=o-1;w>=0;w--)l[w]==-1&&(l[w]=g[--y]);a.setFrame(d,f,l)}n.push(a)}const h=t.readInt(!0);if(h>0){const a=new bl(h);for(let o=0;o<h;o++){const d=t.readFloat(),f=s.events[t.readInt(!0)],m=new Qh(d,f);m.intValue=t.readInt(!1),m.floatValue=t.readFloat(),m.stringValue=t.readString(),m.stringValue==null&&(m.stringValue=f.stringValue),m.data.audioPath&&(m.volume=t.readFloat(),m.balance=t.readFloat()),a.setFrame(o,m)}n.push(a)}let i=0;for(let a=0,o=n.length;a<o;a++)i=Math.max(i,n[a].getDuration());return new gl(e,n,i)}},Sm=class{constructor(t,e=new Array,s=0,n=new DataView(t instanceof ArrayBuffer?t:t.buffer)){this.strings=e,this.index=s,this.buffer=n}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),s=e&127;return e&128&&(e=this.readByte(),s|=(e&127)<<7,e&128&&(e=this.readByte(),s|=(e&127)<<14,e&128&&(e=this.readByte(),s|=(e&127)<<21,e&128&&(e=this.readByte(),s|=(e&127)<<28)))),t?s:s>>>1^-(s&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let s=0;s<t;){const n=this.readUnsignedByte();switch(n>>4){case 12:case 13:e+=String.fromCharCode((n&31)<<6|this.readByte()&63),s+=2;break;case 14:e+=String.fromCharCode((n&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),s+=3;break;default:e+=String.fromCharCode(n),s++}}return e}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}},aS=class{constructor(t,e,s,n,r){gi(this,"parent"),gi(this,"skinIndex"),gi(this,"slotIndex"),gi(this,"mesh"),gi(this,"inheritTimeline"),this.mesh=t,this.skinIndex=e,this.slotIndex=s,this.parent=n,this.inheritTimeline=r}},oS=class{constructor(t=null,e=null,s=0){this.bones=t,this.vertices=e,this.length=s}};function Is(u,t,e){let s=u.readFloat(),n=u.readFloat()*e;for(let r=0,c=0,h=t.getFrameCount()-1;t.setFrame(r,s,n),r!=h;r++){const i=u.readFloat(),a=u.readFloat()*e;switch(u.readByte()){case ur:t.setStepped(r);break;case fr:$t(u,t,c++,r,0,s,i,n,a,e)}s=i,n=a}return t}function id(u,t,e){let s=u.readFloat(),n=u.readFloat()*e,r=u.readFloat()*e;for(let c=0,h=0,i=t.getFrameCount()-1;t.setFrame(c,s,n,r),c!=i;c++){const a=u.readFloat(),o=u.readFloat()*e,d=u.readFloat()*e;switch(u.readByte()){case ur:t.setStepped(c);break;case fr:$t(u,t,h++,c,0,s,a,n,o,e),$t(u,t,h++,c,1,s,a,r,d,e)}s=a,n=o,r=d}return t}function $t(u,t,e,s,n,r,c,h,i,a){t.setBezier(e,s,n,r,h,u.readFloat(),u.readFloat()*a,u.readFloat(),u.readFloat()*a,c,i)}const lS=0,cS=1,hS=2,dS=3,uS=4,fS=5,mS=6,gS=7,pS=8,bS=9,xS=10,wS=0,yS=1,SS=2,CS=3,AS=4,vS=5,MS=0,ES=1,TS=0,IS=1,RS=2,PS=0,kS=1,FS=2,YS=4,$S=5,_S=6,XS=7,BS=8,ur=1,fr=2;var VS=Object.defineProperty,NS=(u,t,e)=>t in u?VS(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,pi=(u,t,e)=>NS(u,typeof t!="symbol"?t+"":t,e);let Cm=class{constructor(t){pi(this,"attachmentLoader"),pi(this,"scale",1),pi(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){var c,h;const e=this.scale,s=new ed,n=typeof t=="string"?JSON.parse(t):t,r=n.skeleton;if(r&&(s.hash=r.hash,s.version=r.spine,s.x=r.x,s.y=r.y,s.width=r.width,s.height=r.height,s.referenceScale=B(r,"referenceScale",100)*e,s.fps=r.fps,s.imagesPath=(c=r.images)!=null?c:null,s.audioPath=(h=r.audio)!=null?h:null),n.bones)for(let i=0;i<n.bones.length;i++){const a=n.bones[i];let o=null;const d=B(a,"parent",null);d&&(o=s.findBone(d));const f=new Zh(s.bones.length,a.name,o);f.length=B(a,"length",0)*e,f.x=B(a,"x",0)*e,f.y=B(a,"y",0)*e,f.rotation=B(a,"rotation",0),f.scaleX=B(a,"scaleX",1),f.scaleY=B(a,"scaleY",1),f.shearX=B(a,"shearX",0),f.shearY=B(a,"shearY",0),f.transformMode=nt.enumValue(pe,B(a,"transformMode","Normal")),f.skinRequired=B(a,"skin",!1);const m=B(a,"color",null);m&&f.color.setFromString(m),s.bones.push(f)}if(n.slots)for(let i=0;i<n.slots.length;i++){const a=n.slots[i],o=a.name,d=s.findBone(a.bone);if(!d)throw new Error(`Couldn't find bone ${a.bone} for slot ${o}`);const f=new nd(s.slots.length,o,d),m=B(a,"color",null);m&&f.color.setFromString(m);const l=B(a,"dark",null);l&&(f.darkColor=Pt.fromString(l)),f.attachmentName=B(a,"attachment",null),f.blendMode=nt.enumValue(G.BLEND_MODES,B(a,"blend","normal")),f.visible=B(a,"visible",!0),s.slots.push(f)}if(n.ik)for(let i=0;i<n.ik.length;i++){const a=n.ik[i],o=new jh(a.name);o.order=B(a,"order",0),o.skinRequired=B(a,"skin",!1);for(let f=0;f<a.bones.length;f++){const m=s.findBone(a.bones[f]);if(!m)throw new Error(`Couldn't find bone ${a.bones[f]} for IK constraint ${a.name}.`);o.bones.push(m)}const d=s.findBone(a.target);if(!d)throw new Error(`Couldn't find target bone ${a.target} for IK constraint ${a.name}.`);o.target=d,o.mix=B(a,"mix",1),o.softness=B(a,"softness",0)*e,o.bendDirection=B(a,"bendPositive",!0)?1:-1,o.compress=B(a,"compress",!1),o.stretch=B(a,"stretch",!1),o.uniform=B(a,"uniform",!1),s.ikConstraints.push(o)}if(n.transform)for(let i=0;i<n.transform.length;i++){const a=n.transform[i],o=new rd(a.name);o.order=B(a,"order",0),o.skinRequired=B(a,"skin",!1);for(let m=0;m<a.bones.length;m++){const l=a.bones[m],g=s.findBone(l);if(!g)throw new Error(`Couldn't find bone ${l} for transform constraint ${a.name}.`);o.bones.push(g)}const d=a.target,f=s.findBone(d);if(!f)throw new Error(`Couldn't find target bone ${d} for transform constraint ${a.name}.`);o.target=f,o.local=B(a,"local",!1),o.relative=B(a,"relative",!1),o.offsetRotation=B(a,"rotation",0),o.offsetX=B(a,"x",0)*e,o.offsetY=B(a,"y",0)*e,o.offsetScaleX=B(a,"scaleX",0),o.offsetScaleY=B(a,"scaleY",0),o.offsetShearY=B(a,"shearY",0),o.mixRotate=B(a,"mixRotate",1),o.mixX=B(a,"mixX",1),o.mixY=B(a,"mixY",o.mixX),o.mixScaleX=B(a,"mixScaleX",1),o.mixScaleY=B(a,"mixScaleY",o.mixScaleX),o.mixShearY=B(a,"mixShearY",1),s.transformConstraints.push(o)}if(n.path)for(let i=0;i<n.path.length;i++){const a=n.path[i],o=new zh(a.name);o.order=B(a,"order",0),o.skinRequired=B(a,"skin",!1);for(let m=0;m<a.bones.length;m++){const l=a.bones[m],g=s.findBone(l);if(!g)throw new Error(`Couldn't find bone ${l} for path constraint ${a.name}.`);o.bones.push(g)}const d=a.target,f=s.findSlot(d);if(!f)throw new Error(`Couldn't find target slot ${d} for path constraint ${a.name}.`);o.target=f,o.positionMode=nt.enumValue(Pr,B(a,"positionMode","Percent")),o.spacingMode=nt.enumValue(qe,B(a,"spacingMode","Length")),o.rotateMode=nt.enumValue(Pa,B(a,"rotateMode","Tangent")),o.offsetRotation=B(a,"rotation",0),o.position=B(a,"position",0),o.positionMode==Pr.Fixed&&(o.position*=e),o.spacing=B(a,"spacing",0),(o.spacingMode==qe.Length||o.spacingMode==qe.Fixed)&&(o.spacing*=e),o.mixRotate=B(a,"mixRotate",1),o.mixX=B(a,"mixX",1),o.mixY=B(a,"mixY",o.mixX),s.pathConstraints.push(o)}if(n.physics)for(let i=0;i<n.physics.length;i++){const a=n.physics[i],o=new td(a.name);o.order=B(a,"order",0),o.skinRequired=B(a,"skin",!1);const d=a.bone,f=s.findBone(d);if(f==null)throw new Error(`Physics bone not found: ${d}`);o.bone=f,o.x=B(a,"x",0),o.y=B(a,"y",0),o.rotate=B(a,"rotate",0),o.scaleX=B(a,"scaleX",0),o.shearX=B(a,"shearX",0),o.limit=B(a,"limit",5e3)*e,o.step=1/B(a,"fps",60),o.inertia=B(a,"inertia",1),o.strength=B(a,"strength",100),o.damping=B(a,"damping",1),o.massInverse=1/B(a,"mass",1),o.wind=B(a,"wind",0),o.gravity=B(a,"gravity",0),o.mix=B(a,"mix",1),o.inertiaGlobal=B(a,"inertiaGlobal",!1),o.strengthGlobal=B(a,"strengthGlobal",!1),o.dampingGlobal=B(a,"dampingGlobal",!1),o.massGlobal=B(a,"massGlobal",!1),o.windGlobal=B(a,"windGlobal",!1),o.gravityGlobal=B(a,"gravityGlobal",!1),o.mixGlobal=B(a,"mixGlobal",!1),s.physicsConstraints.push(o)}if(n.skins)for(let i=0;i<n.skins.length;i++){const a=n.skins[i],o=new Ml(a.name);if(a.bones)for(let d=0;d<a.bones.length;d++){const f=a.bones[d],m=s.findBone(f);if(!m)throw new Error(`Couldn't find bone ${f} for skin ${a.name}.`);o.bones.push(m)}if(a.ik)for(let d=0;d<a.ik.length;d++){const f=a.ik[d],m=s.findIkConstraint(f);if(!m)throw new Error(`Couldn't find IK constraint ${f} for skin ${a.name}.`);o.constraints.push(m)}if(a.transform)for(let d=0;d<a.transform.length;d++){const f=a.transform[d],m=s.findTransformConstraint(f);if(!m)throw new Error(`Couldn't find transform constraint ${f} for skin ${a.name}.`);o.constraints.push(m)}if(a.path)for(let d=0;d<a.path.length;d++){const f=a.path[d],m=s.findPathConstraint(f);if(!m)throw new Error(`Couldn't find path constraint ${f} for skin ${a.name}.`);o.constraints.push(m)}if(a.physics)for(let d=0;d<a.physics.length;d++){const f=a.physics[d],m=s.findPhysicsConstraint(f);if(!m)throw new Error(`Couldn't find physics constraint ${f} for skin ${a.name}.`);o.constraints.push(m)}for(const d in a.attachments){const f=s.findSlot(d);if(!f)throw new Error(`Couldn't find slot ${d} for skin ${a.name}.`);const m=a.attachments[d];for(const l in m){const g=this.readAttachment(m[l],o,f.index,l,s);g&&o.setAttachment(f.index,l,g)}}s.skins.push(o),o.name=="default"&&(s.defaultSkin=o)}for(let i=0,a=this.linkedMeshes.length;i<a;i++){const o=this.linkedMeshes[i],d=o.skin?s.findSkin(o.skin):s.defaultSkin;if(!d)throw new Error(`Skin not found: ${o.skin}`);const f=d.getAttachment(o.slotIndex,o.parent);if(!f)throw new Error(`Parent mesh not found: ${o.parent}`);o.mesh.timelineAttachment=o.inheritTimeline?f:o.mesh,o.mesh.setParentMesh(f)}if(this.linkedMeshes.length=0,n.events)for(const i in n.events){const a=n.events[i],o=new Jh(i);o.intValue=B(a,"int",0),o.floatValue=B(a,"float",0),o.stringValue=B(a,"string",""),o.audioPath=B(a,"audio",null),o.audioPath&&(o.volume=B(a,"volume",1),o.balance=B(a,"balance",0)),s.events.push(o)}if(n.animations)for(const i in n.animations){const a=n.animations[i];this.readAnimation(a,i,s)}return s}readAttachment(t,e,s,n,r){const c=this.scale;switch(n=B(t,"name",n),B(t,"type","region")){case"region":{const h=B(t,"path",n),i=this.readSequence(B(t,"sequence",null)),a=this.attachmentLoader.newRegionAttachment(e,n,h,i);if(!a)return null;a.path=h,a.x=B(t,"x",0)*c,a.y=B(t,"y",0)*c,a.scaleX=B(t,"scaleX",1),a.scaleY=B(t,"scaleY",1),a.rotation=B(t,"rotation",0),a.width=t.width*c,a.height=t.height*c,a.sequence=i;const o=B(t,"color",null);return o&&a.color.setFromString(o),a.region!=null&&a.updateRegion(),a}case"boundingbox":{const h=this.attachmentLoader.newBoundingBoxAttachment(e,n);if(!h)return null;this.readVertices(t,h,t.vertexCount<<1);const i=B(t,"color",null);return i&&h.color.setFromString(i),h}case"mesh":case"linkedmesh":{const h=B(t,"path",n),i=this.readSequence(B(t,"sequence",null)),a=this.attachmentLoader.newMeshAttachment(e,n,h,i);if(!a)return null;a.path=h;const o=B(t,"color",null);o&&a.color.setFromString(o),a.width=B(t,"width",0)*c,a.height=B(t,"height",0)*c,a.sequence=i;const d=B(t,"parent",null);if(d)return this.linkedMeshes.push(new DS(a,B(t,"skin",null),s,d,B(t,"timelines",!0))),a;const f=t.uvs;return this.readVertices(t,a,f.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(f),a.edges=B(t,"edges",null),a.hullLength=B(t,"hull",0)*2,a}case"path":{const h=this.attachmentLoader.newPathAttachment(e,n);if(!h)return null;h.closed=B(t,"closed",!1),h.constantSpeed=B(t,"constantSpeed",!0);const i=t.vertexCount;this.readVertices(t,h,i<<1);const a=nt.newArray(i/3,0);for(let d=0;d<t.lengths.length;d++)a[d]=t.lengths[d]*c;h.lengths=a;const o=B(t,"color",null);return o&&h.color.setFromString(o),h}case"point":{const h=this.attachmentLoader.newPointAttachment(e,n);if(!h)return null;h.x=B(t,"x",0)*c,h.y=B(t,"y",0)*c,h.rotation=B(t,"rotation",0);const i=B(t,"color",null);return i&&h.color.setFromString(i),h}case"clipping":{const h=this.attachmentLoader.newClippingAttachment(e,n);if(!h)return null;const i=B(t,"end",null);i&&(h.endSlot=r.findSlot(i));const a=t.vertexCount;this.readVertices(t,h,a<<1);const o=B(t,"color",null);return o&&h.color.setFromString(o),h}}return null}readSequence(t){if(t==null)return null;const e=new lh(B(t,"count",0));return e.start=B(t,"start",1),e.digits=B(t,"digits",0),e.setupIndex=B(t,"setup",0),e}readVertices(t,e,s){const n=this.scale;e.worldVerticesLength=s;const r=t.vertices;if(s==r.length){const i=nt.toFloatArray(r);if(n!=1)for(let a=0,o=r.length;a<o;a++)i[a]*=n;e.vertices=i;return}const c=new Array,h=new Array;for(let i=0,a=r.length;i<a;){const o=r[i++];h.push(o);for(let d=i+o*4;i<d;i+=4)h.push(r[i]),c.push(r[i+1]*n),c.push(r[i+2]*n),c.push(r[i+3])}e.bones=h,e.vertices=nt.toFloatArray(c)}readAnimation(t,e,s){const n=this.scale,r=new Array;if(t.slots)for(const h in t.slots){const i=t.slots[h],a=s.findSlot(h);if(!a)throw new Error(`Slot not found: ${h}`);const o=a.index;for(const d in i){const f=i[d];if(!f)continue;const m=f.length;if(d=="attachment"){const l=new oa(m,o);for(let g=0;g<m;g++){const p=f[g];l.setFrame(g,B(p,"time",0),B(p,"name",null))}r.push(l)}else if(d=="rgba"){const l=new yh(m,m<<2,o);let g=f[0],p=B(g,"time",0),y=Pt.fromString(g.color);for(let w=0,b=0;;w++){l.setFrame(w,p,y.r,y.g,y.b,y.a);const x=f[w+1];if(!x){l.shrink(b);break}const S=B(x,"time",0),C=Pt.fromString(x.color),A=g.curve;A&&(b=Bt(A,l,b,w,0,p,S,y.r,C.r,1),b=Bt(A,l,b,w,1,p,S,y.g,C.g,1),b=Bt(A,l,b,w,2,p,S,y.b,C.b,1),b=Bt(A,l,b,w,3,p,S,y.a,C.a,1)),p=S,y=C,g=x}r.push(l)}else if(d=="rgb"){const l=new Sh(m,m*3,o);let g=f[0],p=B(g,"time",0),y=Pt.fromString(g.color);for(let w=0,b=0;;w++){l.setFrame(w,p,y.r,y.g,y.b);const x=f[w+1];if(!x){l.shrink(b);break}const S=B(x,"time",0),C=Pt.fromString(x.color),A=g.curve;A&&(b=Bt(A,l,b,w,0,p,S,y.r,C.r,1),b=Bt(A,l,b,w,1,p,S,y.g,C.g,1),b=Bt(A,l,b,w,2,p,S,y.b,C.b,1)),p=S,y=C,g=x}r.push(l)}else if(d=="alpha")r.push(Dn(f,new Ch(m,m,o),0,1));else if(d=="rgba2"){const l=new Ah(m,m*7,o);let g=f[0],p=B(g,"time",0),y=Pt.fromString(g.light),w=Pt.fromString(g.dark);for(let b=0,x=0;;b++){l.setFrame(b,p,y.r,y.g,y.b,y.a,w.r,w.g,w.b);const S=f[b+1];if(!S){l.shrink(x);break}const C=B(S,"time",0),A=Pt.fromString(S.light),v=Pt.fromString(S.dark),M=g.curve;M&&(x=Bt(M,l,x,b,0,p,C,y.r,A.r,1),x=Bt(M,l,x,b,1,p,C,y.g,A.g,1),x=Bt(M,l,x,b,2,p,C,y.b,A.b,1),x=Bt(M,l,x,b,3,p,C,y.a,A.a,1),x=Bt(M,l,x,b,4,p,C,w.r,v.r,1),x=Bt(M,l,x,b,5,p,C,w.g,v.g,1),x=Bt(M,l,x,b,6,p,C,w.b,v.b,1)),p=C,y=A,w=v,g=S}r.push(l)}else if(d=="rgb2"){const l=new vh(m,m*6,o);let g=f[0],p=B(g,"time",0),y=Pt.fromString(g.light),w=Pt.fromString(g.dark);for(let b=0,x=0;;b++){l.setFrame(b,p,y.r,y.g,y.b,w.r,w.g,w.b);const S=f[b+1];if(!S){l.shrink(x);break}const C=B(S,"time",0),A=Pt.fromString(S.light),v=Pt.fromString(S.dark),M=g.curve;M&&(x=Bt(M,l,x,b,0,p,C,y.r,A.r,1),x=Bt(M,l,x,b,1,p,C,y.g,A.g,1),x=Bt(M,l,x,b,2,p,C,y.b,A.b,1),x=Bt(M,l,x,b,3,p,C,w.r,v.r,1),x=Bt(M,l,x,b,4,p,C,w.g,v.g,1),x=Bt(M,l,x,b,5,p,C,w.b,v.b,1)),p=C,y=A,w=v,g=S}r.push(l)}}}if(t.bones)for(const h in t.bones){const i=t.bones[h],a=s.findBone(h);if(!a)throw new Error(`Bone not found: ${h}`);const o=a.index;for(const d in i){const f=i[d],m=f.length;if(m!=0){if(d==="rotate")r.push(Dn(f,new Eo(m,m,o),0,1));else if(d==="translate"){const l=new hh(m,m<<1,o);r.push(ad(f,l,"x","y",0,n))}else if(d==="translatex"){const l=new dh(m,m,o);r.push(Dn(f,l,0,n))}else if(d==="translatey"){const l=new uh(m,m,o);r.push(Dn(f,l,0,n))}else if(d==="scale"){const l=new fh(m,m<<1,o);r.push(ad(f,l,"x","y",1,1))}else if(d==="scalex"){const l=new mh(m,m,o);r.push(Dn(f,l,1,1))}else if(d==="scaley"){const l=new gh(m,m,o);r.push(Dn(f,l,1,1))}else if(d==="shear"){const l=new ph(m,m<<1,o);r.push(ad(f,l,"x","y",0,1))}else if(d==="shearx"){const l=new bh(m,m,o);r.push(Dn(f,l,0,1))}else if(d==="sheary"){const l=new xh(m,m,o);r.push(Dn(f,l,0,1))}else if(d==="transformMode"){const l=new wh(m,a.index);for(let g=0;g<f.length;g++){const p=f[g];l.setFrame(g,B(p,"time",0),nt.enumValue(pe,B(p,"transformMode","Normal")))}r.push(l)}}}}if(t.ik)for(const h in t.ik){const i=t.ik[h];let a=i[0];if(!a)continue;const o=s.findIkConstraint(h);if(!o)throw new Error(`IK Constraint not found: ${h}`);const d=s.ikConstraints.indexOf(o),f=new Eh(i.length,i.length<<1,d);let m=B(a,"time",0),l=B(a,"mix",1),g=B(a,"softness",0)*n;for(let p=0,y=0;;p++){f.setFrame(p,m,l,g,B(a,"bendPositive",!0)?1:-1,B(a,"compress",!1),B(a,"stretch",!1));const w=i[p+1];if(!w){f.shrink(y);break}const b=B(w,"time",0),x=B(w,"mix",1),S=B(w,"softness",0)*n,C=a.curve;C&&(y=Bt(C,f,y,p,0,m,b,l,x,1),y=Bt(C,f,y,p,1,m,b,g,S,n)),m=b,l=x,g=S,a=w}r.push(f)}if(t.transform)for(const h in t.transform){const i=t.transform[h];let a=i[0];if(!a)continue;const o=s.findTransformConstraint(h);if(!o)throw new Error(`Transform constraint not found: ${h}`);const d=s.transformConstraints.indexOf(o),f=new Th(i.length,i.length*6,d);let m=B(a,"time",0),l=B(a,"mixRotate",1),g=B(a,"mixX",1),p=B(a,"mixY",g),y=B(a,"mixScaleX",1),w=B(a,"mixScaleY",y);const b=B(a,"mixShearY",1);for(let x=0,S=0;;x++){f.setFrame(x,m,l,g,p,y,w,b);const C=i[x+1];if(!C){f.shrink(S);break}const A=B(C,"time",0),v=B(C,"mixRotate",1),M=B(C,"mixX",1),E=B(C,"mixY",M),T=B(C,"mixScaleX",1),R=B(C,"mixScaleY",T),k=B(C,"mixShearY",1),I=a.curve;I&&(S=Bt(I,f,S,x,0,m,A,l,v,1),S=Bt(I,f,S,x,1,m,A,g,M,1),S=Bt(I,f,S,x,2,m,A,p,E,1),S=Bt(I,f,S,x,3,m,A,y,T,1),S=Bt(I,f,S,x,4,m,A,w,R,1),S=Bt(I,f,S,x,5,m,A,b,k,1)),m=A,l=v,g=M,p=E,y=T,w=R,y=T,a=C}r.push(f)}if(t.path)for(const h in t.path){const i=t.path[h],a=s.findPathConstraint(h);if(!a)throw new Error(`Path constraint not found: ${h}`);const o=s.pathConstraints.indexOf(a);for(const d in i){const f=i[d];let m=f[0];if(!m)continue;const l=f.length;if(d==="position"){const g=new Ih(l,l,o);r.push(Dn(f,g,0,a.positionMode==Pr.Fixed?n:1))}else if(d==="spacing"){const g=new Rh(l,l,o);r.push(Dn(f,g,0,a.spacingMode==qe.Length||a.spacingMode==qe.Fixed?n:1))}else if(d==="mix"){const g=new Ph(l,l*3,o);let p=B(m,"time",0),y=B(m,"mixRotate",1),w=B(m,"mixX",1),b=B(m,"mixY",w);for(let x=0,S=0;;x++){g.setFrame(x,p,y,w,b);const C=f[x+1];if(!C){g.shrink(S);break}const A=B(C,"time",0),v=B(C,"mixRotate",1),M=B(C,"mixX",1),E=B(C,"mixY",M),T=m.curve;T&&(S=Bt(T,g,S,x,0,p,A,y,v,1),S=Bt(T,g,S,x,1,p,A,w,M,1),S=Bt(T,g,S,x,2,p,A,b,E,1)),p=A,y=v,w=M,b=E,m=C}r.push(g)}}}if(t.physics)for(const h in t.physics){const i=t.physics[h];let a=-1;if(h.length>0){const o=s.findPhysicsConstraint(h);if(!o)throw new Error(`Physics constraint not found: ${h}`);a=s.physicsConstraints.indexOf(o)}for(const o in i){const d=i[o];let f=d[0];if(!f)continue;const m=d.length;if(o=="reset"){const g=new Vh(m,a);for(let p=0;f!=null;f=d[p+1],p++)g.setFrame(p,B(f,"time",0));r.push(g);continue}let l;if(o=="inertia")l=new kh(m,m,a);else if(o=="strength")l=new Fh(m,m,a);else if(o=="damping")l=new Yh(m,m,a);else if(o=="mass")l=new $h(m,m,a);else if(o=="wind")l=new _h(m,m,a);else if(o=="gravity")l=new Xh(m,m,a);else if(o=="mix")l=new Bh(m,m,a);else continue;r.push(Dn(d,l,0,1))}}if(t.attachments)for(const h in t.attachments){const i=t.attachments[h],a=s.findSkin(h);if(!a)throw new Error(`Skin not found: ${h}`);for(const o in i){const d=i[o],f=s.findSlot(o);if(!f)throw new Error(`Slot not found: ${o}`);const m=f.index;for(const l in d){const g=d[l],p=a.getAttachment(m,l);for(const y in g){const w=g[y];let b=w[0];if(b){if(y=="deform"){const x=p.bones,S=p.vertices,C=x?S.length/3*2:S.length,A=new Mh(w.length,w.length,m,p);let v=B(b,"time",0);for(let M=0,E=0;;M++){let T;const R=B(b,"vertices",null);if(!R)T=x?nt.newFloatArray(C):S;else{T=nt.newFloatArray(C);const F=B(b,"offset",0);if(nt.arrayCopy(R,0,T,F,R.length),n!=1)for(let X=F,W=X+R.length;X<W;X++)T[X]*=n;if(!x)for(let X=0;X<C;X++)T[X]+=S[X]}A.setFrame(M,v,T);const k=w[M+1];if(!k){A.shrink(E);break}const I=B(k,"time",0),P=b.curve;P&&(E=Bt(P,A,E,M,0,v,I,0,1,1)),v=I,b=k}r.push(A)}else if(y=="sequence"){const x=new Nh(w.length,m,p);let S=0;for(let C=0;C<w.length;C++){const A=B(b,"delay",S),v=B(b,"time",0),M=dr[B(b,"mode","hold")],E=B(b,"index",0);x.setFrame(C,v,M,E,A),S=A,b=w[C+1]}r.push(x)}}}}}}if(t.drawOrder){const h=new Ra(t.drawOrder.length),i=s.slots.length;let a=0;for(let o=0;o<t.drawOrder.length;o++,a++){const d=t.drawOrder[o];let f=null;const m=B(d,"offsets",null);if(m){f=nt.newArray(i,-1);const l=nt.newArray(i-m.length,0);let g=0,p=0;for(let y=0;y<m.length;y++){const w=m[y],b=s.findSlot(w.slot);if(!b)throw new Error(`Slot not found: ${b}`);const x=b.index;for(;g!=x;)l[p++]=g++;f[g+w.offset]=g++}for(;g<i;)l[p++]=g++;for(let y=i-1;y>=0;y--)f[y]==-1&&(f[y]=l[--p])}h.setFrame(a,B(d,"time",0),f)}r.push(h)}if(t.events){const h=new bl(t.events.length);let i=0;for(let a=0;a<t.events.length;a++,i++){const o=t.events[a],d=s.findEvent(o.name);if(!d)throw new Error(`Event not found: ${o.name}`);const f=new Qh(nt.toSinglePrecision(B(o,"time",0)),d);f.intValue=B(o,"int",d.intValue),f.floatValue=B(o,"float",d.floatValue),f.stringValue=B(o,"string",d.stringValue),f.data.audioPath&&(f.volume=B(o,"volume",1),f.balance=B(o,"balance",0)),h.setFrame(i,f)}r.push(h)}let c=0;for(let h=0,i=r.length;h<i;h++)c=Math.max(c,r[h].getDuration());s.animations.push(new gl(e,r,c))}},DS=class{constructor(t,e,s,n,r){pi(this,"parent"),pi(this,"skin"),pi(this,"slotIndex"),pi(this,"mesh"),pi(this,"inheritTimeline"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritTimeline=r}};function Dn(u,t,e,s){let n=u[0],r=B(n,"time",0),c=B(n,"value",e)*s,h=0;for(let i=0;;i++){t.setFrame(i,r,c);const a=u[i+1];if(!a)return t.shrink(h),t;const o=B(a,"time",0),d=B(a,"value",e)*s;n.curve&&(h=Bt(n.curve,t,h,i,0,r,o,c,d,s)),r=o,c=d,n=a}}function ad(u,t,e,s,n,r){let c=u[0],h=B(c,"time",0),i=B(c,e,n)*r,a=B(c,s,n)*r,o=0;for(let d=0;;d++){t.setFrame(d,h,i,a);const f=u[d+1];if(!f)return t.shrink(o),t;const m=B(f,"time",0),l=B(f,e,n)*r,g=B(f,s,n)*r,p=c.curve;p&&(o=Bt(p,t,o,d,0,h,m,i,l,r),o=Bt(p,t,o,d,1,h,m,a,g,r)),h=m,i=l,a=g,c=f}}function Bt(u,t,e,s,n,r,c,h,i,a){if(u=="stepped")return t.setStepped(s),e;const o=n<<2,d=u[o],f=u[o+1]*a,m=u[o+2],l=u[o+3]*a;return t.setBezier(e,s,n,r,h,d,f,m,l,c,i),e+1}function B(u,t,e){return u[t]!==void 0?u[t]:e}var LS=Object.defineProperty,OS=(u,t,e)=>t in u?LS(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Am=(u,t,e)=>OS(u,typeof t!="symbol"?t+"":t,e);class WS{constructor(){Am(this,"scale",1)}readSkeletonData(t,e){let s=null,n=this.readVersionOldFormat(e),r=za(n);if(r===Je.VER38&&(s=new pf(new ic(t))),n=this.readVersionNewFormat(e),r=za(n),(r===Je.VER40||r===Je.VER41)&&(s=new nh(new Gc(t))),r===Je.VER42&&(s=new ym(new Gh(t))),!s){const c=`Unsupported version of spine model ${n}, please update pixi-spine`;console.error(c)}return s.scale=this.scale,s.readSkeletonData(e)}readVersionOldFormat(t){const e=new zd(t);let s;try{e.readString(),s=e.readString()}catch(n){s=""}return s||""}readVersionNewFormat(t){const e=new zd(t);e.readInt32(),e.readInt32();let s;try{s=e.readString()}catch(n){s=""}return s||""}}class US{constructor(){Am(this,"scale",1)}readSkeletonData(t,e){const s=e.skeleton.spine,n=za(s);let r=null;if(n===Je.VER37&&(r=new Lu(new Mu(t))),n===Je.VER38&&(r=new bf(new ic(t))),(n===Je.VER40||n===Je.VER41)&&(r=new Hf(new Gc(t))),n===Je.VER42&&(r=new Cm(new Gh(t))),!r){const c=`Unsupported version of spine model ${s}, please update pixi-spine`;console.error(c)}return r.scale=this.scale,r.readSkeletonData(e)}}class qS extends c0{createBinaryParser(){return new WS}createJsonParser(){return new US}parseData(t,e,s){return{spineData:t.readSkeletonData(e,s),spineAtlas:e}}}var GS=Object.defineProperty,zS=(u,t,e)=>t in u?GS(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,vm=(u,t,e)=>zS(u,typeof t!="symbol"?t+"":t,e);let HS=class{constructor(t,e){vm(this,"jitterX",0),vm(this,"jitterY",0),this.jitterX=t,this.jitterY=e}begin(t){}transform(t,e,s,n){t.x+=j.randomTriangular(-this.jitterX,this.jitterY),t.y+=j.randomTriangular(-this.jitterX,this.jitterY)}end(){}};var KS=Object.defineProperty,ZS=(u,t,e)=>t in u?KS(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ha=(u,t,e)=>ZS(u,typeof t!="symbol"?t+"":t,e);let QS=class{constructor(){ha(this,"minX",0),ha(this,"minY",0),ha(this,"maxX",0),ha(this,"maxY",0),ha(this,"boundingBoxes",new Array),ha(this,"polygons",new Array),ha(this,"polygonPool",new tu(()=>pt.newFloatArray(16)))}update(t,e){if(!t)throw new Error("skeleton cannot be null.");const s=this.boundingBoxes,n=this.polygons,r=this.polygonPool,c=t.slots,h=c.length;s.length=0,r.freeAll(n),n.length=0;for(let i=0;i<h;i++){const a=c[i];if(!a.bone.active)continue;const o=a.getAttachment();if(o!=null&&o.type===Os.BoundingBox){const d=o;s.push(d);let f=r.obtain();f.length!=d.worldVerticesLength&&(f=pt.newFloatArray(d.worldVerticesLength)),n.push(f),d.computeWorldVertices(a,0,d.worldVerticesLength,f,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY;const r=this.polygons;for(let c=0,h=r.length;c<h;c++){const i=r[c],a=i;for(let o=0,d=i.length;o<d;o+=2){const f=a[o],m=a[o+1];t=Math.min(t,f),e=Math.min(e,m),s=Math.max(s,f),n=Math.max(n,m)}}this.minX=t,this.minY=e,this.maxX=s,this.maxY=n}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,s,n){const r=this.minX,c=this.minY,h=this.maxX,i=this.maxY;if(t<=r&&s<=r||e<=c&&n<=c||t>=h&&s>=h||e>=i&&n>=i)return!1;const a=(n-e)/(s-t);let o=a*(r-t)+e;if(o>c&&o<i||(o=a*(h-t)+e,o>c&&o<i))return!0;let d=(c-e)/a+t;return d>r&&d<h||(d=(i-e)/a+t,d>r&&d<h)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){const s=this.polygons;for(let n=0,r=s.length;n<r;n++)if(this.containsPointPolygon(s[n],t,e))return this.boundingBoxes[n];return null}containsPointPolygon(t,e,s){const n=t,r=t.length;let c=r-2,h=!1;for(let i=0;i<r;i+=2){const a=n[i+1],o=n[c+1];if(a<s&&o>=s||o<s&&a>=s){const d=n[i];d+(s-a)/(o-a)*(n[c]-d)<e&&(h=!h)}c=i}return h}intersectsSegment(t,e,s,n){const r=this.polygons;for(let c=0,h=r.length;c<h;c++)if(this.intersectsSegmentPolygon(r[c],t,e,s,n))return this.boundingBoxes[c];return null}intersectsSegmentPolygon(t,e,s,n,r){const c=t,h=t.length,i=e-n,a=s-r,o=e*r-s*n;let d=c[h-2],f=c[h-1];for(let m=0;m<h;m+=2){const l=c[m],g=c[m+1],p=d*g-f*l,y=d-l,w=f-g,b=i*w-a*y,x=(o*y-i*p)/b;if((x>=d&&x<=l||x>=l&&x<=d)&&(x>=e&&x<=n||x>=n&&x<=e)){const S=(o*w-a*p)/b;if((S>=f&&S<=g||S>=g&&S<=f)&&(S>=s&&S<=r||S>=r&&S<=s))return!0}d=l,f=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const e=this.boundingBoxes.indexOf(t);return e==-1?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}};var JS=Object.freeze({__proto__:null,Animation:$e,AnimationState:mu,AnimationStateAdapter2:V0,AnimationStateData:yu,AtlasAttachmentLoader:Mu,Attachment:Vl,AttachmentTimeline:Zo,Bone:Kl,BoneData:_u,BoundingBoxAttachment:Cu,ClippingAttachment:Au,ColorTimeline:Ll,CurveTimeline:er,DeformTimeline:du,DrawOrderTimeline:Qo,Event:Fu,EventData:Du,EventQueue:bu,EventTimeline:uu,EventType:xu,IkConstraint:Iu,IkConstraintData:Xu,IkConstraintTimeline:Wl,JitterEffect:HS,MeshAttachment:Hl,PathAttachment:eo,PathConstraint:Tu,PathConstraintData:Eu,PathConstraintMixTimeline:ql,PathConstraintPositionTimeline:Jo,PathConstraintSpacingTimeline:fu,PointAttachment:vu,RegionAttachment:Dl,RotateTimeline:yn,ScaleTimeline:lu,ShearTimeline:cu,Skeleton:ku,SkeletonBounds:class extends QS{},SkeletonData:Yu,SkeletonJson:Lu,Skin:Nu,Slot:Nl,SlotData:$u,SpacingMode:Mn,Spine:class extends iu{createSkeleton(t){this.skeleton=new ku(t),this.skeleton.updateWorldTransform(),this.stateData=new yu(t),this.state=new mu(this.stateData)}},SwirlEffect:Y0,TimelineType:ou,TrackEntry:gu,TransformConstraint:Ru,TransformConstraintData:Bu,TransformConstraintTimeline:Ul,TranslateTimeline:Ja,TwoColorTimeline:Ol,VertexAttachment:Bi}),jS=Object.defineProperty,tC=(u,t,e)=>t in u?jS(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Mm=(u,t,e)=>tC(u,typeof t!="symbol"?t+"":t,e);class eC{constructor(t,e){Mm(this,"jitterX",0),Mm(this,"jitterY",0),this.jitterX=t,this.jitterY=e}begin(t){}transform(t,e,s,n){t.x+=J.randomTriangular(-this.jitterX,this.jitterY),t.y+=J.randomTriangular(-this.jitterX,this.jitterY)}end(){}}var sC=Object.defineProperty,nC=(u,t,e)=>t in u?sC(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,da=(u,t,e)=>nC(u,typeof t!="symbol"?t+"":t,e);let rC=class{constructor(){da(this,"minX",0),da(this,"minY",0),da(this,"maxX",0),da(this,"maxY",0),da(this,"boundingBoxes",new Array),da(this,"polygons",new Array),da(this,"polygonPool",new Wu(()=>it.newFloatArray(16)))}update(t,e){if(!t)throw new Error("skeleton cannot be null.");const s=this.boundingBoxes,n=this.polygons,r=this.polygonPool,c=t.slots,h=c.length;s.length=0,r.freeAll(n),n.length=0;for(let i=0;i<h;i++){const a=c[i];if(!a.bone.active)continue;const o=a.getAttachment();if(o!=null&&o.type===we.BoundingBox){const d=o;s.push(d);let f=r.obtain();f.length!=d.worldVerticesLength&&(f=it.newFloatArray(d.worldVerticesLength)),n.push(f),d.computeWorldVertices(a,0,d.worldVerticesLength,f,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY;const r=this.polygons;for(let c=0,h=r.length;c<h;c++){const i=r[c],a=i;for(let o=0,d=i.length;o<d;o+=2){const f=a[o],m=a[o+1];t=Math.min(t,f),e=Math.min(e,m),s=Math.max(s,f),n=Math.max(n,m)}}this.minX=t,this.minY=e,this.maxX=s,this.maxY=n}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,s,n){const r=this.minX,c=this.minY,h=this.maxX,i=this.maxY;if(t<=r&&s<=r||e<=c&&n<=c||t>=h&&s>=h||e>=i&&n>=i)return!1;const a=(n-e)/(s-t);let o=a*(r-t)+e;if(o>c&&o<i||(o=a*(h-t)+e,o>c&&o<i))return!0;let d=(c-e)/a+t;return d>r&&d<h||(d=(i-e)/a+t,d>r&&d<h)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){const s=this.polygons;for(let n=0,r=s.length;n<r;n++)if(this.containsPointPolygon(s[n],t,e))return this.boundingBoxes[n];return null}containsPointPolygon(t,e,s){const n=t,r=t.length;let c=r-2,h=!1;for(let i=0;i<r;i+=2){const a=n[i+1],o=n[c+1];if(a<s&&o>=s||o<s&&a>=s){const d=n[i];d+(s-a)/(o-a)*(n[c]-d)<e&&(h=!h)}c=i}return h}intersectsSegment(t,e,s,n){const r=this.polygons;for(let c=0,h=r.length;c<h;c++)if(this.intersectsSegmentPolygon(r[c],t,e,s,n))return this.boundingBoxes[c];return null}intersectsSegmentPolygon(t,e,s,n,r){const c=t,h=t.length,i=e-n,a=s-r,o=e*r-s*n;let d=c[h-2],f=c[h-1];for(let m=0;m<h;m+=2){const l=c[m],g=c[m+1],p=d*g-f*l,y=d-l,w=f-g,b=i*w-a*y,x=(o*y-i*p)/b;if((x>=d&&x<=l||x>=l&&x<=d)&&(x>=e&&x<=n||x>=n&&x<=e)){const S=(o*w-a*p)/b;if((S>=f&&S<=g||S>=g&&S<=f)&&(S>=s&&S<=r||S>=r&&S<=s))return!0}d=l,f=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const e=this.boundingBoxes.indexOf(t);return e==-1?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}};var iC=Object.freeze({__proto__:null,Animation:ye,AnimationState:ju,AnimationStateAdapter:ix,AnimationStateData:af,AtlasAttachmentLoader:ic,Attachment:Zl,AttachmentTimeline:Qi,Bone:oc,BoneData:dc,BoundingBoxAttachment:lf,ClippingAttachment:cf,ColorTimeline:oo,ConstraintData:nl,CurveTimeline:sr,DeformTimeline:ec,DrawOrderTimeline:Aa,Event:lc,EventData:gc,EventQueue:sf,EventTimeline:tl,EventType:nf,IkConstraint:uf,IkConstraintData:uc,IkConstraintTimeline:co,JitterEffect:eC,MeshAttachment:sl,PathAttachment:go,PathConstraint:df,PathConstraintData:ac,PathConstraintMixTimeline:fo,PathConstraintPositionTimeline:va,PathConstraintSpacingTimeline:sc,PointAttachment:hf,RegionAttachment:Jl,RotateTimeline:rn,ScaleTimeline:jl,ShearTimeline:tc,Skeleton:gf,SkeletonBinary:pf,SkeletonBounds:class extends rC{},SkeletonData:cc,SkeletonJson:bf,Skin:il,SkinEntry:mc,Slot:Ql,SlotData:hc,SpacingMode:Oe,Spine:class extends Hu{createSkeleton(t){this.skeleton=new gf(t),this.skeleton.updateWorldTransform(),this.stateData=new af(t),this.state=new ju(this.stateData)}},SwirlEffect:tx,TimelineType:Qu,TrackEntry:tf,TransformConstraint:ff,TransformConstraintData:fc,TransformConstraintTimeline:ho,TranslateTimeline:Zi,TwoColorTimeline:lo,VertexAttachment:zi}),aC=Object.defineProperty,oC=(u,t,e)=>t in u?aC(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,od=(u,t,e)=>oC(u,typeof t!="symbol"?t+"":t,e);let Em=class{constructor(t){if(od(this,"skeletonData"),od(this,"animationToMixTime",{}),od(this,"defaultMix",0),!t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,s){const n=this.skeletonData.findAnimation(t);if(!n)throw new Error(`Animation not found: ${t}`);const r=this.skeletonData.findAnimation(e);if(!r)throw new Error(`Animation not found: ${e}`);this.setMixWith(n,r,s)}setMixWith(t,e,s){if(!t)throw new Error("from cannot be null.");if(!e)throw new Error("to cannot be null.");const n=`${t.name}.${e.name}`;this.animationToMixTime[n]=s}getMix(t,e){const s=`${t.name}.${e.name}`,n=this.animationToMixTime[s];return n===void 0?this.defaultMix:n}};var lC=Object.defineProperty,cC=(u,t,e)=>t in u?lC(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ua=(u,t,e)=>cC(u,typeof t!="symbol"?t+"":t,e);let hC=class{constructor(){ua(this,"minX",0),ua(this,"minY",0),ua(this,"maxX",0),ua(this,"maxY",0),ua(this,"boundingBoxes",new Array),ua(this,"polygons",new Array),ua(this,"polygonPool",new yf(()=>ct.newFloatArray(16)))}update(t,e){if(!t)throw new Error("skeleton cannot be null.");const s=this.boundingBoxes,n=this.polygons,r=this.polygonPool,c=t.slots,h=c.length;s.length=0,r.freeAll(n),n.length=0;for(let i=0;i<h;i++){const a=c[i];if(!a.bone.active)continue;const o=a.getAttachment();if(o!=null&&o.type===Se.BoundingBox){const d=o;s.push(d);let f=r.obtain();f.length!=d.worldVerticesLength&&(f=ct.newFloatArray(d.worldVerticesLength)),n.push(f),d.computeWorldVertices(a,0,d.worldVerticesLength,f,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY;const r=this.polygons;for(let c=0,h=r.length;c<h;c++){const i=r[c],a=i;for(let o=0,d=i.length;o<d;o+=2){const f=a[o],m=a[o+1];t=Math.min(t,f),e=Math.min(e,m),s=Math.max(s,f),n=Math.max(n,m)}}this.minX=t,this.minY=e,this.maxX=s,this.maxY=n}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,s,n){const r=this.minX,c=this.minY,h=this.maxX,i=this.maxY;if(t<=r&&s<=r||e<=c&&n<=c||t>=h&&s>=h||e>=i&&n>=i)return!1;const a=(n-e)/(s-t);let o=a*(r-t)+e;if(o>c&&o<i||(o=a*(h-t)+e,o>c&&o<i))return!0;let d=(c-e)/a+t;return d>r&&d<h||(d=(i-e)/a+t,d>r&&d<h)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){const s=this.polygons;for(let n=0,r=s.length;n<r;n++)if(this.containsPointPolygon(s[n],t,e))return this.boundingBoxes[n];return null}containsPointPolygon(t,e,s){const n=t,r=t.length;let c=r-2,h=!1;for(let i=0;i<r;i+=2){const a=n[i+1],o=n[c+1];if(a<s&&o>=s||o<s&&a>=s){const d=n[i];d+(s-a)/(o-a)*(n[c]-d)<e&&(h=!h)}c=i}return h}intersectsSegment(t,e,s,n){const r=this.polygons;for(let c=0,h=r.length;c<h;c++)if(this.intersectsSegmentPolygon(r[c],t,e,s,n))return this.boundingBoxes[c];return null}intersectsSegmentPolygon(t,e,s,n,r){const c=t,h=t.length,i=e-n,a=s-r,o=e*r-s*n;let d=c[h-2],f=c[h-1];for(let m=0;m<h;m+=2){const l=c[m],g=c[m+1],p=d*g-f*l,y=d-l,w=f-g,b=i*w-a*y,x=(o*y-i*p)/b;if((x>=d&&x<=l||x>=l&&x<=d)&&(x>=e&&x<=n||x>=n&&x<=e)){const S=(o*w-a*p)/b;if((S>=f&&S<=g||S>=g&&S<=f)&&(S>=s&&S<=r||S>=r&&S<=s))return!0}d=l,f=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const e=this.boundingBoxes.indexOf(t);return e==-1?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}};var dC=Object.freeze({__proto__:null,AlphaTimeline:Fc,Animation:al,AnimationState:Pf,AnimationStateAdapter:A1,AnimationStateData:Em,AtlasAttachmentLoader:Gc,Attachment:bc,AttachmentTimeline:sa,Bone:Hc,BoneData:Jc,BoundingBoxAttachment:Vf,ClippingAttachment:Nf,ConstraintData:dl,CurveTimeline:Pn,CurveTimeline1:kn,CurveTimeline2:ol,DeformTimeline:_c,DrawOrderTimeline:Ea,Event:Kc,EventData:sh,EventQueue:Ff,EventTimeline:ll,EventType:Yf,IkConstraint:Wf,IkConstraintData:jc,IkConstraintTimeline:Xc,MeshAttachment:hl,PathAttachment:Co,PathConstraint:Lf,PathConstraintData:zc,PathConstraintMixTimeline:Dc,PathConstraintPositionTimeline:Vc,PathConstraintSpacingTimeline:Nc,PointAttachment:Df,RGB2Timeline:$c,RGBA2Timeline:Yc,RGBATimeline:Pc,RGBTimeline:kc,RegionAttachment:xc,RotateTimeline:wo,ScaleTimeline:vc,ScaleXTimeline:Mc,ScaleYTimeline:Ec,Sequence:wc,SequenceMode:or,SequenceModeValues:yc,SequenceTimeline:Lc,ShearTimeline:Tc,ShearXTimeline:Ic,ShearYTimeline:Rc,Skeleton:Gf,SkeletonBinary:nh,SkeletonBounds:class extends hC{},SkeletonData:Zc,SkeletonJson:Hf,Skin:fl,SkinEntry:eh,Slot:Of,SlotData:Qc,SpacingMode:Ue,Spine:class extends Mf{createSkeleton(t){this.skeleton=new Gf(t),this.skeleton.updateWorldTransform(),this.stateData=new Em(t),this.state=new Pf(this.stateData)}},Timeline:ge,TrackEntry:kf,TransformConstraint:Uf,TransformConstraintData:th,TransformConstraintTimeline:Bc,TranslateTimeline:Sc,TranslateXTimeline:Cc,TranslateYTimeline:Ac,VertexAttachment:ar}),uC=Object.defineProperty,fC=(u,t,e)=>t in u?uC(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ld=(u,t,e)=>fC(u,typeof t!="symbol"?t+"":t,e);let Tm=class{constructor(t){if(ld(this,"skeletonData"),ld(this,"animationToMixTime",{}),ld(this,"defaultMix",0),!t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,s){const n=this.skeletonData.findAnimation(t);if(!n)throw new Error(`Animation not found: ${t}`);const r=this.skeletonData.findAnimation(e);if(!r)throw new Error(`Animation not found: ${e}`);this.setMixWith(n,r,s)}setMixWith(t,e,s){if(!t)throw new Error("from cannot be null.");if(!e)throw new Error("to cannot be null.");const n=`${t.name}.${e.name}`;this.animationToMixTime[n]=s}getMix(t,e){const s=`${t.name}.${e.name}`,n=this.animationToMixTime[s];return n===void 0?this.defaultMix:n}};var mC=Object.defineProperty,gC=(u,t,e)=>t in u?mC(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,fa=(u,t,e)=>gC(u,typeof t!="symbol"?t+"":t,e);let pC=class{constructor(){fa(this,"minX",0),fa(this,"minY",0),fa(this,"maxX",0),fa(this,"maxY",0),fa(this,"boundingBoxes",new Array),fa(this,"polygons",new Array),fa(this,"polygonPool",new ml(()=>nt.newFloatArray(16)))}update(t,e){if(!t)throw new Error("skeleton cannot be null.");const s=this.boundingBoxes,n=this.polygons,r=this.polygonPool,c=t.slots,h=c.length;s.length=0,r.freeAll(n),n.length=0;for(let i=0;i<h;i++){const a=c[i];if(!a.bone.active)continue;const o=a.getAttachment();if(o instanceof Wh){const d=o;s.push(d);let f=r.obtain();f.length!=d.worldVerticesLength&&(f=nt.newFloatArray(d.worldVerticesLength)),n.push(f),d.computeWorldVertices(a,0,d.worldVerticesLength,f,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY;const r=this.polygons;for(let c=0,h=r.length;c<h;c++){const i=r[c],a=i;for(let o=0,d=i.length;o<d;o+=2){const f=a[o],m=a[o+1];t=Math.min(t,f),e=Math.min(e,m),s=Math.max(s,f),n=Math.max(n,m)}}this.minX=t,this.minY=e,this.maxX=s,this.maxY=n}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,s,n){const r=this.minX,c=this.minY,h=this.maxX,i=this.maxY;if(t<=r&&s<=r||e<=c&&n<=c||t>=h&&s>=h||e>=i&&n>=i)return!1;const a=(n-e)/(s-t);let o=a*(r-t)+e;if(o>c&&o<i||(o=a*(h-t)+e,o>c&&o<i))return!0;let d=(c-e)/a+t;return d>r&&d<h||(d=(i-e)/a+t,d>r&&d<h)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){const s=this.polygons;for(let n=0,r=s.length;n<r;n++)if(this.containsPointPolygon(s[n],t,e))return this.boundingBoxes[n];return null}containsPointPolygon(t,e,s){const n=t,r=t.length;let c=r-2,h=!1;for(let i=0;i<r;i+=2){const a=n[i+1],o=n[c+1];if(a<s&&o>=s||o<s&&a>=s){const d=n[i];d+(s-a)/(o-a)*(n[c]-d)<e&&(h=!h)}c=i}return h}intersectsSegment(t,e,s,n){const r=this.polygons;for(let c=0,h=r.length;c<h;c++)if(this.intersectsSegmentPolygon(r[c],t,e,s,n))return this.boundingBoxes[c];return null}intersectsSegmentPolygon(t,e,s,n,r){const c=t,h=t.length,i=e-n,a=s-r,o=e*r-s*n;let d=c[h-2],f=c[h-1];for(let m=0;m<h;m+=2){const l=c[m],g=c[m+1],p=d*g-f*l,y=d-l,w=f-g,b=i*w-a*y,x=(o*y-i*p)/b;if((x>=d&&x<=l||x>=l&&x<=d)&&(x>=e&&x<=n||x>=n&&x<=e)){const S=(o*w-a*p)/b;if((S>=f&&S<=g||S>=g&&S<=f)&&(S>=s&&S<=r||S>=r&&S<=s))return!0}d=l,f=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const e=this.boundingBoxes.indexOf(t);return e==-1?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}};var bC=Object.defineProperty,xC=(u,t,e)=>t in u?bC(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ma=(u,t,e)=>xC(u,typeof t!="symbol"?t+"":t,e);class Fs{constructor(){ma(this,"convexPolygons",new Array),ma(this,"convexPolygonsIndices",new Array),ma(this,"indicesArray",new Array),ma(this,"isConcaveArray",new Array),ma(this,"triangles",new Array),ma(this,"polygonPool",new ml(()=>new Array)),ma(this,"polygonIndicesPool",new ml(()=>new Array))}triangulate(t){const e=t;let s=t.length>>1;const n=this.indicesArray;n.length=0;for(let h=0;h<s;h++)n[h]=h;const r=this.isConcaveArray;r.length=0;for(let h=0,i=s;h<i;++h)r[h]=Fs.isConcave(h,s,e,n);const c=this.triangles;for(c.length=0;s>3;){let h=s-1,i=0,a=1;for(;;){t:if(!r[i]){const f=n[h]<<1,m=n[i]<<1,l=n[a]<<1,g=e[f],p=e[f+1],y=e[m],w=e[m+1],b=e[l],x=e[l+1];for(let S=(a+1)%s;S!=h;S=(S+1)%s){if(!r[S])continue;const C=n[S]<<1,A=e[C],v=e[C+1];if(Fs.positiveArea(b,x,g,p,A,v)&&Fs.positiveArea(g,p,y,w,A,v)&&Fs.positiveArea(y,w,b,x,A,v))break t}break}if(a==0){do{if(!r[i])break;i--}while(i>0);break}h=i,i=a,a=(a+1)%s}c.push(n[(s+i-1)%s]),c.push(n[i]),c.push(n[(i+1)%s]),n.splice(i,1),r.splice(i,1),s--;const o=(s+i-1)%s,d=i==s?0:i;r[o]=Fs.isConcave(o,s,e,n),r[d]=Fs.isConcave(d,s,e,n)}return s==3&&(c.push(n[2]),c.push(n[0]),c.push(n[1])),c}decompose(t,e){const s=t,n=this.convexPolygons;this.polygonPool.freeAll(n),n.length=0;const r=this.convexPolygonsIndices;this.polygonIndicesPool.freeAll(r),r.length=0;let c=this.polygonIndicesPool.obtain();c.length=0;let h=this.polygonPool.obtain();h.length=0;let i=-1,a=0;for(let o=0,d=e.length;o<d;o+=3){const f=e[o]<<1,m=e[o+1]<<1,l=e[o+2]<<1,g=s[f],p=s[f+1],y=s[m],w=s[m+1],b=s[l],x=s[l+1];let S=!1;if(i==f){const C=h.length-4,A=Fs.winding(h[C],h[C+1],h[C+2],h[C+3],b,x),v=Fs.winding(b,x,h[0],h[1],h[2],h[3]);A==a&&v==a&&(h.push(b),h.push(x),c.push(l),S=!0)}S||(h.length>0?(n.push(h),r.push(c)):(this.polygonPool.free(h),this.polygonIndicesPool.free(c)),h=this.polygonPool.obtain(),h.length=0,h.push(g),h.push(p),h.push(y),h.push(w),h.push(b),h.push(x),c=this.polygonIndicesPool.obtain(),c.length=0,c.push(f),c.push(m),c.push(l),a=Fs.winding(g,p,y,w,b,x),i=f)}h.length>0&&(n.push(h),r.push(c));for(let o=0,d=n.length;o<d;o++){if(c=r[o],c.length==0)continue;const f=c[0],m=c[c.length-1];h=n[o];const l=h.length-4;let g=h[l],p=h[l+1],y=h[l+2],w=h[l+3];const b=h[0],x=h[1],S=h[2],C=h[3],A=Fs.winding(g,p,y,w,b,x);for(let v=0;v<d;v++){if(v==o)continue;const M=r[v];if(M.length!=3)continue;const E=M[0],T=M[1],R=M[2],k=n[v],I=k[k.length-2],P=k[k.length-1];if(E!=f||T!=m)continue;const F=Fs.winding(g,p,y,w,I,P),X=Fs.winding(I,P,b,x,S,C);F==A&&X==A&&(k.length=0,M.length=0,h.push(I),h.push(P),c.push(R),g=y,p=w,y=I,w=P,v=0)}}for(let o=n.length-1;o>=0;o--)h=n[o],h.length==0&&(n.splice(o,1),this.polygonPool.free(h),c=r[o],r.splice(o,1),this.polygonIndicesPool.free(c));return n}static isConcave(t,e,s,n){const r=n[(e+t-1)%e]<<1,c=n[t]<<1,h=n[(t+1)%e]<<1;return!this.positiveArea(s[r],s[r+1],s[c],s[c+1],s[h],s[h+1])}static positiveArea(t,e,s,n,r,c){return t*(c-n)+s*(e-c)+r*(n-e)>=0}static winding(t,e,s,n,r,c){const h=s-t,i=n-e;return r*i-c*h+h*e-t*i>=0?1:-1}}var wC=Object.defineProperty,yC=(u,t,e)=>t in u?wC(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Yr=(u,t,e)=>yC(u,typeof t!="symbol"?t+"":t,e);class El{constructor(){Yr(this,"triangulator",new Fs),Yr(this,"clippingPolygon",new Array),Yr(this,"clipOutput",new Array),Yr(this,"clippedVertices",new Array),Yr(this,"clippedUVs",new Array),Yr(this,"clippedTriangles",new Array),Yr(this,"scratch",new Array),Yr(this,"clipAttachment",null),Yr(this,"clippingPolygons",null)}clipStart(t,e){if(this.clipAttachment)return 0;this.clipAttachment=e;const s=e.worldVerticesLength,n=nt.setArraySize(this.clippingPolygon,s);e.computeWorldVertices(t,0,s,n,0,2);const r=this.clippingPolygon;El.makeClockwise(r);const c=this.clippingPolygons=this.triangulator.decompose(r,this.triangulator.triangulate(r));for(let h=0,i=c.length;h<i;h++){const a=c[h];El.makeClockwise(a),a.push(a[0]),a.push(a[1])}return c.length}clipEndWithSlot(t){this.clipAttachment&&this.clipAttachment.endSlot==t.data&&this.clipEnd()}clipEnd(){this.clipAttachment&&(this.clipAttachment=null,this.clippingPolygons=null,this.clippedVertices.length=0,this.clippedTriangles.length=0,this.clippingPolygon.length=0)}isClipping(){return this.clipAttachment!=null}clipTriangles(t,e,s,n,r,c,h,i){let a,o,d,f,m,l;typeof e=="number"?(a=s,o=n,d=r,f=c,m=h,l=i):(a=e,o=s,d=n,f=r,m=c,l=h),d&&f&&m&&typeof l=="boolean"?this.clipTrianglesRender(t,a,o,d,f,m,l):this.clipTrianglesNoRender(t,a,o)}clipTrianglesNoRender(t,e,s){const n=this.clipOutput,r=this.clippedVertices,c=this.clippedTriangles,h=this.clippingPolygons,i=h.length;let a=0;r.length=0,c.length=0;for(let o=0;o<s;o+=3){let d=e[o]<<1;const f=t[d],m=t[d+1];d=e[o+1]<<1;const l=t[d],g=t[d+1];d=e[o+2]<<1;const p=t[d],y=t[d+1];for(let w=0;w<i;w++){let b=r.length;if(this.clip(f,m,l,g,p,y,h[w],n)){const x=n.length;if(x==0)continue;let S=x>>1;const C=this.clipOutput,A=nt.setArraySize(r,b+S*2);for(let M=0;M<x;M+=2,b+=2){const E=C[M],T=C[M+1];A[b]=E,A[b+1]=T}b=c.length;const v=nt.setArraySize(c,b+3*(S-2));S--;for(let M=1;M<S;M++,b+=3)v[b]=a,v[b+1]=a+M,v[b+2]=a+M+1;a+=S+1}else{const x=nt.setArraySize(r,b+6);x[b]=f,x[b+1]=m,x[b+2]=l,x[b+3]=g,x[b+4]=p,x[b+5]=y,b=c.length;const S=nt.setArraySize(c,b+3);S[b]=a,S[b+1]=a+1,S[b+2]=a+2,a+=3;break}}}}clipTrianglesRender(t,e,s,n,r,c,h){const i=this.clipOutput,a=this.clippedVertices,o=this.clippedTriangles,d=this.clippingPolygons,f=d.length,m=h?12:8;let l=0;a.length=0,o.length=0;for(let g=0;g<s;g+=3){let p=e[g]<<1;const y=t[p],w=t[p+1],b=n[p],x=n[p+1];p=e[g+1]<<1;const S=t[p],C=t[p+1],A=n[p],v=n[p+1];p=e[g+2]<<1;const M=t[p],E=t[p+1],T=n[p],R=n[p+1];for(let k=0;k<f;k++){let I=a.length;if(this.clip(y,w,S,C,M,E,d[k],i)){const P=i.length;if(P==0)continue;const F=C-E,X=M-S,W=y-M,Y=E-w,_=1/(F*W+X*(w-E));let O=P>>1;const z=this.clipOutput,$=nt.setArraySize(a,I+O*m);for(let V=0;V<P;V+=2,I+=m){const rt=z[V],gt=z[V+1];$[I]=rt,$[I+1]=gt,$[I+2]=r.r,$[I+3]=r.g,$[I+4]=r.b,$[I+5]=r.a;const yt=rt-M,lt=gt-E,At=(F*yt+X*lt)*_,Ot=(Y*yt+W*lt)*_,ie=1-At-Ot;$[I+6]=b*At+A*Ot+T*ie,$[I+7]=x*At+v*Ot+R*ie,h&&($[I+8]=c.r,$[I+9]=c.g,$[I+10]=c.b,$[I+11]=c.a)}I=o.length;const N=nt.setArraySize(o,I+3*(O-2));O--;for(let V=1;V<O;V++,I+=3)N[I]=l,N[I+1]=l+V,N[I+2]=l+V+1;l+=O+1}else{const P=nt.setArraySize(a,I+3*m);P[I]=y,P[I+1]=w,P[I+2]=r.r,P[I+3]=r.g,P[I+4]=r.b,P[I+5]=r.a,h?(P[I+6]=b,P[I+7]=x,P[I+8]=c.r,P[I+9]=c.g,P[I+10]=c.b,P[I+11]=c.a,P[I+12]=S,P[I+13]=C,P[I+14]=r.r,P[I+15]=r.g,P[I+16]=r.b,P[I+17]=r.a,P[I+18]=A,P[I+19]=v,P[I+20]=c.r,P[I+21]=c.g,P[I+22]=c.b,P[I+23]=c.a,P[I+24]=M,P[I+25]=E,P[I+26]=r.r,P[I+27]=r.g,P[I+28]=r.b,P[I+29]=r.a,P[I+30]=T,P[I+31]=R,P[I+32]=c.r,P[I+33]=c.g,P[I+34]=c.b,P[I+35]=c.a):(P[I+6]=b,P[I+7]=x,P[I+8]=S,P[I+9]=C,P[I+10]=r.r,P[I+11]=r.g,P[I+12]=r.b,P[I+13]=r.a,P[I+14]=A,P[I+15]=v,P[I+16]=M,P[I+17]=E,P[I+18]=r.r,P[I+19]=r.g,P[I+20]=r.b,P[I+21]=r.a,P[I+22]=T,P[I+23]=R),I=o.length;const F=nt.setArraySize(o,I+3);F[I]=l,F[I+1]=l+1,F[I+2]=l+2,l+=3;break}}}}clipTrianglesUnpacked(t,e,s,n){const r=this.clipOutput,c=this.clippedVertices,h=this.clippedUVs,i=this.clippedTriangles,a=this.clippingPolygons,o=a.length;let d=0;c.length=0,h.length=0,i.length=0;for(let f=0;f<s;f+=3){let m=e[f]<<1;const l=t[m],g=t[m+1],p=n[m],y=n[m+1];m=e[f+1]<<1;const w=t[m],b=t[m+1],x=n[m],S=n[m+1];m=e[f+2]<<1;const C=t[m],A=t[m+1],v=n[m],M=n[m+1];for(let E=0;E<o;E++){let T=c.length;if(this.clip(l,g,w,b,C,A,a[E],r)){const R=r.length;if(R==0)continue;const k=b-A,I=C-w,P=l-C,F=A-g,X=1/(k*P+I*(g-A));let W=R>>1;const Y=this.clipOutput,_=nt.setArraySize(c,T+W*2),O=nt.setArraySize(h,T+W*2);for(let $=0;$<R;$+=2,T+=2){const N=Y[$],V=Y[$+1];_[T]=N,_[T+1]=V;const rt=N-C,gt=V-A,yt=(k*rt+I*gt)*X,lt=(F*rt+P*gt)*X,At=1-yt-lt;O[T]=p*yt+x*lt+v*At,O[T+1]=y*yt+S*lt+M*At}T=i.length;const z=nt.setArraySize(i,T+3*(W-2));W--;for(let $=1;$<W;$++,T+=3)z[T]=d,z[T+1]=d+$,z[T+2]=d+$+1;d+=W+1}else{const R=nt.setArraySize(c,T+6);R[T]=l,R[T+1]=g,R[T+2]=w,R[T+3]=b,R[T+4]=C,R[T+5]=A;const k=nt.setArraySize(h,T+3*2);k[T]=p,k[T+1]=y,k[T+2]=x,k[T+3]=S,k[T+4]=v,k[T+5]=M,T=i.length;const I=nt.setArraySize(i,T+3);I[T]=d,I[T+1]=d+1,I[T+2]=d+2,d+=3;break}}}}clip(t,e,s,n,r,c,h,i){const a=i;let o=!1,d;h.length%4>=2?(d=i,i=this.scratch):d=this.scratch,d.length=0,d.push(t),d.push(e),d.push(s),d.push(n),d.push(r),d.push(c),d.push(t),d.push(e),i.length=0;const f=h.length-4,m=h;for(let l=0;;l+=2){const g=m[l],p=m[l+1],y=g-m[l+2],w=p-m[l+3],b=i.length,x=d;for(let C=0,A=d.length-2;C<A;){const v=x[C],M=x[C+1];C+=2;const E=x[C],T=x[C+1],R=w*(g-E)>y*(p-T),k=w*(g-v)-y*(p-M);if(k>0){if(R){i.push(E),i.push(T);continue}const I=E-v,P=T-M,F=k/(I*w-P*y);if(F>=0&&F<=1)i.push(v+I*F),i.push(M+P*F);else{i.push(E),i.push(T);continue}}else if(R){const I=E-v,P=T-M,F=k/(I*w-P*y);if(F>=0&&F<=1)i.push(v+I*F),i.push(M+P*F),i.push(E),i.push(T);else{i.push(E),i.push(T);continue}}o=!0}if(b==i.length)return a.length=0,!0;if(i.push(i[0]),i.push(i[1]),l==f)break;const S=i;i=d,i.length=0,d=S}if(a!=i){a.length=0;for(let l=0,g=i.length-2;l<g;l++)a[l]=i[l]}else a.length=a.length-2;return o}static makeClockwise(t){const e=t,s=t.length;let n=e[s-2]*e[1]-e[0]*e[s-1],r=0,c=0,h=0,i=0;for(let a=0,o=s-3;a<o;a+=2)r=e[a],c=e[a+1],h=e[a+2],i=e[a+3],n+=r*i-h*c;if(!(n<0))for(let a=0,o=s-2,d=s>>1;a<d;a+=2){const f=e[a],m=e[a+1],l=o-a;e[a]=e[l],e[a+1]=e[l+1],e[l]=f,e[l+1]=m}}}var SC=Object.freeze({__proto__:null,AlphaTimeline:Ch,Animation:gl,AnimationState:om,AnimationStateAdapter:oy,AnimationStateData:Tm,AtlasAttachmentLoader:Gh,Attachment:oh,AttachmentTimeline:oa,BinaryInput:Sm,Bone:Hh,BoneData:Zh,BoundingBoxAttachment:Wh,CURRENT:um,ClippingAttachment:Uh,ConstraintData:Io,CurveTimeline:Bn,CurveTimeline1:xn,CurveTimeline2:pl,DeformTimeline:Mh,DrawOrderTimeline:Ra,Event:Qh,EventData:Jh,EventQueue:cm,EventTimeline:bl,EventType:hm,FIRST:Dh,HOLD_FIRST:yl,HOLD_MIX:dm,HOLD_SUBSEQUENT:Lh,IkConstraint:pm,IkConstraintData:jh,IkConstraintTimeline:Eh,InheritTimeline:wh,MeshAttachment:Sl,MixBlend:Ae,MixDirection:di,PathAttachment:To,PathConstraint:gm,PathConstraintData:zh,PathConstraintMixTimeline:Ph,PathConstraintPositionTimeline:Ih,PathConstraintSpacingTimeline:Rh,PhysicsConstraint:bm,PhysicsConstraintDampingTimeline:Yh,PhysicsConstraintData:td,PhysicsConstraintGravityTimeline:Xh,PhysicsConstraintInertiaTimeline:kh,PhysicsConstraintMassTimeline:$h,PhysicsConstraintMixTimeline:Bh,PhysicsConstraintResetTimeline:Vh,PhysicsConstraintStrengthTimeline:Fh,PhysicsConstraintTimeline:ui,PhysicsConstraintWindTimeline:_h,PointAttachment:mm,PositionMode:Pr,RGB2Timeline:vh,RGBA2Timeline:Ah,RGBATimeline:yh,RGBTimeline:Sh,RegionAttachment:qh,RotateMode:Pa,RotateTimeline:Eo,SETUP:Oh,SUBSEQUENT:wl,ScaleTimeline:fh,ScaleXTimeline:mh,ScaleYTimeline:gh,Sequence:lh,SequenceMode:dr,SequenceModeValues:ch,SequenceTimeline:Nh,ShearTimeline:ph,ShearXTimeline:bh,ShearYTimeline:xh,Skeleton:vl,SkeletonBinary:ym,SkeletonBounds:pC,SkeletonClipping:El,SkeletonData:ed,SkeletonJson:Cm,Skin:Ml,SkinEntry:sd,Slot:xm,SlotData:nd,SpacingMode:qe,Spine:class extends tm{createSkeleton(t){this.skeleton=new vl(t),this.skeleton.updateWorldTransform(li.update),this.stateData=new Tm(t),this.state=new om(this.stateData)}},Timeline:ne,TrackEntry:lm,TransformConstraint:wm,TransformConstraintData:rd,TransformConstraintTimeline:Th,TranslateTimeline:hh,TranslateXTimeline:dh,TranslateYTimeline:uh,Triangulator:Fs,VertexAttachment:hr});let CC=class extends Zd{createSkeleton(t){const e=za(t.version);let s=null;if(e===Je.VER37&&(s=JS),e===Je.VER38&&(s=iC),(e===Je.VER40||e===Je.VER41)&&(s=dC),e===Je.VER42&&(s=SC),!s){const n=`Cant detect version of spine model ${t.version}`;console.error(n)}console.log("version ",e,t,s),this.skeleton=new s.Skeleton(t),this.skeleton.updateWorldTransform(e===Je.VER42&&Bl.update),this.stateData=new s.AnimationStateData(t),this.state=new s.AnimationState(this.stateData),this.skeleton.setToSetupPose()}};new qS().installLoader();var hn=(u=>(u[u.Region=0]="Region",u[u.BoundingBox=1]="BoundingBox",u[u.Mesh=2]="Mesh",u[u.LinkedMesh=3]="LinkedMesh",u[u.Path=4]="Path",u[u.Point=5]="Point",u[u.Clipping=6]="Clipping",u))(hn||{});let AC=class{constructor(t,e=new Array,s=0,n=new DataView(t.buffer)){this.strings=e,this.index=s,this.buffer=n}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),s=e&127;return e&128&&(e=this.readByte(),s|=(e&127)<<7,e&128&&(e=this.readByte(),s|=(e&127)<<14,e&128&&(e=this.readByte(),s|=(e&127)<<21,e&128&&(e=this.readByte(),s|=(e&127)<<28)))),t?s:s>>>1^-(s&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let s=0;s<t;){const n=this.readUnsignedByte();switch(n>>4){case 12:case 13:e+=String.fromCharCode((n&31)<<6|this.readByte()&63),s+=2;break;case 14:e+=String.fromCharCode((n&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),s+=3;break;default:e+=String.fromCharCode(n),s++}}return e}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}};var Im=(u=>(u[u.setup=0]="setup",u[u.first=1]="first",u[u.replace=2]="replace",u[u.add=3]="add",u))(Im||{}),Rm=(u=>(u[u.mixIn=0]="mixIn",u[u.mixOut=1]="mixOut",u))(Rm||{}),Pm=(u=>(u[u.Fixed=0]="Fixed",u[u.Percent=1]="Percent",u))(Pm||{}),km=(u=>(u[u.Tangent=0]="Tangent",u[u.Chain=1]="Chain",u[u.ChainScale=2]="ChainScale",u))(km||{}),Fm=(u=>(u[u.Normal=0]="Normal",u[u.OnlyTranslation=1]="OnlyTranslation",u[u.NoRotationOrReflection=2]="NoRotationOrReflection",u[u.NoScale=3]="NoScale",u[u.NoScaleOrReflection=4]="NoScaleOrReflection",u))(Fm||{}),cd=(u=>(u[u.none=0]="none",u[u.reset=1]="reset",u[u.update=2]="update",u[u.pose=3]="pose",u))(cd||{}),vC=Object.defineProperty,MC=(u,t,e)=>t in u?vC(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Zt=(u,t,e)=>MC(u,typeof t!="symbol"?t+"":t,e);class EC{constructor(){Zt(this,"array",new Array)}add(t){const e=this.contains(t);return this.array[t|0]=t|0,!e}contains(t){return this.array[t|0]!=null}remove(t){this.array[t|0]=void 0}clear(){this.array.length=0}}let TC=class{constructor(){Zt(this,"entries",{}),Zt(this,"size",0)}add(t){const e=this.entries[t];return this.entries[t]=!0,e?!1:(this.size++,!0)}addAll(t){const e=this.size;for(let s=0,n=t.length;s<n;s++)this.add(t[s]);return e!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}};const Ln=class Ip{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new Ip().setFromString(t)}};Zt(Ln,"WHITE",new Ln(1,1,1,1)),Zt(Ln,"RED",new Ln(1,0,0,1)),Zt(Ln,"GREEN",new Ln(0,1,0,1)),Zt(Ln,"BLUE",new Ln(0,0,1,1)),Zt(Ln,"MAGENTA",new Ln(1,0,1,1));let IC=Ln;const Qs=class zo{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*zo.degRad)}static sinDeg(t){return Math.sin(t*zo.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*zo.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return zo.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};Zt(Qs,"PI",3.1415927),Zt(Qs,"PI2",Qs.PI*2),Zt(Qs,"invPI2",1/Qs.PI2),Zt(Qs,"radiansToDegrees",180/Qs.PI),Zt(Qs,"radDeg",Qs.radiansToDegrees),Zt(Qs,"degreesToRadians",Qs.PI/180),Zt(Qs,"degRad",Qs.degreesToRadians);let Ym=Qs;class $m{apply(t,e,s){return t+(e-t)*this.applyInternal(s)}}class _m extends $m{constructor(t){super(),Zt(this,"power",2),this.power=t}applyInternal(t){return t<=.5?Math.pow(t*2,this.power)/2:Math.pow((t-1)*2,this.power)/(this.power%2==0?-2:2)+1}}class RC extends _m{applyInternal(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1}}const Xm=class Ua{static arrayCopy(t,e,s,n,r){for(let c=e,h=n;c<e+r;c++,h++)s[h]=t[c]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:Ua.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(Ua.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(Ua.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return Ua.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return Ua.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}};Zt(Xm,"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");let hd=Xm;class PC{static logBones(t){for(let e=0;e<t.bones.length;e++){const s=t.bones[e],n=s.matrix;console.log(`${s.data.name}, ${n.a}, ${n.b}, ${n.c}, ${n.d}, ${n.tx}, ${n.ty}`)}}}let Bm=class{constructor(t){Zt(this,"items",new Array),Zt(this,"instantiator"),this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}},kC=class{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}};class FC{constructor(){Zt(this,"maxDelta",.064),Zt(this,"framesPerSecond",0),Zt(this,"delta",0),Zt(this,"totalTime",0),Zt(this,"lastTime",Date.now()/1e3),Zt(this,"frameCount",0),Zt(this,"frameTime",0)}update(){const t=Date.now()/1e3;this.delta=t-this.lastTime,this.frameTime+=this.delta,this.totalTime+=this.delta,this.delta>this.maxDelta&&(this.delta=this.maxDelta),this.lastTime=t,this.frameCount++,this.frameTime>1&&(this.framesPerSecond=this.frameCount/this.frameTime,this.frameTime=0,this.frameCount=0)}}class YC{constructor(t=32){Zt(this,"values"),Zt(this,"addedValues",0),Zt(this,"lastValue",0),Zt(this,"mean",0),Zt(this,"dirty",!0),this.values=new Array(t)}hasEnoughData(){return this.addedValues>=this.values.length}addValue(t){this.addedValues<this.values.length&&this.addedValues++,this.values[this.lastValue++]=t,this.lastValue>this.values.length-1&&(this.lastValue=0),this.dirty=!0}getMean(){if(this.hasEnoughData()){if(this.dirty){let t=0;for(let e=0;e<this.values.length;e++)t+=this.values[e];this.mean=t/this.values.length,this.dirty=!1}return this.mean}return 0}}var $C=Object.defineProperty,_C=(u,t,e)=>t in u?$C(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ga=(u,t,e)=>_C(u,typeof t!="symbol"?t+"":t,e);let Vm=class{constructor(){ga(this,"minX",0),ga(this,"minY",0),ga(this,"maxX",0),ga(this,"maxY",0),ga(this,"boundingBoxes",new Array),ga(this,"polygons",new Array),ga(this,"polygonPool",new Bm(()=>hd.newFloatArray(16)))}update(t,e){if(!t)throw new Error("skeleton cannot be null.");const s=this.boundingBoxes,n=this.polygons,r=this.polygonPool,c=t.slots,h=c.length;s.length=0,r.freeAll(n),n.length=0;for(let i=0;i<h;i++){const a=c[i];if(!a.bone.active)continue;const o=a.getAttachment();if(o!=null&&o.type===hn.BoundingBox){const d=o;s.push(d);let f=r.obtain();f.length!=d.worldVerticesLength&&(f=hd.newFloatArray(d.worldVerticesLength)),n.push(f),d.computeWorldVertices(a,0,d.worldVerticesLength,f,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY;const r=this.polygons;for(let c=0,h=r.length;c<h;c++){const i=r[c],a=i;for(let o=0,d=i.length;o<d;o+=2){const f=a[o],m=a[o+1];t=Math.min(t,f),e=Math.min(e,m),s=Math.max(s,f),n=Math.max(n,m)}}this.minX=t,this.minY=e,this.maxX=s,this.maxY=n}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,s,n){const r=this.minX,c=this.minY,h=this.maxX,i=this.maxY;if(t<=r&&s<=r||e<=c&&n<=c||t>=h&&s>=h||e>=i&&n>=i)return!1;const a=(n-e)/(s-t);let o=a*(r-t)+e;if(o>c&&o<i||(o=a*(h-t)+e,o>c&&o<i))return!0;let d=(c-e)/a+t;return d>r&&d<h||(d=(i-e)/a+t,d>r&&d<h)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){const s=this.polygons;for(let n=0,r=s.length;n<r;n++)if(this.containsPointPolygon(s[n],t,e))return this.boundingBoxes[n];return null}containsPointPolygon(t,e,s){const n=t,r=t.length;let c=r-2,h=!1;for(let i=0;i<r;i+=2){const a=n[i+1],o=n[c+1];if(a<s&&o>=s||o<s&&a>=s){const d=n[i];d+(s-a)/(o-a)*(n[c]-d)<e&&(h=!h)}c=i}return h}intersectsSegment(t,e,s,n){const r=this.polygons;for(let c=0,h=r.length;c<h;c++)if(this.intersectsSegmentPolygon(r[c],t,e,s,n))return this.boundingBoxes[c];return null}intersectsSegmentPolygon(t,e,s,n,r){const c=t,h=t.length,i=e-n,a=s-r,o=e*r-s*n;let d=c[h-2],f=c[h-1];for(let m=0;m<h;m+=2){const l=c[m],g=c[m+1],p=d*g-f*l,y=d-l,w=f-g,b=i*w-a*y,x=(o*y-i*p)/b;if((x>=d&&x<=l||x>=l&&x<=d)&&(x>=e&&x<=n||x>=n&&x<=e)){const S=(o*w-a*p)/b;if((S>=f&&S<=g||S>=g&&S<=f)&&(S>=s&&S<=r||S>=r&&S<=s))return!0}d=l,f=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const e=this.boundingBoxes.indexOf(t);return e==-1?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}};var XC=Object.defineProperty,BC=(u,t,e)=>t in u?XC(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ko=(u,t,e)=>BC(u,typeof t!="symbol"?t+"":t,e);function dd(u){switch(u.toLowerCase()){case"nearest":return 9728;case"linear":return 9729;case"mipmap":return 9987;case"mipmapnearestnearest":return 9984;case"mipmaplinearnearest":return 9985;case"mipmapnearestlinear":return 9986;case"mipmaplinearlinear":return 9987;default:throw new Error(`Unknown texture filter ${u}`)}}function VC(u){switch(u.toLowerCase()){case"mirroredtepeat":return 33648;case"clamptoedge":return 33071;case"repeat":return 10497;default:throw new Error(`Unknown texture wrap ${u}`)}}var bi=(u=>(u[u.Nearest=9728]="Nearest",u[u.Linear=9729]="Linear",u[u.MipMap=9987]="MipMap",u[u.MipMapNearestNearest=9984]="MipMapNearestNearest",u[u.MipMapLinearNearest=9985]="MipMapLinearNearest",u[u.MipMapNearestLinear=9986]="MipMapNearestLinear",u[u.MipMapLinearLinear=9987]="MipMapLinearLinear",u))(bi||{}),xi=(u=>(u[u.MirroredRepeat=33648]="MirroredRepeat",u[u.ClampToEdge=33071]="ClampToEdge",u[u.Repeat=10497]="Repeat",u))(xi||{});let Tl=class{constructor(){ko(this,"texture"),ko(this,"size",null),ko(this,"names",null),ko(this,"values",null),ko(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}};var NC=Object.defineProperty,DC=(u,t,e)=>t in u?NC(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,re=(u,t,e)=>DC(u,typeof t!="symbol"?t+"":t,e);class LC{constructor(){re(this,"x",0),re(this,"y",0),re(this,"width",0),re(this,"height",0),re(this,"offsetX",0),re(this,"offsetY",0),re(this,"originalWidth",0),re(this,"originalHeight",0),re(this,"rotate",0),re(this,"index",0)}}class OC{constructor(t,e,s){re(this,"pages",new Array),re(this,"regions",new Array),t&&this.addSpineAtlas(t,e,s)}addTexture(t,e){const s=this.pages;let n=null;for(let c=0;c<s.length;c++)if(s[c].baseTexture===e.baseTexture){n=s[c];break}if(n===null){n=new ud,n.name="texturePage";const c=e.baseTexture;n.width=c.realWidth,n.height=c.realHeight,n.baseTexture=c,n.minFilter=n.magFilter=bi.Nearest,n.uWrap=xi.ClampToEdge,n.vWrap=xi.ClampToEdge,s.push(n)}const r=new fd;return r.name=t,r.page=n,r.texture=e,r.index=-1,this.regions.push(r),r}addTextureHash(t,e){for(const s in t)t.hasOwnProperty(s)&&this.addTexture(e&&s.indexOf(".")!==-1?s.substr(0,s.lastIndexOf(".")):s,t[s])}addSpineAtlas(t,e,s){return this.load(t,e,s)}load(t,e,s){if(e==null)throw new Error("textureLoader cannot be null.");const n=new WC(t),r=new Array(4);let c=null;const h={};let i=null;h.size=()=>{c.width=parseInt(r[1]),c.height=parseInt(r[2])},h.format=()=>{},h.filter=()=>{c.minFilter=dd(r[1]),c.magFilter=dd(r[2])},h.repeat=()=>{r[1].indexOf("x")!=-1&&(c.uWrap=xi.Repeat),r[1].indexOf("y")!=-1&&(c.vWrap=xi.Repeat)},h.pma=()=>{c.pma=r[1]=="true"};const a={};a.xy=()=>{i.x=parseInt(r[1]),i.y=parseInt(r[2])},a.size=()=>{i.width=parseInt(r[1]),i.height=parseInt(r[2])},a.bounds=()=>{i.x=parseInt(r[1]),i.y=parseInt(r[2]),i.width=parseInt(r[3]),i.height=parseInt(r[4])},a.offset=()=>{i.offsetX=parseInt(r[1]),i.offsetY=parseInt(r[2])},a.orig=()=>{i.originalWidth=parseInt(r[1]),i.originalHeight=parseInt(r[2])},a.offsets=()=>{i.offsetX=parseInt(r[1]),i.offsetY=parseInt(r[2]),i.originalWidth=parseInt(r[3]),i.originalHeight=parseInt(r[4])},a.rotate=()=>{const f=r[1];let m=0;f.toLocaleLowerCase()=="true"?m=6:f.toLocaleLowerCase()=="false"?m=0:m=(720-parseFloat(f))%360/45,i.rotate=m},a.index=()=>{i.index=parseInt(r[1])};let o=n.readLine();for(;o!=null&&o.trim().length==0;)o=n.readLine();for(;!(o==null||o.trim().length==0||n.readEntry(r,o)==0);)o=n.readLine();const d=()=>{for(;;){if(o==null)return s&&s(this);if(o.trim().length==0)c=null,o=n.readLine();else if(c===null){for(c=new ud,c.name=o.trim();n.readEntry(r,o=n.readLine())!=0;){const f=h[r[0]];f&&f()}this.pages.push(c),e(c.name,f=>{if(f===null)return this.pages.splice(this.pages.indexOf(c),1),s&&s(null);c.baseTexture=f,c.pma&&(f.alphaMode=G.ALPHA_MODES.PMA),f.valid||f.setSize(c.width,c.height),c.setFilters(),(!c.width||!c.height)&&(c.width=f.realWidth,c.height=f.realHeight,(!c.width||!c.height)&&console.log(`ERROR spine atlas page ${c.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)),d()});break}else{i=new LC;const f=new fd;f.name=o,f.page=c;let m=null,l=null;for(;;){const x=n.readEntry(r,o=n.readLine());if(x==0)break;const S=a[r[0]];if(S)S();else{m==null&&(m=[],l=[]),m.push(r[0]);const C=[];for(let A=0;A<x;A++)C.push(parseInt(r[A+1]));l.push(C)}}i.originalWidth==0&&i.originalHeight==0&&(i.originalWidth=i.width,i.originalHeight=i.height);const g=c.baseTexture.resolution;i.x/=g,i.y/=g,i.width/=g,i.height/=g,i.originalWidth/=g,i.originalHeight/=g,i.offsetX/=g,i.offsetY/=g;const p=i.rotate%4!==0,y=new G.Rectangle(i.x,i.y,p?i.height:i.width,p?i.width:i.height),w=new G.Rectangle(0,0,i.originalWidth,i.originalHeight),b=new G.Rectangle(i.offsetX,i.originalHeight-i.height-i.offsetY,i.width,i.height);f.texture=new G.Texture(f.page.baseTexture,y,w,b,i.rotate),f.index=i.index,f.texture.updateUvs(),this.regions.push(f)}}};d()}findRegion(t){for(let e=0;e<this.regions.length;e++)if(this.regions[e].name==t)return this.regions[e];return null}dispose(){for(let t=0;t<this.pages.length;t++)this.pages[t].baseTexture.dispose()}}class WC{constructor(t){re(this,"lines"),re(this,"index",0),this.lines=t.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readEntry(t,e){if(e==null||(e=e.trim(),e.length==0))return 0;const s=e.indexOf(":");if(s==-1)return 0;t[0]=e.substr(0,s).trim();for(let n=1,r=s+1;;n++){const c=e.indexOf(",",r);if(c==-1)return t[n]=e.substr(r).trim(),n;if(t[n]=e.substr(r,c-r).trim(),r=c+1,n==4)return 4}}}class ud{constructor(){re(this,"name"),re(this,"minFilter",bi.Nearest),re(this,"magFilter",bi.Nearest),re(this,"uWrap",xi.ClampToEdge),re(this,"vWrap",xi.ClampToEdge),re(this,"baseTexture"),re(this,"width"),re(this,"height"),re(this,"pma")}setFilters(){const t=this.baseTexture,e=this.minFilter;e==bi.Linear?t.scaleMode=G.SCALE_MODES.LINEAR:this.minFilter==bi.Nearest?t.scaleMode=G.SCALE_MODES.NEAREST:(t.mipmap=G.MIPMAP_MODES.POW2,e==bi.MipMapNearestNearest?t.scaleMode=G.SCALE_MODES.NEAREST:t.scaleMode=G.SCALE_MODES.LINEAR)}}class fd extends Tl{constructor(){super(...arguments),re(this,"page"),re(this,"name"),re(this,"index")}}var md=(u=>(u[u.UNKNOWN=0]="UNKNOWN",u[u.VER37=37]="VER37",u[u.VER38=38]="VER38",u[u.VER40=40]="VER40",u[u.VER41=41]="VER41",u[u.VER42=42]="VER42",u))(md||{});function Nm(u){const t=u.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}const gd={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var UC=Object.defineProperty,qC=(u,t,e)=>t in u?UC(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,fs=(u,t,e)=>qC(u,typeof t!="symbol"?t+"":t,e);const wi=[0,0,0];let Dm=class extends zr.Sprite{constructor(){super(...arguments),fs(this,"region",null),fs(this,"attachment",null)}},Lm=class extends Gr.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),fs(this,"region",null),fs(this,"attachment",null)}};const Om=class Rp extends Lt.Container{constructor(t){if(super(),fs(this,"tintRgb"),fs(this,"spineData"),fs(this,"skeleton"),fs(this,"stateData"),fs(this,"state"),fs(this,"slotContainers"),fs(this,"tempClipContainers"),fs(this,"localDelayLimit"),fs(this,"_autoUpdate"),fs(this,"_visible"),fs(this,"_debug"),fs(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),c=this.newContainer();if(this.slotContainers.push(c),this.addChild(c),this.tempClipContainers.push(null),!!r)if(r.type===hn.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,c.addChild(i)}else if(r.type===hn.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,c.addChild(h)}else r.type===hn.Clipping&&(this.createGraphics(n,r),c.addChild(n.clippingContainer),c.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?Rp.prototype.autoUpdateTransform:Lt.Container.prototype.updateTransform)}get tint(){return G.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=G.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:gd.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=Nm(this.spineData.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===md.VER42&&cd.update);const n=this.skeleton.slots,r=this.color;let c=null,h=null;r?(c=r.light,h=r.dark):c=this.tintRgb;for(let f=0,m=n.length;f<m;f++){const l=n[f],g=l.getAttachment(),p=this.slotContainers[f];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(l,g);let w=g.region;const b=g.color;switch(g!=null&&g.type){case hn.Region:if(p.transform.setFromMatrix(l.bone.matrix),w=g.region,l.currentMesh&&(l.currentMesh.visible=!1,l.currentMesh=null,l.currentMeshId=void 0,l.currentMeshName=void 0),!w){l.currentSprite&&(l.currentSprite.renderable=!1);break}if(!l.currentSpriteName||l.currentSpriteName!==g.name){const C=g.name;if(l.currentSprite&&(l.currentSprite.visible=!1),l.sprites=l.sprites||{},l.sprites[C]!==void 0)l.sprites[C].visible=!0;else{const A=this.createSprite(l,g,C);p.addChild(A)}l.currentSprite=l.sprites[C],l.currentSpriteName=C}l.currentSprite.renderable=!0,l.hackRegion||this.setSpriteRegion(g,l.currentSprite,w),l.currentSprite.color?y=l.currentSprite.color:(wi[0]=c[0]*l.color.r*b.r,wi[1]=c[1]*l.color.g*b.g,wi[2]=c[2]*l.color.b*b.b,l.currentSprite.tint=G.utils.rgb2hex(wi)),l.currentSprite.blendMode=l.blendMode;break;case hn.Mesh:if(l.currentSprite){l.currentSprite.visible=!1,l.currentSprite=null,l.currentSpriteName=void 0;const C=new G.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){l.currentMesh&&(l.currentMesh.renderable=!1);break}const S=g.id;if(l.currentMeshId===void 0||l.currentMeshId!==S){const C=S;if(l.currentMesh&&(l.currentMesh.visible=!1),l.meshes=l.meshes||{},l.meshes[C]!==void 0)l.meshes[C].visible=!0;else{const A=this.createMesh(l,g);p.addChild(A)}l.currentMesh=l.meshes[C],l.currentMeshName=g.name,l.currentMeshId=C}l.currentMesh.renderable=!0,g.computeWorldVerticesOld(l,l.currentMesh.vertices),l.currentMesh.color?y=l.currentMesh.color:(wi[0]=c[0]*l.color.r*b.r,wi[1]=c[1]*l.color.g*b.g,wi[2]=c[2]*l.color.b*b.b,l.currentMesh.tint=G.utils.rgb2hex(wi)),l.currentMesh.blendMode=l.blendMode,l.hackRegion||this.setMeshRegion(g,l.currentMesh,w);break;case hn.Clipping:l.currentGraphics||(this.createGraphics(l,g),p.addChild(l.clippingContainer),p.addChild(l.currentGraphics)),this.updateGraphics(l,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let x=l.color.r*b.r,S=l.color.g*b.g,C=l.color.b*b.b;y.setLight(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C)),l.darkColor?(x=l.darkColor.r,S=l.darkColor.g,C=l.darkColor.b):(x=0,S=0,C=0),y.setDark(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C))}p.alpha=l.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let f=0,m=i.length;f<m;f++){const l=n[i[f].data.index],g=this.slotContainers[i[f].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),l.currentGraphics&&l.getAttachment())o=l.clippingContainer,a=l.getAttachment(),o.children.length=0,this.children[f]=g,a.endSlot===l.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[f];p||(p=this.tempClipContainers[f]=this.newContainer(),p.visible=!1),this.children[f]=p,g.parent=null,o.addChild(g),a.endSlot==l.data&&(o.renderable=!0,o=null,a=null)}else this.children[f]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*Ym.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){if(gd.GLOBAL_AUTO_UPDATE){this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}else this.lastTime=0;Lt.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,c=this.newSprite(r);return c.anchor.set(.5),n&&this.setSpriteRegion(e,c,e.region),t.sprites=t.sprites||{},t.sprites[s]=c,c}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),G.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new G.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let c=r.region;return e?(c=new Tl,c.texture=e,c.size=s,n.hackRegion=c,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,c):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,c),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),c=this.skeleton.getAttachmentByName(t,e);c.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=c.region;return s?(a=new Tl,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Lt.Container}newSprite(t){return new Dm(t)}newGraphics(){return new Ye.Graphics}newMesh(t,e,s,n,r){return new Lm(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let c=0,h=this.skeleton.slots.length;c<h;c++){const i=this.skeleton.slots[c],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};fs(Om,"clippingPolygon",[]);let Wm=Om;Object.defineProperty(Wm.prototype,"visible",{get(){return this._visible},set(u){u!==this._visible&&(this._visible=u,u&&(this.lastTime=0))}});var GC=Object.defineProperty,zC=(u,t,e)=>t in u?GC(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Me=(u,t,e)=>zC(u,typeof t!="symbol"?t+"":t,e);class HC{constructor(){Me(this,"registeredSpines",new Map),Me(this,"drawDebug",!0),Me(this,"drawMeshHull",!0),Me(this,"drawMeshTriangles",!0),Me(this,"drawBones",!0),Me(this,"drawPaths",!0),Me(this,"drawBoundingBoxes",!0),Me(this,"drawClipping",!0),Me(this,"drawRegionAttachments",!0),Me(this,"lineWidth",1),Me(this,"regionAttachmentsColor",30975),Me(this,"meshHullColor",30975),Me(this,"meshTrianglesColor",16763904),Me(this,"clippingPolygonColor",16711935),Me(this,"boundingBoxesRectColor",65280),Me(this,"boundingBoxesPolygonColor",65280),Me(this,"boundingBoxesCircleColor",65280),Me(this,"pathsCurveColor",16711680),Me(this,"pathsLineColor",16711935),Me(this,"skeletonXYColor",16711680),Me(this,"bonesColor",61132)}registerSpine(t){this.registeredSpines.has(t)&&console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!",t);const e={parentDebugContainer:new Lt.Container,bones:new Lt.Container,skeletonXY:new Ye.Graphics,regionAttachmentsShape:new Ye.Graphics,meshTrianglesLine:new Ye.Graphics,meshHullLine:new Ye.Graphics,clippingPolygon:new Ye.Graphics,boundingBoxesRect:new Ye.Graphics,boundingBoxesCircle:new Ye.Graphics,boundingBoxesPolygon:new Ye.Graphics,pathsCurve:new Ye.Graphics,pathsLine:new Ye.Graphics};e.parentDebugContainer.addChild(e.bones),e.parentDebugContainer.addChild(e.skeletonXY),e.parentDebugContainer.addChild(e.regionAttachmentsShape),e.parentDebugContainer.addChild(e.meshTrianglesLine),e.parentDebugContainer.addChild(e.meshHullLine),e.parentDebugContainer.addChild(e.clippingPolygon),e.parentDebugContainer.addChild(e.boundingBoxesRect),e.parentDebugContainer.addChild(e.boundingBoxesCircle),e.parentDebugContainer.addChild(e.boundingBoxesPolygon),e.parentDebugContainer.addChild(e.pathsCurve),e.parentDebugContainer.addChild(e.pathsLine),t.addChild(e.parentDebugContainer),this.registeredSpines.set(t,e)}renderDebug(t){this.registeredSpines.has(t)||this.registerSpine(t);const e=this.registeredSpines.get(t);e.skeletonXY.clear(),e.regionAttachmentsShape.clear(),e.meshTrianglesLine.clear(),e.meshHullLine.clear(),e.clippingPolygon.clear(),e.boundingBoxesRect.clear(),e.boundingBoxesCircle.clear(),e.boundingBoxesPolygon.clear(),e.pathsCurve.clear(),e.pathsLine.clear();for(let r=e.bones.children.length;r>0;r--)e.bones.children[r-1].destroy({children:!0,texture:!0,baseTexture:!0});const s=t.scale.x||t.scale.y||1,n=this.lineWidth/s;this.drawBones&&this.drawBonesFunc(t,e,n,s),this.drawPaths&&this.drawPathsFunc(t,e,n),this.drawBoundingBoxes&&this.drawBoundingBoxesFunc(t,e,n),this.drawClipping&&this.drawClippingFunc(t,e,n),(this.drawMeshHull||this.drawMeshTriangles)&&this.drawMeshHullAndMeshTriangles(t,e,n),this.drawRegionAttachments&&this.drawRegionAttachmentsFunc(t,e,n)}drawBonesFunc(t,e,s,n){const r=t.skeleton,c=r.x,h=r.y,i=r.bones;e.skeletonXY.lineStyle(s,this.skeletonXYColor,1);for(let o=0,d=i.length;o<d;o++){const f=i[o],m=f.data.length,l=c+f.matrix.tx,g=h+f.matrix.ty,p=c+m*f.matrix.a+f.matrix.tx,y=h+m*f.matrix.b+f.matrix.ty;if(f.data.name==="root"||f.data.parent===null)continue;const w=Math.abs(l-p),b=Math.abs(g-y),x=Math.pow(w,2),S=b,C=Math.pow(b,2),A=Math.sqrt(x+C),v=Math.pow(A,2),M=Math.PI/180,E=Math.acos((v+C-x)/(2*S*A))||0;if(A===0)continue;const T=new Ye.Graphics;e.bones.addChild(T);const R=A/50/n;T.beginFill(this.bonesColor,1),T.drawPolygon(0,0,0-R,A-R*3,0,A-R,0+R,A-R*3),T.endFill(),T.x=l,T.y=g,T.pivot.y=A;let k=0;l<p&&g<y?k=-E+180*M:l>p&&g<y?k=180*M+E:l>p&&g>y?k=-E:l<p&&g>y?k=E:g===y&&l<p?k=90*M:g===y&&l>p?k=-90*M:l===p&&g<y?k=180*M:l===p&&g>y&&(k=0),T.rotation=k,T.lineStyle(s+R/2.4,this.bonesColor,1),T.beginFill(0,.6),T.drawCircle(0,A,R*1.2),T.endFill()}const a=s*3;e.skeletonXY.moveTo(c-a,h-a),e.skeletonXY.lineTo(c+a,h+a),e.skeletonXY.moveTo(c+a,h-a),e.skeletonXY.lineTo(c-a,h+a)}drawRegionAttachmentsFunc(t,e,s){const r=t.skeleton.slots;e.regionAttachmentsShape.lineStyle(s,this.regionAttachmentsColor,1);for(let c=0,h=r.length;c<h;c++){const i=r[c],a=i.getAttachment();if(a==null||a.type!==hn.Region)continue;const o=a,d=new Float32Array(8);o.updateOffset&&o.updateOffset(),o.computeWorldVertices(i,d,0,2),e.regionAttachmentsShape.drawPolygon(Array.from(d.slice(0,8)))}}drawMeshHullAndMeshTriangles(t,e,s){const r=t.skeleton.slots;e.meshHullLine.lineStyle(s,this.meshHullColor,1),e.meshTrianglesLine.lineStyle(s,this.meshTrianglesColor,1);for(let c=0,h=r.length;c<h;c++){const i=r[c];if(!i.bone.active)continue;const a=i.getAttachment();if(a==null||a.type!==hn.Mesh)continue;const o=a,d=new Float32Array(o.worldVerticesLength),f=o.triangles;let m=o.hullLength;if(o.computeWorldVertices(i,0,o.worldVerticesLength,d,0,2),this.drawMeshTriangles)for(let l=0,g=f.length;l<g;l+=3){const p=f[l]*2,y=f[l+1]*2,w=f[l+2]*2;e.meshTrianglesLine.moveTo(d[p],d[p+1]),e.meshTrianglesLine.lineTo(d[y],d[y+1]),e.meshTrianglesLine.lineTo(d[w],d[w+1])}if(this.drawMeshHull&&m>0){m=(m>>1)*2;let l=d[m-2],g=d[m-1];for(let p=0,y=m;p<y;p+=2){const w=d[p],b=d[p+1];e.meshHullLine.moveTo(w,b),e.meshHullLine.lineTo(l,g),l=w,g=b}}}}drawClippingFunc(t,e,s){const r=t.skeleton.slots;e.clippingPolygon.lineStyle(s,this.clippingPolygonColor,1);for(let c=0,h=r.length;c<h;c++){const i=r[c];if(!i.bone.active)continue;const a=i.getAttachment();if(a==null||a.type!==hn.Clipping)continue;const o=a,d=o.worldVerticesLength,f=new Float32Array(d);o.computeWorldVertices(i,0,d,f,0,2),e.clippingPolygon.drawPolygon(Array.from(f))}}drawBoundingBoxesFunc(t,e,s){e.boundingBoxesRect.lineStyle(s,this.boundingBoxesRectColor,5);const n=new Vm;n.update(t.skeleton,!0),e.boundingBoxesRect.drawRect(n.minX,n.minY,n.getWidth(),n.getHeight());const r=n.polygons,c=(h,i,a)=>{if(e.boundingBoxesPolygon.lineStyle(s,this.boundingBoxesPolygonColor,1),e.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor,.1),a<3)throw new Error("Polygon must contain at least 3 vertices");const o=[],d=s*2;for(let f=0,m=h.length;f<m;f+=2){const l=h[f],g=h[f+1];e.boundingBoxesCircle.lineStyle(0),e.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor),e.boundingBoxesCircle.drawCircle(l,g,d),e.boundingBoxesCircle.endFill(),o.push(l,g)}e.boundingBoxesPolygon.drawPolygon(o),e.boundingBoxesPolygon.endFill()};for(let h=0,i=r.length;h<i;h++){const a=r[h];c(a,0,a.length)}}drawPathsFunc(t,e,s){const r=t.skeleton.slots;e.pathsCurve.lineStyle(s,this.pathsCurveColor,1),e.pathsLine.lineStyle(s,this.pathsLineColor,1);for(let c=0,h=r.length;c<h;c++){const i=r[c];if(!i.bone.active)continue;const a=i.getAttachment();if(a==null||a.type!==hn.Path)continue;const o=a;let d=o.worldVerticesLength;const f=new Float32Array(d);o.computeWorldVertices(i,0,d,f,0,2);let m=f[2],l=f[3],g=0,p=0;if(o.closed){const y=f[0],w=f[1],b=f[d-2],x=f[d-1];g=f[d-4],p=f[d-3],e.pathsCurve.moveTo(m,l),e.pathsCurve.bezierCurveTo(y,w,b,x,g,p),e.pathsLine.moveTo(m,l),e.pathsLine.lineTo(y,w),e.pathsLine.moveTo(g,p),e.pathsLine.lineTo(b,x)}d-=4;for(let y=4;y<d;y+=6){const w=f[y],b=f[y+1],x=f[y+2],S=f[y+3];g=f[y+4],p=f[y+5],e.pathsCurve.moveTo(m,l),e.pathsCurve.bezierCurveTo(w,b,x,S,g,p),e.pathsLine.moveTo(m,l),e.pathsLine.lineTo(w,b),e.pathsLine.moveTo(g,p),e.pathsLine.lineTo(x,S),m=g,l=p}}}unregisterSpine(t){this.registeredSpines.has(t)||console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!",t),this.registeredSpines.get(t).parentDebugContainer.destroy({baseTexture:!0,children:!0,texture:!0}),this.registeredSpines.delete(t)}}var KC=Object.defineProperty,ZC=(u,t,e)=>t in u?KC(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ms=(u,t,e)=>ZC(u,typeof t!="symbol"?t+"":t,e);class Um{constructor(){ms(this,"entries",{}),ms(this,"size",0)}add(t){const e=this.entries[t];return this.entries[t]=!0,e?!1:(this.size++,!0)}addAll(t){const e=this.size;for(let s=0,n=t.length;s<n;s++)this.add(t[s]);return e!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}}const On=class Pp{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new Pp().setFromString(t)}};ms(On,"WHITE",new On(1,1,1,1)),ms(On,"RED",new On(1,0,0,1)),ms(On,"GREEN",new On(0,1,0,1)),ms(On,"BLUE",new On(0,0,1,1)),ms(On,"MAGENTA",new On(1,0,1,1));let Ft=On;const Js=class Ho{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*Ho.degRad)}static sinDeg(t){return Math.sin(t*Ho.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*Ho.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return Ho.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};ms(Js,"PI",3.1415927),ms(Js,"PI2",Js.PI*2),ms(Js,"invPI2",1/Js.PI2),ms(Js,"radiansToDegrees",180/Js.PI),ms(Js,"radDeg",Js.radiansToDegrees),ms(Js,"degreesToRadians",Js.PI/180),ms(Js,"degRad",Js.degreesToRadians);let Q=Js;const qm=class qa{static arrayCopy(t,e,s,n,r){for(let c=e,h=n;c<e+r;c++,h++)s[h]=t[c]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:qa.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(qa.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(qa.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return qa.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return qa.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}};ms(qm,"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");let dt=qm;class Gm{constructor(t){ms(this,"items",new Array),ms(this,"instantiator"),this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}}class pd{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}}var Ee=(u=>(u[u.Region=0]="Region",u[u.BoundingBox=1]="BoundingBox",u[u.Mesh=2]="Mesh",u[u.LinkedMesh=3]="LinkedMesh",u[u.Path=4]="Path",u[u.Point=5]="Point",u[u.Clipping=6]="Clipping",u))(Ee||{}),dn=(u=>(u[u.Normal=0]="Normal",u[u.OnlyTranslation=1]="OnlyTranslation",u[u.NoRotationOrReflection=2]="NoRotationOrReflection",u[u.NoScale=3]="NoScale",u[u.NoScaleOrReflection=4]="NoScaleOrReflection",u))(dn||{}),zm=(u=>(u[u.none=0]="none",u[u.reset=1]="reset",u[u.update=2]="update",u[u.pose=3]="pose",u))(zm||{}),QC=Object.defineProperty,JC=(u,t,e)=>t in u?QC(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Fo=(u,t,e)=>JC(u,typeof t!="symbol"?t+"":t,e);class Hm{constructor(){Fo(this,"texture"),Fo(this,"size",null),Fo(this,"names",null),Fo(this,"values",null),Fo(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}}var Km=(u=>(u[u.UNKNOWN=0]="UNKNOWN",u[u.VER37=37]="VER37",u[u.VER38=38]="VER38",u[u.VER40=40]="VER40",u[u.VER41=41]="VER41",u[u.VER42=42]="VER42",u))(Km||{});function jC(u){const t=u.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}const tA={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var eA=Object.defineProperty,sA=(u,t,e)=>t in u?eA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,gs=(u,t,e)=>sA(u,typeof t!="symbol"?t+"":t,e);const yi=[0,0,0];class nA extends zr.Sprite{constructor(){super(...arguments),gs(this,"region",null),gs(this,"attachment",null)}}class rA extends Gr.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),gs(this,"region",null),gs(this,"attachment",null)}}const Zm=class kp extends Lt.Container{constructor(t){if(super(),gs(this,"tintRgb"),gs(this,"spineData"),gs(this,"skeleton"),gs(this,"stateData"),gs(this,"state"),gs(this,"slotContainers"),gs(this,"tempClipContainers"),gs(this,"localDelayLimit"),gs(this,"_autoUpdate"),gs(this,"_visible"),gs(this,"_debug"),gs(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),c=this.newContainer();if(this.slotContainers.push(c),this.addChild(c),this.tempClipContainers.push(null),!!r)if(r.type===Ee.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,c.addChild(i)}else if(r.type===Ee.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,c.addChild(h)}else r.type===Ee.Clipping&&(this.createGraphics(n,r),c.addChild(n.clippingContainer),c.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?kp.prototype.autoUpdateTransform:Lt.Container.prototype.updateTransform)}get tint(){return G.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=G.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:tA.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=jC(this.spineData.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===Km.VER42&&zm.update);const n=this.skeleton.slots,r=this.color;let c=null,h=null;r?(c=r.light,h=r.dark):c=this.tintRgb;for(let f=0,m=n.length;f<m;f++){const l=n[f],g=l.getAttachment(),p=this.slotContainers[f];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(l,g);let w=g.region;const b=g.color;switch(g!=null&&g.type){case Ee.Region:if(p.transform.setFromMatrix(l.bone.matrix),w=g.region,l.currentMesh&&(l.currentMesh.visible=!1,l.currentMesh=null,l.currentMeshId=void 0,l.currentMeshName=void 0),!w){l.currentSprite&&(l.currentSprite.renderable=!1);break}if(!l.currentSpriteName||l.currentSpriteName!==g.name){const C=g.name;if(l.currentSprite&&(l.currentSprite.visible=!1),l.sprites=l.sprites||{},l.sprites[C]!==void 0)l.sprites[C].visible=!0;else{const A=this.createSprite(l,g,C);p.addChild(A)}l.currentSprite=l.sprites[C],l.currentSpriteName=C}l.currentSprite.renderable=!0,l.hackRegion||this.setSpriteRegion(g,l.currentSprite,w),l.currentSprite.color?y=l.currentSprite.color:(yi[0]=c[0]*l.color.r*b.r,yi[1]=c[1]*l.color.g*b.g,yi[2]=c[2]*l.color.b*b.b,l.currentSprite.tint=G.utils.rgb2hex(yi)),l.currentSprite.blendMode=l.blendMode;break;case Ee.Mesh:if(l.currentSprite){l.currentSprite.visible=!1,l.currentSprite=null,l.currentSpriteName=void 0;const C=new G.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){l.currentMesh&&(l.currentMesh.renderable=!1);break}const S=g.id;if(l.currentMeshId===void 0||l.currentMeshId!==S){const C=S;if(l.currentMesh&&(l.currentMesh.visible=!1),l.meshes=l.meshes||{},l.meshes[C]!==void 0)l.meshes[C].visible=!0;else{const A=this.createMesh(l,g);p.addChild(A)}l.currentMesh=l.meshes[C],l.currentMeshName=g.name,l.currentMeshId=C}l.currentMesh.renderable=!0,g.computeWorldVerticesOld(l,l.currentMesh.vertices),l.currentMesh.color?y=l.currentMesh.color:(yi[0]=c[0]*l.color.r*b.r,yi[1]=c[1]*l.color.g*b.g,yi[2]=c[2]*l.color.b*b.b,l.currentMesh.tint=G.utils.rgb2hex(yi)),l.currentMesh.blendMode=l.blendMode,l.hackRegion||this.setMeshRegion(g,l.currentMesh,w);break;case Ee.Clipping:l.currentGraphics||(this.createGraphics(l,g),p.addChild(l.clippingContainer),p.addChild(l.currentGraphics)),this.updateGraphics(l,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let x=l.color.r*b.r,S=l.color.g*b.g,C=l.color.b*b.b;y.setLight(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C)),l.darkColor?(x=l.darkColor.r,S=l.darkColor.g,C=l.darkColor.b):(x=0,S=0,C=0),y.setDark(c[0]*x+h[0]*(1-x),c[1]*S+h[1]*(1-S),c[2]*C+h[2]*(1-C))}p.alpha=l.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let f=0,m=i.length;f<m;f++){const l=n[i[f].data.index],g=this.slotContainers[i[f].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),l.currentGraphics&&l.getAttachment())o=l.clippingContainer,a=l.getAttachment(),o.children.length=0,this.children[f]=g,a.endSlot===l.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[f];p||(p=this.tempClipContainers[f]=this.newContainer(),p.visible=!1),this.children[f]=p,g.parent=null,o.addChild(g),a.endSlot==l.data&&(o.renderable=!0,o=null,a=null)}else this.children[f]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*Q.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}Lt.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,c=this.newSprite(r);return c.anchor.set(.5),n&&this.setSpriteRegion(e,c,e.region),t.sprites=t.sprites||{},t.sprites[s]=c,c}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),G.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new G.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let c=r.region;return e?(c=new Hm,c.texture=e,c.size=s,n.hackRegion=c,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,c):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,c),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),c=this.skeleton.getAttachmentByName(t,e);c.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=c.region;return s?(a=new Hm,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Lt.Container}newSprite(t){return new nA(t)}newGraphics(){return new Ye.Graphics}newMesh(t,e,s,n,r){return new rA(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let c=0,h=this.skeleton.slots.length;c<h;c++){const i=this.skeleton.slots[c],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};gs(Zm,"clippingPolygon",[]);let Qm=Zm;Object.defineProperty(Qm.prototype,"visible",{get(){return this._visible},set(u){u!==this._visible&&(this._visible=u,u&&(this.lastTime=0))}});var iA=Object.defineProperty,aA=(u,t,e)=>t in u?iA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Si=(u,t,e)=>aA(u,typeof t!="symbol"?t+"":t,e);class Jm{constructor(t){if(Si(this,"name"),Si(this,"type"),!t)throw new Error("name cannot be null.");this.name=t}}const jm=class Fp extends Jm{constructor(t){super(t),Si(this,"id",Fp.nextID++),Si(this,"bones",null),Si(this,"vertices",[]),Si(this,"worldVerticesLength",0),Si(this,"timelineAttachment",this)}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,s,n,r,c){s=r+(s>>1)*c;const h=t.bone.skeleton,i=t.deform;let a=this.vertices;const o=this.bones;if(!o){i.length>0&&(a=i);const l=t.bone.matrix,g=l.tx,p=l.ty,y=l.a,w=l.c,b=l.b,x=l.d;for(let S=e,C=r;C<s;S+=2,C+=c){const A=a[S],v=a[S+1];n[C]=A*y+v*w+g,n[C+1]=A*b+v*x+p}return}let d=0,f=0;for(let l=0;l<e;l+=2){const g=o[d];d+=g+1,f+=g}const m=h.bones;if(i.length==0)for(let l=r,g=f*3;l<s;l+=c){let p=0,y=0,w=o[d++];for(w+=d;d<w;d++,g+=3){const b=m[o[d]].matrix,x=a[g],S=a[g+1],C=a[g+2];p+=(x*b.a+S*b.c+b.tx)*C,y+=(x*b.b+S*b.d+b.ty)*C}n[l]=p,n[l+1]=y}else{const l=i;for(let g=r,p=f*3,y=f<<1;g<s;g+=c){let w=0,b=0,x=o[d++];for(x+=d;d<x;d++,p+=3,y+=2){const S=m[o[d]].matrix,C=a[p]+l[y],A=a[p+1]+l[y+1],v=a[p+2];w+=(C*S.a+A*S.c+S.tx)*v,b+=(C*S.b+A*S.d+S.ty)*v}n[g]=w,n[g+1]=b}}}copyTo(t){this.bones?(t.bones=new Array(this.bones.length),dt.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices&&(t.vertices=dt.newFloatArray(this.vertices.length),dt.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)),t.worldVerticesLength=this.worldVerticesLength,t.timelineAttachment=this.timelineAttachment}};Si(jm,"nextID",0);let $r=jm;var oA=Object.defineProperty,lA=(u,t,e)=>t in u?oA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,tg=(u,t,e)=>lA(u,typeof t!="symbol"?t+"":t,e);class bd extends $r{constructor(t){super(t),tg(this,"type",Ee.BoundingBox),tg(this,"color",new Ft(1,1,1,1))}copy(){const t=new bd(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}var cA=Object.defineProperty,hA=(u,t,e)=>t in u?cA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,xd=(u,t,e)=>hA(u,typeof t!="symbol"?t+"":t,e);class wd extends $r{constructor(t){super(t),xd(this,"type",Ee.Clipping),xd(this,"endSlot",null),xd(this,"color",new Ft(.2275,.2275,.8078,1))}copy(){const t=new wd(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}var dA=Object.defineProperty,uA=(u,t,e)=>t in u?dA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,un=(u,t,e)=>uA(u,typeof t!="symbol"?t+"":t,e);class ka extends $r{constructor(t,e){super(t),un(this,"type",Ee.Mesh),un(this,"region",null),un(this,"path"),un(this,"regionUVs"),un(this,"triangles",[]),un(this,"color",new Ft(1,1,1,1)),un(this,"width",0),un(this,"height",0),un(this,"hullLength",0),un(this,"edges",[]),un(this,"parentMesh",null),un(this,"sequence",null),un(this,"tempColor",new Ft(0,0,0,0)),this.path=e}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new ka(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),dt.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),dt.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,t.sequence=this.sequence!=null?this.sequence.copy():null,this.edges&&(t.edges=new Array(this.edges.length),dt.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}computeWorldVertices(t,e,s,n,r,c){this.sequence!=null&&this.sequence.apply(t,this),super.computeWorldVertices(t,e,s,n,r,c)}newLinkedMesh(){const t=new ka(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),t.timelineAttachment=this.timelineAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}}var fA=Object.defineProperty,mA=(u,t,e)=>t in u?fA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Yo=(u,t,e)=>mA(u,typeof t!="symbol"?t+"":t,e);class Fa extends $r{constructor(t){super(t),Yo(this,"type",Ee.Path),Yo(this,"lengths",[]),Yo(this,"closed",!1),Yo(this,"constantSpeed",!1),Yo(this,"color",new Ft(1,1,1,1))}copy(){const t=new Fa(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),dt.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}var gA=Object.defineProperty,pA=(u,t,e)=>t in u?gA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,$o=(u,t,e)=>pA(u,typeof t!="symbol"?t+"":t,e);class yd extends $r{constructor(t){super(t),$o(this,"type",Ee.Point),$o(this,"x",0),$o(this,"y",0),$o(this,"rotation",0),$o(this,"color",new Ft(.38,.94,0,1))}computeWorldPosition(t,e){const s=t.matrix;return e.x=this.x*s.a+this.y*s.c+t.worldX,e.y=this.x*s.b+this.y*s.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,s=Q.cosDeg(this.rotation),n=Q.sinDeg(this.rotation),r=s*e.a+n*e.c,c=s*e.b+n*e.d;return Math.atan2(c,r)*Q.radDeg}copy(){const t=new yd(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}var bA=Object.defineProperty,xA=(u,t,e)=>t in u?bA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,wt=(u,t,e)=>xA(u,typeof t!="symbol"?t+"":t,e);const zt=class Yp extends Jm{constructor(t,e){super(t),wt(this,"type",Ee.Region),wt(this,"x",0),wt(this,"y",0),wt(this,"scaleX",1),wt(this,"scaleY",1),wt(this,"rotation",0),wt(this,"width",0),wt(this,"height",0),wt(this,"color",new Ft(1,1,1,1)),wt(this,"path"),wt(this,"rendererObject",null),wt(this,"region",null),wt(this,"sequence",null),wt(this,"offset",dt.newFloatArray(8)),wt(this,"uvs",dt.newFloatArray(8)),wt(this,"tempColor",new Ft(1,1,1,1)),this.path=e}updateRegion(){if(!this.region)throw new Error("Region not set.");const t=this.region,e=this.width/this.region.originalWidth*this.scaleX,s=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*e,r=-this.height/2*this.scaleY+this.region.offsetY*s,c=n+this.region.width*e,h=r+this.region.height*s,i=this.rotation*Math.PI/180,a=Math.cos(i),o=Math.sin(i),d=this.x,f=this.y,m=n*a+d,l=n*o,g=r*a+f,p=r*o,y=c*a+d,w=c*o,b=h*a+f,x=h*o,S=this.offset;S[0]=m-p,S[1]=g+l,S[2]=m-x,S[3]=b+l,S[4]=y-x,S[5]=b+w,S[6]=y-p,S[7]=g+w;const C=this.uvs;t.degrees==90?(C[2]=t.u,C[3]=t.v2,C[4]=t.u,C[5]=t.v,C[6]=t.u2,C[7]=t.v,C[0]=t.u2,C[1]=t.v2):(C[0]=t.u,C[1]=t.v2,C[2]=t.u,C[3]=t.v,C[4]=t.u2,C[5]=t.v,C[6]=t.u2,C[7]=t.v2)}computeWorldVertices(t,e,s,n){this.sequence!=null&&this.sequence.apply(t,this);const r=t.bone,c=this.offset,h=r.matrix,i=h.tx,a=h.ty,o=h.a,d=h.c,f=h.b,m=h.d;let l=0,g=0;l=c[0],g=c[1],e[s]=l*o+g*d+i,e[s+1]=l*f+g*m+a,s+=n,l=c[2],g=c[3],e[s]=l*o+g*d+i,e[s+1]=l*f+g*m+a,s+=n,l=c[4],g=c[5],e[s]=l*o+g*d+i,e[s+1]=l*f+g*m+a,s+=n,l=c[6],g=c[7],e[s]=l*o+g*d+i,e[s+1]=l*f+g*m+a}copy(){const t=new Yp(this.name,this.path);return t.region=this.region,t.rendererObject=this.rendererObject,t.x=this.x,t.y=this.y,t.scaleX=this.scaleX,t.scaleY=this.scaleY,t.rotation=this.rotation,t.width=this.width,t.height=this.height,dt.arrayCopy(this.uvs,0,t.uvs,0,8),dt.arrayCopy(this.offset,0,t.offset,0,8),t.color.setFromColor(this.color),t.sequence=this.sequence!=null?this.sequence.copy():null,t}};wt(zt,"X1",0),wt(zt,"Y1",1),wt(zt,"C1R",2),wt(zt,"C1G",3),wt(zt,"C1B",4),wt(zt,"C1A",5),wt(zt,"U1",6),wt(zt,"V1",7),wt(zt,"X2",8),wt(zt,"Y2",9),wt(zt,"C2R",10),wt(zt,"C2G",11),wt(zt,"C2B",12),wt(zt,"C2A",13),wt(zt,"U2",14),wt(zt,"V2",15),wt(zt,"X3",16),wt(zt,"Y3",17),wt(zt,"C3R",18),wt(zt,"C3G",19),wt(zt,"C3B",20),wt(zt,"C3A",21),wt(zt,"U3",22),wt(zt,"V3",23),wt(zt,"X4",24),wt(zt,"Y4",25),wt(zt,"C4R",26),wt(zt,"C4G",27),wt(zt,"C4B",28),wt(zt,"C4A",29),wt(zt,"U4",30),wt(zt,"V4",31);let eg=zt;var wA=Object.defineProperty,yA=(u,t,e)=>t in u?wA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ya=(u,t,e)=>yA(u,typeof t!="symbol"?t+"":t,e);const sg=class $l{constructor(t){Ya(this,"id",$l.nextID()),Ya(this,"regions"),Ya(this,"start",0),Ya(this,"digits",0),Ya(this,"setupIndex",0),this.regions=new Array(t)}copy(){const t=new $l(this.regions.length);return dt.arrayCopy(this.regions,0,t.regions,0,this.regions.length),t.start=this.start,t.digits=this.digits,t.setupIndex=this.setupIndex,t}apply(t,e){let s=t.sequenceIndex;s==-1&&(s=this.setupIndex),s>=this.regions.length&&(s=this.regions.length-1);const n=this.regions[s];e.region!=n&&(e.region=n)}getPath(t,e){let s=t;const n=(this.start+e).toString();for(let r=this.digits-n.length;r>0;r--)s+="0";return s+=n,s}static nextID(){return $l._nextID++}};Ya(sg,"_nextID",0);let ng=sg;var _r=(u=>(u[u.hold=0]="hold",u[u.once=1]="once",u[u.loop=2]="loop",u[u.pingpong=3]="pingpong",u[u.onceReverse=4]="onceReverse",u[u.loopReverse=5]="loopReverse",u[u.pingpongReverse=6]="pingpongReverse",u))(_r||{});const rg=[0,1,2,3,4,5,6];var q=(u=>(u[u.setup=0]="setup",u[u.first=1]="first",u[u.replace=2]="replace",u[u.add=3]="add",u))(q||{}),js=(u=>(u[u.mixIn=0]="mixIn",u[u.mixOut=1]="mixOut",u))(js||{}),SA=Object.defineProperty,CA=(u,t,e)=>t in u?SA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,It=(u,t,e)=>CA(u,typeof t!="symbol"?t+"":t,e);class Sd{constructor(t,e,s){if(It(this,"name"),It(this,"timelines",[]),It(this,"timelineIds",new Um),It(this,"duration"),!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(e),this.duration=s}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(let e=0;e<t.length;e++)this.timelineIds.addAll(t[e].getPropertyIds())}hasTimeline(t){for(let e=0;e<t.length;e++)if(this.timelineIds.contains(t[e]))return!0;return!1}apply(t,e,s,n,r,c,h,i){if(!t)throw new Error("skeleton cannot be null.");n&&this.duration!=0&&(s%=this.duration,e>0&&(e%=this.duration));const a=this.timelines;for(let o=0,d=a.length;o<d;o++)a[o].apply(t,e,s,r,c,h,i)}}const Kt={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,rgb:7,alpha:8,rgb2:9,attachment:10,deform:11,event:12,drawOrder:13,ikConstraint:14,transformConstraint:15,pathConstraintPosition:16,pathConstraintSpacing:17,pathConstraintMix:18,sequence:19};class Te{constructor(t,e){It(this,"propertyIds"),It(this,"frames"),this.propertyIds=e,this.frames=dt.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,e){const s=t.length;for(let n=1;n<s;n++)if(t[n]>e)return n-1;return s-1}static search(t,e,s){const n=t.length;for(let r=s;r<n;r+=s)if(t[r]>e)return r-s;return n-s}}class mr extends Te{constructor(t,e,s){super(t,s),It(this,"curves"),this.curves=dt.newFloatArray(t+e*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const e=this.getFrameCount()+t*18;if(this.curves.length>e){const s=dt.newFloatArray(e);dt.arrayCopy(this.curves,0,s,0,e),this.curves=s}}setBezier(t,e,s,n,r,c,h,i,a,o,d){const f=this.curves;let m=this.getFrameCount()+t*18;s==0&&(f[e]=2+m);const l=(n-c*2+i)*.03,g=(r-h*2+a)*.03,p=((c-i)*3-n+o)*.006,y=((h-a)*3-r+d)*.006;let w=l*2+p,b=g*2+y,x=(c-n)*.3+l+p*.16666667,S=(h-r)*.3+g+y*.16666667,C=n+x,A=r+S;for(let v=m+18;m<v;m+=2)f[m]=C,f[m+1]=A,x+=w,S+=b,w+=p,b+=y,C+=x,A+=S}getBezierValue(t,e,s,n){const r=this.curves;if(r[n]>t){const a=this.frames[e],o=this.frames[e+s];return o+(t-a)/(r[n]-a)*(r[n+1]-o)}const c=n+18;for(n+=2;n<c;n+=2)if(r[n]>=t){const a=r[n-2],o=r[n-1];return o+(t-a)/(r[n]-a)*(r[n+1]-o)}e+=this.getFrameEntries();const h=r[c-2],i=r[c-1];return i+(t-h)/(this.frames[e]-h)*(this.frames[e+s]-i)}}class gr extends mr{constructor(t,e,s){super(t,e,[s])}getFrameEntries(){return 2}setFrame(t,e,s){t<<=1,this.frames[t]=e,this.frames[t+1]=s}getCurveValue(t){const e=this.frames;let s=e.length-2;for(let r=2;r<=s;r+=2)if(e[r]>t){s=r-2;break}const n=this.curves[s>>1];switch(n){case 0:const r=e[s],c=e[s+1];return c+(t-r)/(e[s+2]-r)*(e[s+2+1]-c);case 1:return e[s+1]}return this.getBezierValue(t,s,1,n-2)}}class Cd extends mr{constructor(t,e,s,n){super(t,e,[s,n])}getFrameEntries(){return 3}setFrame(t,e,s,n){t*=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n}}class Il extends gr{constructor(t,e,s){super(t,e,`${Kt.rotate}|${s}`),It(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case q.setup:i.rotation=i.data.rotation;return;case q.first:i.rotation+=(i.data.rotation-i.rotation)*r}return}let o=this.getCurveValue(s);switch(c){case q.setup:i.rotation=i.data.rotation+o*r;break;case q.first:case q.replace:o+=i.data.rotation-i.rotation;case q.add:i.rotation+=o*r}}}class ig extends Cd{constructor(t,e,s){super(t,e,`${Kt.x}|${s}`,`${Kt.y}|${s}`),It(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case q.setup:i.x=i.data.x,i.y=i.data.y;return;case q.first:i.x+=(i.data.x-i.x)*r,i.y+=(i.data.y-i.y)*r}return}let o=0,d=0;const f=Te.search(a,s,3),m=this.curves[f/3];switch(m){case 0:const l=a[f];o=a[f+1],d=a[f+2];const g=(s-l)/(a[f+3]-l);o+=(a[f+3+1]-o)*g,d+=(a[f+3+2]-d)*g;break;case 1:o=a[f+1],d=a[f+2];break;default:o=this.getBezierValue(s,f,1,m-2),d=this.getBezierValue(s,f,2,m+18-2)}switch(c){case q.setup:i.x=i.data.x+o*r,i.y=i.data.y+d*r;break;case q.first:case q.replace:i.x+=(i.data.x+o-i.x)*r,i.y+=(i.data.y+d-i.y)*r;break;case q.add:i.x+=o*r,i.y+=d*r}}}class ag extends gr{constructor(t,e,s){super(t,e,`${Kt.x}|${s}`),It(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case q.setup:i.x=i.data.x;return;case q.first:i.x+=(i.data.x-i.x)*r}return}const o=this.getCurveValue(s);switch(c){case q.setup:i.x=i.data.x+o*r;break;case q.first:case q.replace:i.x+=(i.data.x+o-i.x)*r;break;case q.add:i.x+=o*r}}}class og extends gr{constructor(t,e,s){super(t,e,`${Kt.y}|${s}`),It(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case q.setup:i.y=i.data.y;return;case q.first:i.y+=(i.data.y-i.y)*r}return}const o=this.getCurveValue(s);switch(c){case q.setup:i.y=i.data.y+o*r;break;case q.first:case q.replace:i.y+=(i.data.y+o-i.y)*r;break;case q.add:i.y+=o*r}}}class lg extends Cd{constructor(t,e,s){super(t,e,`${Kt.scaleX}|${s}`,`${Kt.scaleY}|${s}`),It(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case q.setup:i.scaleX=i.data.scaleX,i.scaleY=i.data.scaleY;return;case q.first:i.scaleX+=(i.data.scaleX-i.scaleX)*r,i.scaleY+=(i.data.scaleY-i.scaleY)*r}return}let o,d;const f=Te.search(a,s,3),m=this.curves[f/3];switch(m){case 0:const l=a[f];o=a[f+1],d=a[f+2];const g=(s-l)/(a[f+3]-l);o+=(a[f+3+1]-o)*g,d+=(a[f+3+2]-d)*g;break;case 1:o=a[f+1],d=a[f+2];break;default:o=this.getBezierValue(s,f,1,m-2),d=this.getBezierValue(s,f,2,m+18-2)}if(o*=i.data.scaleX,d*=i.data.scaleY,r==1)c==q.add?(i.scaleX+=o-i.data.scaleX,i.scaleY+=d-i.data.scaleY):(i.scaleX=o,i.scaleY=d);else{let l=0,g=0;if(h==js.mixOut)switch(c){case q.setup:l=i.data.scaleX,g=i.data.scaleY,i.scaleX=l+(Math.abs(o)*Q.signum(l)-l)*r,i.scaleY=g+(Math.abs(d)*Q.signum(g)-g)*r;break;case q.first:case q.replace:l=i.scaleX,g=i.scaleY,i.scaleX=l+(Math.abs(o)*Q.signum(l)-l)*r,i.scaleY=g+(Math.abs(d)*Q.signum(g)-g)*r;break;case q.add:i.scaleX+=(o-i.data.scaleX)*r,i.scaleY+=(d-i.data.scaleY)*r}else switch(c){case q.setup:l=Math.abs(i.data.scaleX)*Q.signum(o),g=Math.abs(i.data.scaleY)*Q.signum(d),i.scaleX=l+(o-l)*r,i.scaleY=g+(d-g)*r;break;case q.first:case q.replace:l=Math.abs(i.scaleX)*Q.signum(o),g=Math.abs(i.scaleY)*Q.signum(d),i.scaleX=l+(o-l)*r,i.scaleY=g+(d-g)*r;break;case q.add:i.scaleX+=(o-i.data.scaleX)*r,i.scaleY+=(d-i.data.scaleY)*r}}}}class cg extends gr{constructor(t,e,s){super(t,e,`${Kt.scaleX}|${s}`),It(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case q.setup:i.scaleX=i.data.scaleX;return;case q.first:i.scaleX+=(i.data.scaleX-i.scaleX)*r}return}const o=this.getCurveValue(s)*i.data.scaleX;if(r==1)c==q.add?i.scaleX+=o-i.data.scaleX:i.scaleX=o;else{let d=0;if(h==js.mixOut)switch(c){case q.setup:d=i.data.scaleX,i.scaleX=d+(Math.abs(o)*Q.signum(d)-d)*r;break;case q.first:case q.replace:d=i.scaleX,i.scaleX=d+(Math.abs(o)*Q.signum(d)-d)*r;break;case q.add:i.scaleX+=(o-i.data.scaleX)*r}else switch(c){case q.setup:d=Math.abs(i.data.scaleX)*Q.signum(o),i.scaleX=d+(o-d)*r;break;case q.first:case q.replace:d=Math.abs(i.scaleX)*Q.signum(o),i.scaleX=d+(o-d)*r;break;case q.add:i.scaleX+=(o-i.data.scaleX)*r}}}}class hg extends gr{constructor(t,e,s){super(t,e,`${Kt.scaleY}|${s}`),It(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case q.setup:i.scaleY=i.data.scaleY;return;case q.first:i.scaleY+=(i.data.scaleY-i.scaleY)*r}return}const o=this.getCurveValue(s)*i.data.scaleY;if(r==1)c==q.add?i.scaleY+=o-i.data.scaleY:i.scaleY=o;else{let d=0;if(h==js.mixOut)switch(c){case q.setup:d=i.data.scaleY,i.scaleY=d+(Math.abs(o)*Q.signum(d)-d)*r;break;case q.first:case q.replace:d=i.scaleY,i.scaleY=d+(Math.abs(o)*Q.signum(d)-d)*r;break;case q.add:i.scaleY+=(o-i.data.scaleY)*r}else switch(c){case q.setup:d=Math.abs(i.data.scaleY)*Q.signum(o),i.scaleY=d+(o-d)*r;break;case q.first:case q.replace:d=Math.abs(i.scaleY)*Q.signum(o),i.scaleY=d+(o-d)*r;break;case q.add:i.scaleY+=(o-i.data.scaleY)*r}}}}class dg extends Cd{constructor(t,e,s){super(t,e,`${Kt.shearX}|${s}`,`${Kt.shearY}|${s}`),It(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case q.setup:i.shearX=i.data.shearX,i.shearY=i.data.shearY;return;case q.first:i.shearX+=(i.data.shearX-i.shearX)*r,i.shearY+=(i.data.shearY-i.shearY)*r}return}let o=0,d=0;const f=Te.search(a,s,3),m=this.curves[f/3];switch(m){case 0:const l=a[f];o=a[f+1],d=a[f+2];const g=(s-l)/(a[f+3]-l);o+=(a[f+3+1]-o)*g,d+=(a[f+3+2]-d)*g;break;case 1:o=a[f+1],d=a[f+2];break;default:o=this.getBezierValue(s,f,1,m-2),d=this.getBezierValue(s,f,2,m+18-2)}switch(c){case q.setup:i.shearX=i.data.shearX+o*r,i.shearY=i.data.shearY+d*r;break;case q.first:case q.replace:i.shearX+=(i.data.shearX+o-i.shearX)*r,i.shearY+=(i.data.shearY+d-i.shearY)*r;break;case q.add:i.shearX+=o*r,i.shearY+=d*r}}}class ug extends gr{constructor(t,e,s){super(t,e,`${Kt.shearX}|${s}`),It(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case q.setup:i.shearX=i.data.shearX;return;case q.first:i.shearX+=(i.data.shearX-i.shearX)*r}return}const o=this.getCurveValue(s);switch(c){case q.setup:i.shearX=i.data.shearX+o*r;break;case q.first:case q.replace:i.shearX+=(i.data.shearX+o-i.shearX)*r;break;case q.add:i.shearX+=o*r}}}class fg extends gr{constructor(t,e,s){super(t,e,`${Kt.shearY}|${s}`),It(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,c,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case q.setup:i.shearY=i.data.shearY;return;case q.first:i.shearY+=(i.data.shearY-i.shearY)*r}return}const o=this.getCurveValue(s);switch(c){case q.setup:i.shearY=i.data.shearY+o*r;break;case q.first:case q.replace:i.shearY+=(i.data.shearY+o-i.shearY)*r;break;case q.add:i.shearY+=o*r}}}class mg extends mr{constructor(t,e,s){super(t,e,[`${Kt.rgb}|${s}`,`${Kt.alpha}|${s}`]),It(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 5}setFrame(t,e,s,n,r,c){t*=5,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=c}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color;if(s<a[0]){const y=i.data.color;switch(c){case q.setup:o.setFromColor(y);return;case q.first:o.add((y.r-o.r)*r,(y.g-o.g)*r,(y.b-o.b)*r,(y.a-o.a)*r)}return}let d=0,f=0,m=0,l=0;const g=Te.search(a,s,5),p=this.curves[g/5];switch(p){case 0:const y=a[g];d=a[g+1],f=a[g+2],m=a[g+3],l=a[g+4];const w=(s-y)/(a[g+5]-y);d+=(a[g+5+1]-d)*w,f+=(a[g+5+2]-f)*w,m+=(a[g+5+3]-m)*w,l+=(a[g+5+4]-l)*w;break;case 1:d=a[g+1],f=a[g+2],m=a[g+3],l=a[g+4];break;default:d=this.getBezierValue(s,g,1,p-2),f=this.getBezierValue(s,g,2,p+18-2),m=this.getBezierValue(s,g,3,p+18*2-2),l=this.getBezierValue(s,g,4,p+18*3-2)}r==1?o.set(d,f,m,l):(c==q.setup&&o.setFromColor(i.data.color),o.add((d-o.r)*r,(f-o.g)*r,(m-o.b)*r,(l-o.a)*r))}}class gg extends mr{constructor(t,e,s){super(t,e,[`${Kt.rgb}|${s}`]),It(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 4}setFrame(t,e,s,n,r){t<<=2,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color;if(s<a[0]){const p=i.data.color;switch(c){case q.setup:o.r=p.r,o.g=p.g,o.b=p.b;return;case q.first:o.r+=(p.r-o.r)*r,o.g+=(p.g-o.g)*r,o.b+=(p.b-o.b)*r}return}let d=0,f=0,m=0;const l=Te.search(a,s,4),g=this.curves[l>>2];switch(g){case 0:const p=a[l];d=a[l+1],f=a[l+2],m=a[l+3];const y=(s-p)/(a[l+4]-p);d+=(a[l+4+1]-d)*y,f+=(a[l+4+2]-f)*y,m+=(a[l+4+3]-m)*y;break;case 1:d=a[l+1],f=a[l+2],m=a[l+3];break;default:d=this.getBezierValue(s,l,1,g-2),f=this.getBezierValue(s,l,2,g+18-2),m=this.getBezierValue(s,l,3,g+18*2-2)}if(r==1)o.r=d,o.g=f,o.b=m;else{if(c==q.setup){const p=i.data.color;o.r=p.r,o.g=p.g,o.b=p.b}o.r+=(d-o.r)*r,o.g+=(f-o.g)*r,o.b+=(m-o.b)*r}}}class pg extends gr{constructor(t,e,s){super(t,e,`${Kt.alpha}|${s}`),It(this,"slotIndex",0),this.slotIndex=s}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.color;if(s<this.frames[0]){const d=i.data.color;switch(c){case q.setup:a.a=d.a;return;case q.first:a.a+=(d.a-a.a)*r}return}const o=this.getCurveValue(s);r==1?a.a=o:(c==q.setup&&(a.a=i.data.color.a),a.a+=(o-a.a)*r)}}class bg extends mr{constructor(t,e,s){super(t,e,[`${Kt.rgb}|${s}`,`${Kt.alpha}|${s}`,`${Kt.rgb2}|${s}`]),It(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 8}setFrame(t,e,s,n,r,c,h,i,a){t<<=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=c,this.frames[t+5]=h,this.frames[t+6]=i,this.frames[t+7]=a}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color,d=i.darkColor;if(s<a[0]){const S=i.data.color,C=i.data.darkColor;switch(c){case q.setup:o.setFromColor(S),d.r=C.r,d.g=C.g,d.b=C.b;return;case q.first:o.add((S.r-o.r)*r,(S.g-o.g)*r,(S.b-o.b)*r,(S.a-o.a)*r),d.r+=(C.r-d.r)*r,d.g+=(C.g-d.g)*r,d.b+=(C.b-d.b)*r}return}let f=0,m=0,l=0,g=0,p=0,y=0,w=0;const b=Te.search(a,s,8),x=this.curves[b>>3];switch(x){case 0:const S=a[b];f=a[b+1],m=a[b+2],l=a[b+3],g=a[b+4],p=a[b+5],y=a[b+6],w=a[b+7];const C=(s-S)/(a[b+8]-S);f+=(a[b+8+1]-f)*C,m+=(a[b+8+2]-m)*C,l+=(a[b+8+3]-l)*C,g+=(a[b+8+4]-g)*C,p+=(a[b+8+5]-p)*C,y+=(a[b+8+6]-y)*C,w+=(a[b+8+7]-w)*C;break;case 1:f=a[b+1],m=a[b+2],l=a[b+3],g=a[b+4],p=a[b+5],y=a[b+6],w=a[b+7];break;default:f=this.getBezierValue(s,b,1,x-2),m=this.getBezierValue(s,b,2,x+18-2),l=this.getBezierValue(s,b,3,x+18*2-2),g=this.getBezierValue(s,b,4,x+18*3-2),p=this.getBezierValue(s,b,5,x+18*4-2),y=this.getBezierValue(s,b,6,x+18*5-2),w=this.getBezierValue(s,b,7,x+18*6-2)}if(r==1)o.set(f,m,l,g),d.r=p,d.g=y,d.b=w;else{if(c==q.setup){o.setFromColor(i.data.color);const S=i.data.darkColor;d.r=S.r,d.g=S.g,d.b=S.b}o.add((f-o.r)*r,(m-o.g)*r,(l-o.b)*r,(g-o.a)*r),d.r+=(p-d.r)*r,d.g+=(y-d.g)*r,d.b+=(w-d.b)*r}}}class xg extends mr{constructor(t,e,s){super(t,e,[`${Kt.rgb}|${s}`,`${Kt.rgb2}|${s}`]),It(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 7}setFrame(t,e,s,n,r,c,h,i){t*=7,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=c,this.frames[t+5]=h,this.frames[t+6]=i}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color,d=i.darkColor;if(s<a[0]){const x=i.data.color,S=i.data.darkColor;switch(c){case q.setup:o.r=x.r,o.g=x.g,o.b=x.b,d.r=S.r,d.g=S.g,d.b=S.b;return;case q.first:o.r+=(x.r-o.r)*r,o.g+=(x.g-o.g)*r,o.b+=(x.b-o.b)*r,d.r+=(S.r-d.r)*r,d.g+=(S.g-d.g)*r,d.b+=(S.b-d.b)*r}return}let f=0,m=0,l=0,g=0,p=0,y=0;const w=Te.search(a,s,7),b=this.curves[w/7];switch(b){case 0:const x=a[w];f=a[w+1],m=a[w+2],l=a[w+3],g=a[w+4],p=a[w+5],y=a[w+6];const S=(s-x)/(a[w+7]-x);f+=(a[w+7+1]-f)*S,m+=(a[w+7+2]-m)*S,l+=(a[w+7+3]-l)*S,g+=(a[w+7+4]-g)*S,p+=(a[w+7+5]-p)*S,y+=(a[w+7+6]-y)*S;break;case 1:f=a[w+1],m=a[w+2],l=a[w+3],g=a[w+4],p=a[w+5],y=a[w+6];break;default:f=this.getBezierValue(s,w,1,b-2),m=this.getBezierValue(s,w,2,b+18-2),l=this.getBezierValue(s,w,3,b+18*2-2),g=this.getBezierValue(s,w,4,b+18*3-2),p=this.getBezierValue(s,w,5,b+18*4-2),y=this.getBezierValue(s,w,6,b+18*5-2)}if(r==1)o.r=f,o.g=m,o.b=l,d.r=g,d.g=p,d.b=y;else{if(c==q.setup){const x=i.data.color,S=i.data.darkColor;o.r=x.r,o.g=x.g,o.b=x.b,d.r=S.r,d.g=S.g,d.b=S.b}o.r+=(f-o.r)*r,o.g+=(m-o.g)*r,o.b+=(l-o.b)*r,d.r+=(g-d.r)*r,d.g+=(p-d.g)*r,d.b+=(y-d.b)*r}}}class $a extends Te{constructor(t,e){super(t,[`${Kt.attachment}|${e}`]),It(this,"slotIndex",0),It(this,"attachmentNames"),this.slotIndex=e,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.attachmentNames[t]=s}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(i.bone.active){if(h==js.mixOut){c==q.setup&&this.setAttachment(t,i,i.data.attachmentName);return}if(s<this.frames[0]){(c==q.setup||c==q.first)&&this.setAttachment(t,i,i.data.attachmentName);return}this.setAttachment(t,i,this.attachmentNames[Te.search1(this.frames,s)])}}setAttachment(t,e,s){e.setAttachment(s?t.getAttachment(this.slotIndex,s):null)}}class wg extends mr{constructor(t,e,s,n){super(t,e,[`${Kt.deform}|${s}|${n.id}`]),It(this,"slotIndex",0),It(this,"attachment"),It(this,"vertices"),this.slotIndex=s,this.attachment=n,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.vertices[t]=s}setBezier(t,e,s,n,r,c,h,i,a,o,d){const f=this.curves;let m=this.getFrameCount()+t*18;s==0&&(f[e]=2+m);const l=(n-c*2+i)*.03,g=a*.03-h*.06,p=((c-i)*3-n+o)*.006,y=(h-a+.33333333)*.018;let w=l*2+p,b=g*2+y,x=(c-n)*.3+l+p*.16666667,S=h*.3+g+y*.16666667,C=n+x,A=S;for(let v=m+18;m<v;m+=2)f[m]=C,f[m+1]=A,x+=w,S+=b,w+=p,b+=y,C+=x,A+=S}getCurvePercent(t,e){const s=this.curves;let n=s[e];switch(n){case 0:const i=this.frames[e];return(t-i)/(this.frames[e+this.getFrameEntries()]-i);case 1:return 0}if(n-=2,s[n]>t){const i=this.frames[e];return s[n+1]*(t-i)/(s[n]-i)}const r=n+18;for(n+=2;n<r;n+=2)if(s[n]>=t){const i=s[n-2],a=s[n-1];return a+(t-i)/(s[n]-i)*(s[n+1]-a)}const c=s[r-2],h=s[r-1];return h+(1-h)*(t-c)/(this.frames[e+this.getFrameEntries()]-c)}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.getAttachment();if(!a||!(a instanceof $r)||a.timelineAttachment!=this.attachment)return;const o=i.deform;o.length==0&&(c=q.setup);const d=this.vertices,f=d[0].length,m=this.frames;if(s<m[0]){switch(c){case q.setup:o.length=0;return;case q.first:if(r==1){o.length=0;return}o.length=f;const w=a;if(w.bones){r=1-r;for(let b=0;b<f;b++)o[b]*=r}else{const b=w.vertices;for(let x=0;x<f;x++)o[x]+=(b[x]-o[x])*r}}return}if(o.length=f,s>=m[m.length-1]){const w=d[m.length-1];if(r==1)if(c==q.add){const b=a;if(b.bones)for(let x=0;x<f;x++)o[x]+=w[x];else{const x=b.vertices;for(let S=0;S<f;S++)o[S]+=w[S]-x[S]}}else dt.arrayCopy(w,0,o,0,f);else switch(c){case q.setup:{const x=a;if(x.bones)for(let S=0;S<f;S++)o[S]=w[S]*r;else{const S=x.vertices;for(let C=0;C<f;C++){const A=S[C];o[C]=A+(w[C]-A)*r}}break}case q.first:case q.replace:for(let x=0;x<f;x++)o[x]+=(w[x]-o[x])*r;break;case q.add:const b=a;if(b.bones)for(let x=0;x<f;x++)o[x]+=w[x]*r;else{const x=b.vertices;for(let S=0;S<f;S++)o[S]+=(w[S]-x[S])*r}}return}const l=Te.search1(m,s),g=this.getCurvePercent(s,l),p=d[l],y=d[l+1];if(r==1)if(c==q.add){const w=a;if(w.bones)for(let b=0;b<f;b++){const x=p[b];o[b]+=x+(y[b]-x)*g}else{const b=w.vertices;for(let x=0;x<f;x++){const S=p[x];o[x]+=S+(y[x]-S)*g-b[x]}}}else for(let w=0;w<f;w++){const b=p[w];o[w]=b+(y[w]-b)*g}else switch(c){case q.setup:{const b=a;if(b.bones)for(let x=0;x<f;x++){const S=p[x];o[x]=(S+(y[x]-S)*g)*r}else{const x=b.vertices;for(let S=0;S<f;S++){const C=p[S],A=x[S];o[S]=A+(C+(y[S]-C)*g-A)*r}}break}case q.first:case q.replace:for(let b=0;b<f;b++){const x=p[b];o[b]+=(x+(y[b]-x)*g-o[b])*r}break;case q.add:const w=a;if(w.bones)for(let b=0;b<f;b++){const x=p[b];o[b]+=(x+(y[b]-x)*g)*r}else{const b=w.vertices;for(let x=0;x<f;x++){const S=p[x];o[x]+=(S+(y[x]-S)*g-b[x])*r}}}}}const yg=class $p extends Te{constructor(t){super(t,$p.propertyIds),It(this,"events"),this.events=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,s,n,r,c,h){if(!n)return;const i=this.frames,a=this.frames.length;if(e>s)this.apply(t,e,Number.MAX_VALUE,n,r,c,h),e=-1;else if(e>=i[a-1])return;if(s<i[0])return;let o=0;if(e<i[0])o=0;else{o=Te.search1(i,e)+1;const d=i[o];for(;o>0&&i[o-1]==d;)o--}for(;o<a&&s>=i[o];o++)n.push(this.events[o])}};It(yg,"propertyIds",[`${Kt.event}`]);let Ad=yg;const Sg=class _p extends Te{constructor(t){super(t,_p.propertyIds),It(this,"drawOrders"),this.drawOrders=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.drawOrders[t]=s}apply(t,e,s,n,r,c,h){if(h==js.mixOut){c==q.setup&&dt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}if(s<this.frames[0]){(c==q.setup||c==q.first)&&dt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const i=Te.search1(this.frames,s),a=this.drawOrders[i];if(!a)dt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);else{const o=t.drawOrder,d=t.slots;for(let f=0,m=a.length;f<m;f++)o[f]=d[a[f]]}}};It(Sg,"propertyIds",[`${Kt.drawOrder}`]);let _o=Sg;class Cg extends mr{constructor(t,e,s){super(t,e,[`${Kt.ikConstraint}|${s}`]),It(this,"ikConstraintIndex",0),this.ikConstraintIndex=s}getFrameEntries(){return 6}setFrame(t,e,s,n,r,c,h){t*=6,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=c?1:0,this.frames[t+5]=h?1:0}apply(t,e,s,n,r,c,h){const i=t.ikConstraints[this.ikConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case q.setup:i.mix=i.data.mix,i.softness=i.data.softness,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch;return;case q.first:i.mix+=(i.data.mix-i.mix)*r,i.softness+=(i.data.softness-i.softness)*r,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch}return}let o=0,d=0;const f=Te.search(a,s,6),m=this.curves[f/6];switch(m){case 0:const l=a[f];o=a[f+1],d=a[f+2];const g=(s-l)/(a[f+6]-l);o+=(a[f+6+1]-o)*g,d+=(a[f+6+2]-d)*g;break;case 1:o=a[f+1],d=a[f+2];break;default:o=this.getBezierValue(s,f,1,m-2),d=this.getBezierValue(s,f,2,m+18-2)}c==q.setup?(i.mix=i.data.mix+(o-i.data.mix)*r,i.softness=i.data.softness+(d-i.data.softness)*r,h==js.mixOut?(i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch):(i.bendDirection=a[f+3],i.compress=a[f+4]!=0,i.stretch=a[f+5]!=0)):(i.mix+=(o-i.mix)*r,i.softness+=(d-i.softness)*r,h==js.mixIn&&(i.bendDirection=a[f+3],i.compress=a[f+4]!=0,i.stretch=a[f+5]!=0))}}class Ag extends mr{constructor(t,e,s){super(t,e,[`${Kt.transformConstraint}|${s}`]),It(this,"transformConstraintIndex",0),this.transformConstraintIndex=s}getFrameEntries(){return 7}setFrame(t,e,s,n,r,c,h,i){const a=this.frames;t*=7,a[t]=e,a[t+1]=s,a[t+2]=n,a[t+3]=r,a[t+4]=c,a[t+5]=h,a[t+6]=i}apply(t,e,s,n,r,c,h){const i=t.transformConstraints[this.transformConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){const w=i.data;switch(c){case q.setup:i.mixRotate=w.mixRotate,i.mixX=w.mixX,i.mixY=w.mixY,i.mixScaleX=w.mixScaleX,i.mixScaleY=w.mixScaleY,i.mixShearY=w.mixShearY;return;case q.first:i.mixRotate+=(w.mixRotate-i.mixRotate)*r,i.mixX+=(w.mixX-i.mixX)*r,i.mixY+=(w.mixY-i.mixY)*r,i.mixScaleX+=(w.mixScaleX-i.mixScaleX)*r,i.mixScaleY+=(w.mixScaleY-i.mixScaleY)*r,i.mixShearY+=(w.mixShearY-i.mixShearY)*r}return}let o,d,f,m,l,g;const p=Te.search(a,s,7),y=this.curves[p/7];switch(y){case 0:const w=a[p];o=a[p+1],d=a[p+2],f=a[p+3],m=a[p+4],l=a[p+5],g=a[p+6];const b=(s-w)/(a[p+7]-w);o+=(a[p+7+1]-o)*b,d+=(a[p+7+2]-d)*b,f+=(a[p+7+3]-f)*b,m+=(a[p+7+4]-m)*b,l+=(a[p+7+5]-l)*b,g+=(a[p+7+6]-g)*b;break;case 1:o=a[p+1],d=a[p+2],f=a[p+3],m=a[p+4],l=a[p+5],g=a[p+6];break;default:o=this.getBezierValue(s,p,1,y-2),d=this.getBezierValue(s,p,2,y+18-2),f=this.getBezierValue(s,p,3,y+18*2-2),m=this.getBezierValue(s,p,4,y+18*3-2),l=this.getBezierValue(s,p,5,y+18*4-2),g=this.getBezierValue(s,p,6,y+18*5-2)}if(c==q.setup){const w=i.data;i.mixRotate=w.mixRotate+(o-w.mixRotate)*r,i.mixX=w.mixX+(d-w.mixX)*r,i.mixY=w.mixY+(f-w.mixY)*r,i.mixScaleX=w.mixScaleX+(m-w.mixScaleX)*r,i.mixScaleY=w.mixScaleY+(l-w.mixScaleY)*r,i.mixShearY=w.mixShearY+(g-w.mixShearY)*r}else i.mixRotate+=(o-i.mixRotate)*r,i.mixX+=(d-i.mixX)*r,i.mixY+=(f-i.mixY)*r,i.mixScaleX+=(m-i.mixScaleX)*r,i.mixScaleY+=(l-i.mixScaleY)*r,i.mixShearY+=(g-i.mixShearY)*r}}class vg extends gr{constructor(t,e,s){super(t,e,`${Kt.pathConstraintPosition}|${s}`),It(this,"pathConstraintIndex",0),this.pathConstraintIndex=s}apply(t,e,s,n,r,c,h){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case q.setup:i.position=i.data.position;return;case q.first:i.position+=(i.data.position-i.position)*r}return}const o=this.getCurveValue(s);c==q.setup?i.position=i.data.position+(o-i.data.position)*r:i.position+=(o-i.position)*r}}class Mg extends gr{constructor(t,e,s){super(t,e,`${Kt.pathConstraintSpacing}|${s}`),It(this,"pathConstraintIndex",0),this.pathConstraintIndex=s}apply(t,e,s,n,r,c,h){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case q.setup:i.spacing=i.data.spacing;return;case q.first:i.spacing+=(i.data.spacing-i.spacing)*r}return}const o=this.getCurveValue(s);c==q.setup?i.spacing=i.data.spacing+(o-i.data.spacing)*r:i.spacing+=(o-i.spacing)*r}}class Eg extends mr{constructor(t,e,s){super(t,e,[`${Kt.pathConstraintMix}|${s}`]),It(this,"pathConstraintIndex",0),this.pathConstraintIndex=s}getFrameEntries(){return 4}setFrame(t,e,s,n,r){const c=this.frames;t<<=2,c[t]=e,c[t+1]=s,c[t+2]=n,c[t+3]=r}apply(t,e,s,n,r,c,h){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(c){case q.setup:i.mixRotate=i.data.mixRotate,i.mixX=i.data.mixX,i.mixY=i.data.mixY;return;case q.first:i.mixRotate+=(i.data.mixRotate-i.mixRotate)*r,i.mixX+=(i.data.mixX-i.mixX)*r,i.mixY+=(i.data.mixY-i.mixY)*r}return}let o,d,f;const m=Te.search(a,s,4),l=this.curves[m>>2];switch(l){case 0:const g=a[m];o=a[m+1],d=a[m+2],f=a[m+3];const p=(s-g)/(a[m+4]-g);o+=(a[m+4+1]-o)*p,d+=(a[m+4+2]-d)*p,f+=(a[m+4+3]-f)*p;break;case 1:o=a[m+1],d=a[m+2],f=a[m+3];break;default:o=this.getBezierValue(s,m,1,l-2),d=this.getBezierValue(s,m,2,l+18-2),f=this.getBezierValue(s,m,3,l+18*2-2)}if(c==q.setup){const g=i.data;i.mixRotate=g.mixRotate+(o-g.mixRotate)*r,i.mixX=g.mixX+(d-g.mixX)*r,i.mixY=g.mixY+(f-g.mixY)*r}else i.mixRotate+=(o-i.mixRotate)*r,i.mixX+=(d-i.mixX)*r,i.mixY+=(f-i.mixY)*r}}const Rl=class ki extends Te{constructor(t,e,s){super(t,[`${Kt.sequence}|${e}|${s.sequence.id}`]),It(this,"slotIndex"),It(this,"attachment"),this.slotIndex=e,this.attachment=s}getFrameEntries(){return ki.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(t,e,s,n,r){const c=this.frames;t*=ki.ENTRIES,c[t]=e,c[t+ki.MODE]=s|n<<4,c[t+ki.DELAY]=r}apply(t,e,s,n,r,c,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.attachment,o=this.attachment;if(a!=o&&(!(a instanceof $r)||a.timelineAttachment!=o))return;const d=this.frames;if(s<d[0]){(c==q.setup||c==q.first)&&(i.sequenceIndex=-1);return}const f=Te.search(d,s,ki.ENTRIES),m=d[f],l=d[f+ki.MODE],g=d[f+ki.DELAY];if(!this.attachment.sequence)return;let p=l>>4;const y=this.attachment.sequence.regions.length,w=rg[l&15];if(w!=_r.hold)switch(p+=(s-m)/g+1e-5|0,w){case _r.once:p=Math.min(y-1,p);break;case _r.loop:p%=y;break;case _r.pingpong:{const b=(y<<1)-2;p=b==0?0:p%b,p>=y&&(p=b-p);break}case _r.onceReverse:p=Math.max(y-1-p,0);break;case _r.loopReverse:p=y-1-p%y;break;case _r.pingpongReverse:{const b=(y<<1)-2;p=b==0?0:(p+y-1)%b,p>=y&&(p=b-p)}}i.sequenceIndex=p}};It(Rl,"ENTRIES",3),It(Rl,"MODE",1),It(Rl,"DELAY",2);let Tg=Rl;var AA=Object.defineProperty,vA=(u,t,e)=>t in u?AA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ut=(u,t,e)=>vA(u,typeof t!="symbol"?t+"":t,e);const Xo=class yr{constructor(t){ut(this,"data"),ut(this,"tracks",new Array),ut(this,"timeScale",1),ut(this,"unkeyedState",0),ut(this,"events",new Array),ut(this,"listeners",new Array),ut(this,"queue",new TA(this)),ut(this,"propertyIDs",new Um),ut(this,"animationsChanged",!1),ut(this,"trackEntryPool",new Gm(()=>new EA)),ut(this,"onComplete"),ut(this,"onEvent"),ut(this,"onStart"),ut(this,"onEnd"),this.data=t}static emptyAnimation(){return yr._emptyAnimation}update(t){t*=this.timeScale;const e=this.tracks;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(!r)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let c=t*r.timeScale;if(r.delay>0){if(r.delay-=c,r.delay>0)continue;c=-r.delay,r.delay=0}let h=r.next;if(h){const i=r.trackLast-h.delay;if(i>=0){for(h.delay=0,h.trackTime+=r.timeScale==0?0:(i/r.timeScale+t)*h.timeScale,r.trackTime+=c,this.setCurrent(s,h,!0);h.mixingFrom;)h.mixTime+=t,h=h.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&!r.mixingFrom){e[s]=null,this.queue.end(r),this.clearNext(r);continue}if(r.mixingFrom&&this.updateMixingFrom(r,t)){let i=r.mixingFrom;for(r.mixingFrom=null,i&&(i.mixingTo=null);i;)this.queue.end(i),i=i.mixingFrom}r.trackTime+=c}this.queue.drain()}updateMixingFrom(t,e){const s=t.mixingFrom;if(!s)return!0;const n=this.updateMixingFrom(s,e);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?((s.totalAlpha==0||t.mixDuration==0)&&(t.mixingFrom=s.mixingFrom,s.mixingFrom&&(s.mixingFrom.mixingTo=t),t.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=e*s.timeScale,t.mixTime+=e,!1)}apply(t){if(!t)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,s=this.tracks;let n=!1;for(let h=0,i=s.length;h<i;h++){const a=s[h];if(!a||a.delay>0)continue;n=!0;const o=h==0?q.first:a.mixBlend;let d=a.alpha;a.mixingFrom?d*=this.applyMixingFrom(a,t,o):a.trackTime>=a.trackEnd&&!a.next&&(d=0);const f=a.animationLast,m=a.getAnimationTime();let l=m,g=e;a.reverse&&(l=a.animation.duration-l,g=null);const p=a.animation.timelines,y=p.length;if(h==0&&d==1||o==q.add)for(let w=0;w<y;w++){dt.webkit602BugfixHelper(d,o);const b=p[w];b instanceof $a?this.applyAttachmentTimeline(b,t,l,o,!0):b.apply(t,f,l,g,d,o,js.mixIn)}else{const w=a.timelineMode,b=a.shortestRotation,x=!b&&a.timelinesRotation.length!=y<<1;x&&(a.timelinesRotation.length=y<<1);for(let S=0;S<y;S++){const C=p[S],A=w[S]==Md?o:q.setup;!b&&C instanceof Il?this.applyRotateTimeline(C,t,l,d,A,a.timelinesRotation,S<<1,x):C instanceof $a?this.applyAttachmentTimeline(C,t,l,o,!0):(dt.webkit602BugfixHelper(d,o),C.apply(t,f,l,g,d,A,js.mixIn))}}this.queueEvents(a,m),e.length=0,a.nextAnimationLast=m,a.nextTrackLast=a.trackTime}const r=this.unkeyedState+Pg,c=t.slots;for(let h=0,i=t.slots.length;h<i;h++){const a=c[h];if(a.attachmentState==r){const o=a.data.attachmentName;a.setAttachment(o?t.getAttachment(a.data.index,o):null)}}return this.unkeyedState+=2,this.queue.drain(),n}applyMixingFrom(t,e,s){const n=t.mixingFrom;n.mixingFrom&&this.applyMixingFrom(n,e,s);let r=0;t.mixDuration==0?(r=1,s==q.first&&(s=q.setup)):(r=t.mixTime/t.mixDuration,r>1&&(r=1),s!=q.first&&(s=n.mixBlend));const c=r<n.attachmentThreshold,h=r<n.drawOrderThreshold,i=n.animation.timelines,a=i.length,o=n.alpha*t.interruptAlpha,d=o*(1-r),f=n.animationLast,m=n.getAnimationTime();let l=m,g=null;if(n.reverse?l=n.animation.duration-l:r<n.eventThreshold&&(g=this.events),s==q.add)for(let p=0;p<a;p++)i[p].apply(e,f,l,g,d,s,js.mixOut);else{const p=n.timelineMode,y=n.timelineHoldMix,w=n.shortestRotation,b=!w&&n.timelinesRotation.length!=a<<1;b&&(n.timelinesRotation.length=a<<1),n.totalAlpha=0;for(let x=0;x<a;x++){const S=i[x];let C=js.mixOut,A,v=0;switch(p[x]){case Md:if(!h&&S instanceof _o)continue;A=s,v=d;break;case Ig:A=q.setup,v=d;break;case Rg:A=s,v=o;break;case Ed:A=q.setup,v=o;break;default:A=q.setup;const M=y[x];v=o*Math.max(0,1-M.mixTime/M.mixDuration);break}n.totalAlpha+=v,!w&&S instanceof Il?this.applyRotateTimeline(S,e,l,v,A,n.timelinesRotation,x<<1,b):S instanceof $a?this.applyAttachmentTimeline(S,e,l,A,c):(dt.webkit602BugfixHelper(v,s),h&&S instanceof _o&&A==q.setup&&(C=js.mixIn),S.apply(e,f,l,g,v,A,C))}}return t.mixDuration>0&&this.queueEvents(n,m),this.events.length=0,n.nextAnimationLast=m,n.nextTrackLast=n.trackTime,r}applyAttachmentTimeline(t,e,s,n,r){const c=e.slots[t.slotIndex];c.bone.active&&(s<t.frames[0]?(n==q.setup||n==q.first)&&this.setAttachment(e,c,c.data.attachmentName,r):this.setAttachment(e,c,t.attachmentNames[Te.search1(t.frames,s)],r),c.attachmentState<=this.unkeyedState&&(c.attachmentState=this.unkeyedState+Pg))}setAttachment(t,e,s,n){e.setAttachment(s?t.getAttachment(e.data.index,s):null),n&&(e.attachmentState=this.unkeyedState+PA)}applyRotateTimeline(t,e,s,n,r,c,h,i){if(i&&(c[h]=0),n==1){t.apply(e,0,s,null,1,r,js.mixIn);return}const a=e.bones[t.boneIndex];if(!a.active)return;const o=t.frames;let d=0,f=0;if(s<o[0])switch(r){case q.setup:a.rotation=a.data.rotation;default:return;case q.first:d=a.rotation,f=a.data.rotation}else d=r==q.setup?a.data.rotation:a.rotation,f=a.data.rotation+t.getCurveValue(s);let m=0,l=f-d;if(l-=(16384-(16384.499999999996-l/360|0))*360,l==0)m=c[h];else{let g=0,p=0;i?(g=0,p=l):(g=c[h],p=c[h+1]);const y=l>0;let w=g>=0;Q.signum(p)!=Q.signum(l)&&Math.abs(p)<=90&&(Math.abs(g)>180&&(g+=360*Q.signum(g)),w=y),m=l+g-g%360,w!=y&&(m+=360*Q.signum(g)),c[h]=m}c[h+1]=l,a.rotation=d+m*n}queueEvents(t,e){const s=t.animationStart,n=t.animationEnd,r=n-s,c=t.trackLast%r,h=this.events;let i=0;const a=h.length;for(;i<a;i++){const d=h[i];if(d.time<c)break;d.time>n||this.queue.event(t,d)}let o=!1;for(t.loop?o=r==0||c>t.trackTime%r:o=e>=n&&t.animationLast<n,o&&this.queue.complete(t);i<a;i++){const d=h[i];d.time<s||this.queue.event(t,d)}}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,s=this.tracks.length;e<s;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(!e)return;this.queue.end(e),this.clearNext(e);let s=e;for(;;){const n=s.mixingFrom;if(!n)break;this.queue.end(n),s.mixingFrom=null,s.mixingTo=null,s=n}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,s){const n=this.expandToIndex(t);this.tracks[t]=e,e.previous=null,n&&(s&&this.queue.interrupt(n),e.mixingFrom=n,n.mixingTo=e,e.mixTime=0,n.mixingFrom&&n.mixDuration>0&&(e.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,s=!1){const n=this.data.skeletonData.findAnimation(e);if(!n)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,n,s)}setAnimationWith(t,e,s=!1){if(!e)throw new Error("animation cannot be null.");let n=!0,r=this.expandToIndex(t);r&&(r.nextTrackLast==-1?(this.tracks[t]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.clearNext(r),r=r.mixingFrom,n=!1):this.clearNext(r));const c=this.trackEntry(t,e,s,r);return this.setCurrent(t,c,n),this.queue.drain(),c}addAnimation(t,e,s=!1,n=0){const r=this.data.skeletonData.findAnimation(e);if(!r)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,r,s,n)}addAnimationWith(t,e,s=!1,n=0){if(!e)throw new Error("animation cannot be null.");let r=this.expandToIndex(t);if(r)for(;r.next;)r=r.next;const c=this.trackEntry(t,e,s,r);return r?(r.next=c,c.previous=r,n<=0&&(n+=r.getTrackComplete()-c.mixDuration)):(this.setCurrent(t,c,!0),this.queue.drain()),c.delay=n,c}setEmptyAnimation(t,e=0){const s=this.setAnimationWith(t,yr.emptyAnimation(),!1);return s.mixDuration=e,s.trackEnd=e,s}addEmptyAnimation(t,e=0,s=0){const n=this.addAnimationWith(t,yr.emptyAnimation(),!1,s);return s<=0&&(n.delay+=n.mixDuration-e),n.mixDuration=e,n.trackEnd=e,n}setEmptyAnimations(t=0){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,n=this.tracks.length;s<n;s++){const r=this.tracks[s];r&&this.setEmptyAnimation(r.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(dt.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,s,n){const r=this.trackEntryPool.obtain();return r.reset(),r.trackIndex=t,r.animation=e,r.loop=s,r.holdPrevious=!1,r.reverse=!1,r.shortestRotation=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=e.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.mixTime=0,r.mixDuration=n?this.data.getMix(n.animation,e):0,r.interruptAlpha=1,r.totalAlpha=0,r.mixBlend=q.replace,r}clearNext(t){let e=t.next;for(;e;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const t=this.tracks;for(let e=0,s=t.length;e<s;e++){let n=t[e];if(n){for(;n.mixingFrom;)n=n.mixingFrom;do(!n.mixingTo||n.mixBlend!=q.add)&&this.computeHold(n),n=n.mixingTo;while(n)}}}computeHold(t){const e=t.mixingTo,s=t.animation.timelines,n=t.animation.timelines.length,r=t.timelineMode;r.length=n;const c=t.timelineHoldMix;c.length=0;const h=this.propertyIDs;if(e&&e.holdPrevious){for(let i=0;i<n;i++)r[i]=h.addAll(s[i].getPropertyIds())?Ed:Rg;return}t:for(let i=0;i<n;i++){const a=s[i],o=a.getPropertyIds();if(!h.addAll(o))r[i]=Md;else if(!e||a instanceof $a||a instanceof _o||a instanceof Ad||!e.animation.hasTimeline(o))r[i]=Ig;else{for(let d=e.mixingTo;d;d=d.mixingTo)if(!d.animation.hasTimeline(o)){if(t.mixDuration>0){r[i]=RA,c[i]=d;continue t}break}r[i]=Ed}}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(!t)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,e,s){yr.deprecatedWarning1||(yr.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,e,s)}addAnimationByName(t,e,s,n){yr.deprecatedWarning2||(yr.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,e,s,n)}hasAnimation(t){return this.data.skeletonData.findAnimation(t)!==null}hasAnimationByName(t){return yr.deprecatedWarning3||(yr.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};ut(Xo,"_emptyAnimation",new Sd("<empty>",[],0)),ut(Xo,"deprecatedWarning1",!1),ut(Xo,"deprecatedWarning2",!1),ut(Xo,"deprecatedWarning3",!1);let MA=Xo;const vd=class Ur{constructor(){ut(this,"animation",null),ut(this,"previous",null),ut(this,"next",null),ut(this,"mixingFrom",null),ut(this,"mixingTo",null),ut(this,"listener",null),ut(this,"trackIndex",0),ut(this,"loop",!1),ut(this,"holdPrevious",!1),ut(this,"reverse",!1),ut(this,"shortestRotation",!1),ut(this,"eventThreshold",0),ut(this,"attachmentThreshold",0),ut(this,"drawOrderThreshold",0),ut(this,"animationStart",0),ut(this,"animationEnd",0),ut(this,"animationLast",0),ut(this,"nextAnimationLast",0),ut(this,"delay",0),ut(this,"trackTime",0),ut(this,"trackLast",0),ut(this,"nextTrackLast",0),ut(this,"trackEnd",0),ut(this,"timeScale",0),ut(this,"alpha",0),ut(this,"mixTime",0),ut(this,"mixDuration",0),ut(this,"interruptAlpha",0),ut(this,"totalAlpha",0),ut(this,"mixBlend",q.replace),ut(this,"timelineMode",new Array),ut(this,"timelineHoldMix",new Array),ut(this,"timelinesRotation",new Array),ut(this,"onComplete"),ut(this,"onEvent"),ut(this,"onStart"),ut(this,"onEnd")}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const t=this.animationEnd-this.animationStart;if(t!=0){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}get time(){return Ur.deprecatedWarning1||(Ur.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){Ur.deprecatedWarning1||(Ur.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return Ur.deprecatedWarning2||(Ur.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){Ur.deprecatedWarning2||(Ur.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};ut(vd,"deprecatedWarning1",!1),ut(vd,"deprecatedWarning2",!1);let EA=vd;class TA{constructor(t){ut(this,"objects",[]),ut(this,"drainDisabled",!1),ut(this,"animState"),this.animState=t}start(t){this.objects.push(0),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(1),this.objects.push(t)}end(t){this.objects.push(2),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(3),this.objects.push(t)}complete(t){this.objects.push(4),this.objects.push(t)}event(t,e){this.objects.push(5),this.objects.push(t),this.objects.push(e)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let s=0;s<t.length;s+=2){const n=t[s],r=t[s+1];switch(n){case 0:r.listener&&r.listener.start&&r.listener.start(r);for(let h=0;h<e.length;h++){const i=e[h];i.start&&i.start(r)}break;case 1:r.listener&&r.listener.interrupt&&r.listener.interrupt(r);for(let h=0;h<e.length;h++){const i=e[h];i.interrupt&&i.interrupt(r)}break;case 2:r.listener&&r.listener.end&&r.listener.end(r);for(let h=0;h<e.length;h++){const i=e[h];i.end&&i.end(r)}case 3:r.listener&&r.listener.dispose&&r.listener.dispose(r);for(let h=0;h<e.length;h++){const i=e[h];i.dispose&&i.dispose(r)}this.animState.trackEntryPool.free(r);break;case 4:r.listener&&r.listener.complete&&r.listener.complete(r);for(let h=0;h<e.length;h++){const i=e[h];i.complete&&i.complete(r)}break;case 5:const c=t[s+++2];r.listener&&r.listener.event&&r.listener.event(r,c);for(let h=0;h<e.length;h++){const i=e[h];i.event&&i.event(r,c)}break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}}var IA=(u=>(u[u.start=0]="start",u[u.interrupt=1]="interrupt",u[u.end=2]="end",u[u.dispose=3]="dispose",u[u.complete=4]="complete",u[u.event=5]="event",u))(IA||{});class oM{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}}const Md=0,Ig=1,Rg=2,Ed=3,RA=4,Pg=1,PA=2;var kA=Object.defineProperty,FA=(u,t,e)=>t in u?kA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Td=(u,t,e)=>FA(u,typeof t!="symbol"?t+"":t,e);class YA{constructor(t){if(Td(this,"skeletonData"),Td(this,"animationToMixTime",{}),Td(this,"defaultMix",0),!t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,s){const n=this.skeletonData.findAnimation(t);if(!n)throw new Error(`Animation not found: ${t}`);const r=this.skeletonData.findAnimation(e);if(!r)throw new Error(`Animation not found: ${e}`);this.setMixWith(n,r,s)}setMixWith(t,e,s){if(!t)throw new Error("from cannot be null.");if(!e)throw new Error("to cannot be null.");const n=`${t.name}.${e.name}`;this.animationToMixTime[n]=s}getMix(t,e){const s=`${t.name}.${e.name}`,n=this.animationToMixTime[s];return n===void 0?this.defaultMix:n}}var $A=Object.defineProperty,_A=(u,t,e)=>t in u?$A(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,XA=(u,t,e)=>_A(u,typeof t!="symbol"?t+"":t,e);class lM{constructor(t){XA(this,"atlas"),this.atlas=t}loadSequence(t,e,s){const n=s.regions;for(let r=0,c=n.length;r<c;r++){const h=s.getPath(e,r),i=this.atlas.findRegion(h);if(i==null)throw new Error(`Region not found in atlas: ${h} (sequence: ${t})`);n[r]=i,n[r].renderObject=n[r]}}newRegionAttachment(t,e,s,n){const r=new eg(e,s);if(n!=null)this.loadSequence(e,s,n);else{const c=this.atlas.findRegion(s);if(!c)throw new Error(`Region not found in atlas: ${s} (region attachment: ${e})`);c.renderObject=c,r.region=c}return r}newMeshAttachment(t,e,s,n){const r=new ka(e,s);if(n!=null)this.loadSequence(e,s,n);else{const c=this.atlas.findRegion(s);if(!c)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${e})`);c.renderObject=c,r.region=c}return r}newBoundingBoxAttachment(t,e){return new bd(e)}newPathAttachment(t,e){return new Fa(e)}newPointAttachment(t,e){return new yd(e)}newClippingAttachment(t,e){return new wd(e)}}var BA=Object.defineProperty,VA=(u,t,e)=>t in u?BA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ie=(u,t,e)=>VA(u,typeof t!="symbol"?t+"":t,e);class kg{constructor(t,e,s){if(Ie(this,"matrix",new G.Matrix),Ie(this,"data"),Ie(this,"skeleton"),Ie(this,"parent",null),Ie(this,"children",new Array),Ie(this,"x",0),Ie(this,"y",0),Ie(this,"rotation",0),Ie(this,"scaleX",0),Ie(this,"scaleY",0),Ie(this,"shearX",0),Ie(this,"shearY",0),Ie(this,"ax",0),Ie(this,"ay",0),Ie(this,"arotation",0),Ie(this,"ascaleX",0),Ie(this,"ascaleY",0),Ie(this,"ashearX",0),Ie(this,"ashearY",0),Ie(this,"sorted",!1),Ie(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=s,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,s,n,r,c,h){this.ax=t,this.ay=e,this.arotation=s,this.ascaleX=n,this.ascaleY=r,this.ashearX=c,this.ashearY=h;const i=this.parent,a=this.matrix,o=this.skeleton.scaleX,d=-this.skeleton.scaleY;if(!i){const p=this.skeleton,y=s+90+h;a.a=Q.cosDeg(s+c)*n*o,a.c=Q.cosDeg(y)*r*o,a.b=Q.sinDeg(s+c)*n*d,a.d=Q.sinDeg(y)*r*d,a.tx=t*o+p.x,a.ty=e*d+p.y;return}let f=i.matrix.a,m=i.matrix.c,l=i.matrix.b,g=i.matrix.d;switch(a.tx=f*t+m*e+i.matrix.tx,a.ty=l*t+g*e+i.matrix.ty,this.data.transformMode){case dn.Normal:{const p=s+90+h,y=Q.cosDeg(s+c)*n,w=Q.cosDeg(p)*r,b=Q.sinDeg(s+c)*n,x=Q.sinDeg(p)*r;a.a=f*y+m*b,a.c=f*w+m*x,a.b=l*y+g*b,a.d=l*w+g*x;return}case dn.OnlyTranslation:{const p=s+90+h;a.a=Q.cosDeg(s+c)*n,a.c=Q.cosDeg(p)*r,a.b=Q.sinDeg(s+c)*n,a.d=Q.sinDeg(p)*r;break}case dn.NoRotationOrReflection:{let p=f*f+l*l,y=0;p>1e-4?(p=Math.abs(f*g-m*l)/p,f/=o,l/=d,m=l*p,g=f*p,y=Math.atan2(l,f)*Q.radDeg):(f=0,l=0,y=90-Math.atan2(g,m)*Q.radDeg);const w=s+c-y,b=s+h-y+90,x=Q.cosDeg(w)*n,S=Q.cosDeg(b)*r,C=Q.sinDeg(w)*n,A=Q.sinDeg(b)*r;a.a=f*x-m*C,a.c=f*S-m*A,a.b=l*x+g*C,a.d=l*S+g*A;break}case dn.NoScale:case dn.NoScaleOrReflection:{const p=Q.cosDeg(s),y=Q.sinDeg(s);let w=(f*p+m*y)/o,b=(l*p+g*y)/d,x=Math.sqrt(w*w+b*b);x>1e-5&&(x=1/x),w*=x,b*=x,x=Math.sqrt(w*w+b*b),this.data.transformMode==dn.NoScale&&f*g-m*l<0!=(o<0!=d<0)&&(x=-x);const S=Math.PI/2+Math.atan2(b,w),C=Math.cos(S)*x,A=Math.sin(S)*x,v=Q.cosDeg(c)*n,M=Q.cosDeg(90+h)*r,E=Q.sinDeg(c)*n,T=Q.sinDeg(90+h)*r;a.a=w*v+C*E,a.c=w*M+C*T,a.b=b*v+A*E,a.d=b*M+A*T;break}}a.a*=o,a.c*=o,a.b*=d,a.d*=d}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*Q.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*Q.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,e=this.matrix;if(!t){this.ax=e.tx-this.skeleton.x,this.ay=e.ty-this.skeleton.y,this.arotation=Math.atan2(e.b,e.a)*Q.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*Q.radDeg;return}const s=t.matrix,n=1/(s.a*s.d-s.b*s.c),r=e.tx-s.tx,c=e.ty-s.ty;this.ax=r*s.d*n-c*s.c*n,this.ay=c*s.a*n-r*s.b*n;const h=n*s.d,i=n*s.a,a=n*s.c,o=n*s.b,d=h*e.a-a*e.b,f=h*e.c-a*e.d,m=i*e.b-o*e.a,l=i*e.d-o*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(d*d+m*m),this.ascaleX>1e-4){const g=d*l-f*m;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(d*f+m*l,g)*Q.radDeg,this.arotation=Math.atan2(m,d)*Q.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(f*f+l*l),this.ashearY=0,this.arotation=90-Math.atan2(l,f)*Q.radDeg}worldToLocal(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,c=e.d,h=1/(s*c-n*r),i=t.x-e.tx,a=t.y-e.ty;return t.x=i*c*h-a*n*h,t.y=a*s*h-i*r*h,t}localToWorld(t){const e=this.matrix,s=t.x,n=t.y;return t.x=s*e.a+n*e.c+e.tx,t.y=s*e.b+n*e.d+e.ty,t}worldToLocalRotation(t){const e=Q.sinDeg(t),s=Q.cosDeg(t),n=this.matrix;return Math.atan2(n.a*e-n.b*s,n.d*s-n.c*e)*Q.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const e=Q.sinDeg(t),s=Q.cosDeg(t),n=this.matrix;return Math.atan2(s*n.b+e*n.d,s*n.a+e*n.c)*Q.radDeg}rotateWorld(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,c=e.d,h=Q.cosDeg(t),i=Q.sinDeg(t);e.a=h*s-i*r,e.c=h*n-i*c,e.b=i*s+h*r,e.d=i*n+h*c}}var NA=Object.defineProperty,DA=(u,t,e)=>t in u?NA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,tn=(u,t,e)=>DA(u,typeof t!="symbol"?t+"":t,e);class Fg{constructor(t,e,s){if(tn(this,"index",0),tn(this,"name"),tn(this,"parent",null),tn(this,"length",0),tn(this,"x",0),tn(this,"y",0),tn(this,"rotation",0),tn(this,"scaleX",1),tn(this,"scaleY",1),tn(this,"shearX",0),tn(this,"shearY",0),tn(this,"transformMode",dn.Normal),tn(this,"skinRequired",!1),tn(this,"color",new Ft),t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=s}}class Id{constructor(t,e,s){this.name=t,this.order=e,this.skinRequired=s}}var LA=Object.defineProperty,OA=(u,t,e)=>t in u?LA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,pa=(u,t,e)=>OA(u,typeof t!="symbol"?t+"":t,e);class Yg{constructor(t,e){if(pa(this,"data"),pa(this,"intValue",0),pa(this,"floatValue",0),pa(this,"stringValue",null),pa(this,"time",0),pa(this,"volume",0),pa(this,"balance",0),!e)throw new Error("data cannot be null.");this.time=t,this.data=e}}var WA=Object.defineProperty,UA=(u,t,e)=>t in u?WA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,ba=(u,t,e)=>UA(u,typeof t!="symbol"?t+"":t,e);class $g{constructor(t){ba(this,"name"),ba(this,"intValue",0),ba(this,"floatValue",0),ba(this,"stringValue",null),ba(this,"audioPath",null),ba(this,"volume",0),ba(this,"balance",0),this.name=t}}var qA=Object.defineProperty,GA=(u,t,e)=>t in u?qA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Xr=(u,t,e)=>GA(u,typeof t!="symbol"?t+"":t,e);class zA{constructor(t,e){if(Xr(this,"data"),Xr(this,"bones"),Xr(this,"target"),Xr(this,"bendDirection",0),Xr(this,"compress",!1),Xr(this,"stretch",!1),Xr(this,"mix",1),Xr(this,"softness",0),Xr(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let n=0;n<t.bones.length;n++){const r=e.findBone(t.bones[n].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[n].name}`);this.bones.push(r)}const s=e.findBone(t.target.name);if(!s)throw new Error(`Couldn't find bone ${t.target.name}`);this.target=s}isActive(){return this.active}update(){if(this.mix==0)return;const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,e,s,n,r,c,h){const i=t.parent.matrix;if(!i)throw new Error("IK bone must have parent.");const a=i.a;let o=i.c;const d=i.b;let f=i.d,m=-t.ashearX-t.arotation,l=0,g=0;const p=t.skeleton.scaleX,y=-t.skeleton.scaleY;switch(t.data.transformMode){case dn.OnlyTranslation:l=e-t.worldX,g=s-t.worldY,g=-g;break;case dn.NoRotationOrReflection:const x=Math.abs(a*f-o*d)/(a*a+d*d),S=a/p,C=d/y;o=-C*x*p,f=S*x*y,m+=Math.atan2(C,S)*Q.radDeg;default:const A=e-i.tx,v=s-i.ty,M=a*f-o*d;l=(A*f-v*o)/M-t.ax,g=(v*a-A*d)/M-t.ay}m+=Math.atan2(g,l)*Q.radDeg,t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let w=t.ascaleX,b=t.ascaleY;if(n||r){switch(t.data.transformMode){case dn.NoScale:case dn.NoScaleOrReflection:l=e-t.worldX,g=s-t.worldY}const x=t.data.length*w,S=Math.sqrt(l*l+g*g);if(n&&S<x||r&&S>x&&x>1e-4){const C=(S/x-1)*h+1;w*=C,c&&(b*=C)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*h,w,b,t.ashearX,t.ashearY)}apply2(t,e,s,n,r,c,h,i,a){const o=t.ax,d=t.ay;let f=t.ascaleX,m=t.ascaleY,l=f,g=m,p=e.ascaleX;const y=t.matrix;let w=0,b=0,x=0;f<0?(f=-f,w=180,x=-1):(w=0,x=1),m<0&&(m=-m,x=-x),p<0?(p=-p,b=180):b=0;const S=e.ax;let C=0,A=0,v=0,M=y.a,E=y.c,T=y.b,R=y.d;const k=Math.abs(f-m)<=1e-4;!k||c?(C=0,A=M*S+y.tx,v=T*S+y.ty):(C=e.ay,A=M*S+E*C+y.tx,v=T*S+R*C+y.ty);const I=t.parent.matrix;if(!I)throw new Error("IK parent must itself have a parent.");M=I.a,E=I.c,T=I.b,R=I.d;const P=1/(M*R-E*T);let F=A-I.tx,X=v-I.ty;const W=(F*R-X*E)*P-o,Y=(X*M-F*T)*P-d,_=Math.sqrt(W*W+Y*Y);let O=e.data.length*p,z,$;if(_<1e-4){this.apply1(t,s,n,!1,c,!1,a),e.updateWorldTransformWith(S,C,0,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY);return}F=s-I.tx,X=n-I.ty;let N=(F*R-X*E)*P-o,V=(X*M-F*T)*P-d,rt=N*N+V*V;if(i!=0){i*=f*(p+1)*.5;const lt=Math.sqrt(rt),At=lt-_-O*f+i;if(At>0){let Ot=Math.min(1,At/(i*2))-1;Ot=(At-i*(1-Ot*Ot))/lt,N-=Ot*N,V-=Ot*V,rt=N*N+V*V}}t:if(k){O*=f;let lt=(rt-_*_-O*O)/(2*_*O);lt<-1?(lt=-1,$=Math.PI*r):lt>1?(lt=1,$=0,c&&(M=(Math.sqrt(rt)/(_+O)-1)*a+1,l*=M,h&&(g*=M))):$=Math.acos(lt)*r,M=_+O*lt,E=O*Math.sin($),z=Math.atan2(V*M-N*E,N*M+V*E)}else{M=f*O,E=m*O;const lt=M*M,At=E*E,Ot=Math.atan2(V,N);T=At*_*_+lt*rt-lt*At;const ie=-2*At*_,bs=At-lt;if(R=ie*ie-4*bs*T,R>=0){let Qt=Math.sqrt(R);ie<0&&(Qt=-Qt),Qt=-(ie+Qt)*.5;const $s=Qt/bs,xr=T/Qt,fn=Math.abs($s)<Math.abs(xr)?$s:xr;if(fn*fn<=rt){X=Math.sqrt(rt-fn*fn)*r,z=Ot-Math.atan2(X,fn),$=Math.atan2(X/m,(fn-_)/f);break t}}let xs=Q.PI,Le=_-M,ze=Le*Le,ws=0,ys=0,ae=_+M,Fe=ae*ae,He=0;T=-M*_/(lt-At),T>=-1&&T<=1&&(T=Math.acos(T),F=M*Math.cos(T)+_,X=E*Math.sin(T),R=F*F+X*X,R<ze&&(xs=T,ze=R,Le=F,ws=X),R>Fe&&(ys=T,Fe=R,ae=F,He=X)),rt<=(ze+Fe)*.5?(z=Ot-Math.atan2(ws*r,Le),$=xs*r):(z=Ot-Math.atan2(He*r,ae),$=ys*r)}const gt=Math.atan2(C,S)*x;let yt=t.arotation;z=(z-gt)*Q.radDeg+w-yt,z>180?z-=360:z<-180&&(z+=360),t.updateWorldTransformWith(o,d,yt+z*a,l,g,0,0),yt=e.arotation,$=(($+gt)*Q.radDeg-e.ashearX)*x+b-yt,$>180?$-=360:$<-180&&($+=360),e.updateWorldTransformWith(S,C,yt+$*a,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}}var HA=Object.defineProperty,KA=(u,t,e)=>t in u?HA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ci=(u,t,e)=>KA(u,typeof t!="symbol"?t+"":t,e);class _g extends Id{constructor(t){super(t,0,!1),Ci(this,"bones",new Array),Ci(this,"_target",null),Ci(this,"bendDirection",1),Ci(this,"compress",!1),Ci(this,"stretch",!1),Ci(this,"uniform",!1),Ci(this,"mix",1),Ci(this,"softness",0)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}var Br=(u=>(u[u.Fixed=0]="Fixed",u[u.Percent=1]="Percent",u))(Br||{}),_a=(u=>(u[u.Tangent=0]="Tangent",u[u.Chain=1]="Chain",u[u.ChainScale=2]="ChainScale",u))(_a||{}),ZA=Object.defineProperty,QA=(u,t,e)=>t in u?ZA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Wn=(u,t,e)=>QA(u,typeof t!="symbol"?t+"":t,e);class Xg extends Id{constructor(t){super(t,0,!1),Wn(this,"bones",new Array),Wn(this,"_target",null),Wn(this,"positionMode",Br.Fixed),Wn(this,"spacingMode",1),Wn(this,"rotateMode",_a.Chain),Wn(this,"offsetRotation",0),Wn(this,"position",0),Wn(this,"spacing",0),Wn(this,"mixRotate",0),Wn(this,"mixX",0),Wn(this,"mixY",0)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}}var ps=(u=>(u[u.Length=0]="Length",u[u.Fixed=1]="Fixed",u[u.Percent=2]="Percent",u[u.Proportional=3]="Proportional",u))(ps||{}),JA=Object.defineProperty,jA=(u,t,e)=>t in u?JA(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ne=(u,t,e)=>jA(u,typeof t!="symbol"?t+"":t,e);const Bo=class qr{constructor(t,e){if(Ne(this,"data"),Ne(this,"bones"),Ne(this,"target"),Ne(this,"position",0),Ne(this,"spacing",0),Ne(this,"mixRotate",0),Ne(this,"mixX",0),Ne(this,"mixY",0),Ne(this,"spaces",new Array),Ne(this,"positions",new Array),Ne(this,"world",new Array),Ne(this,"curves",new Array),Ne(this,"lengths",new Array),Ne(this,"segments",new Array),Ne(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let n=0,r=t.bones.length;n<r;n++){const c=e.findBone(t.bones[n].name);if(!c)throw new Error(`Couldn't find bone ${t.bones[n].name}.`);this.bones.push(c)}const s=e.findSlot(t.target.name);if(!s)throw new Error(`Couldn't find target bone ${t.target.name}`);this.target=s,this.position=t.position,this.spacing=t.spacing,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY}isActive(){return this.active}update(){const t=this.target.getAttachment();if(!(t instanceof Fa))return;const e=this.mixRotate,s=this.mixX,n=this.mixY;if(e==0&&s==0&&n==0)return;const r=this.data,c=r.rotateMode==_a.Tangent,h=r.rotateMode==_a.ChainScale,i=this.bones,a=i.length,o=c?a:a+1,d=dt.setArraySize(this.spaces,o),f=h?this.lengths=dt.setArraySize(this.lengths,a):[],m=this.spacing;switch(r.spacingMode){case ps.Percent:if(h)for(let S=0,C=o-1;S<C;S++){const A=i[S],v=A.data.length;if(v<qr.epsilon)f[S]=0;else{const M=v*A.matrix.a,E=v*A.matrix.b;f[S]=Math.sqrt(M*M+E*E)}}dt.arrayFill(d,1,o,m);break;case ps.Proportional:let b=0;for(let S=0,C=o-1;S<C;){const A=i[S],v=A.data.length;if(v<qr.epsilon)h&&(f[S]=0),d[++S]=m;else{const M=v*A.matrix.a,E=v*A.matrix.b,T=Math.sqrt(M*M+E*E);h&&(f[S]=T),d[++S]=T,b+=T}}if(b>0){b=o/b*m;for(let S=1;S<o;S++)d[S]*=b}break;default:const x=r.spacingMode==ps.Length;for(let S=0,C=o-1;S<C;){const A=i[S],v=A.data.length;if(v<qr.epsilon)h&&(f[S]=0),d[++S]=m;else{const M=v*A.matrix.a,E=v*A.matrix.b,T=Math.sqrt(M*M+E*E);h&&(f[S]=T),d[++S]=(x?v+m:m)*T/v}}}const l=this.computeWorldPositions(t,o,c);let g=l[0],p=l[1],y=r.offsetRotation,w=!1;if(y==0)w=r.rotateMode==_a.Chain;else{w=!1;const b=this.target.bone.matrix;y*=b.a*b.d-b.b*b.c>0?Q.degRad:-Q.degRad}for(let b=0,x=3;b<a;b++,x+=3){const S=i[b],C=S.matrix;C.tx+=(g-C.tx)*s,C.ty+=(p-C.ty)*n;const A=l[x],v=l[x+1],M=A-g,E=v-p;if(h){const T=f[b];if(T!=0){const R=(Math.sqrt(M*M+E*E)/T-1)*e+1;C.a*=R,C.b*=R}}if(g=A,p=v,e>0){const T=C.a,R=C.c,k=C.b,I=C.d;let P=0,F=0,X=0;if(c?P=l[x-1]:d[b+1]==0?P=l[x+2]:P=Math.atan2(E,M),P-=Math.atan2(k,T),w){F=Math.cos(P),X=Math.sin(P);const W=S.data.length;g+=(W*(F*T-X*k)-M)*e,p+=(W*(X*T+F*k)-E)*e}else P+=y;P>Q.PI?P-=Q.PI2:P<-Q.PI&&(P+=Q.PI2),P*=e,F=Math.cos(P),X=Math.sin(P),C.a=F*T-X*k,C.c=F*R-X*I,C.b=X*T+F*k,C.d=X*R+F*I}S.updateAppliedTransform()}}computeWorldPositions(t,e,s){const n=this.target;let r=this.position;const c=this.spaces,h=dt.setArraySize(this.positions,e*3+2);let i=this.world;const a=t.closed;let o=t.worldVerticesLength,d=o/6,f=qr.NONE;if(!t.constantSpeed){const W=t.lengths;d-=a?1:2;const Y=W[d];this.data.positionMode==Br.Percent&&(r*=Y);let _;switch(this.data.spacingMode){case ps.Percent:_=Y;break;case ps.Proportional:_=Y/e;break;default:_=1}i=dt.setArraySize(this.world,8);for(let O=0,z=0,$=0;O<e;O++,z+=3){const N=c[O]*_;r+=N;let V=r;if(a)V%=Y,V<0&&(V+=Y),$=0;else if(V<0){f!=qr.BEFORE&&(f=qr.BEFORE,t.computeWorldVertices(n,2,4,i,0,2)),this.addBeforePosition(V,i,0,h,z);continue}else if(V>Y){f!=qr.AFTER&&(f=qr.AFTER,t.computeWorldVertices(n,o-6,4,i,0,2)),this.addAfterPosition(V-Y,i,0,h,z);continue}for(;;$++){const rt=W[$];if(!(V>rt)){if($==0)V/=rt;else{const gt=W[$-1];V=(V-gt)/(rt-gt)}break}}$!=f&&(f=$,a&&$==d?(t.computeWorldVertices(n,o-4,4,i,0,2),t.computeWorldVertices(n,0,4,i,4,2)):t.computeWorldVertices(n,$*6+2,8,i,0,2)),this.addCurvePosition(V,i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7],h,z,s||O>0&&N==0)}return h}a?(o+=2,i=dt.setArraySize(this.world,o),t.computeWorldVertices(n,2,o-4,i,0,2),t.computeWorldVertices(n,0,2,i,o-4,2),i[o-2]=i[0],i[o-1]=i[1]):(d--,o-=4,i=dt.setArraySize(this.world,o),t.computeWorldVertices(n,2,o,i,0,2));const m=dt.setArraySize(this.curves,d);let l=0,g=i[0],p=i[1],y=0,w=0,b=0,x=0,S=0,C=0,A=0,v=0,M=0,E=0,T=0,R=0,k=0,I=0;for(let W=0,Y=2;W<d;W++,Y+=6)y=i[Y],w=i[Y+1],b=i[Y+2],x=i[Y+3],S=i[Y+4],C=i[Y+5],A=(g-y*2+b)*.1875,v=(p-w*2+x)*.1875,M=((y-b)*3-g+S)*.09375,E=((w-x)*3-p+C)*.09375,T=A*2+M,R=v*2+E,k=(y-g)*.75+A+M*.16666667,I=(w-p)*.75+v+E*.16666667,l+=Math.sqrt(k*k+I*I),k+=T,I+=R,T+=M,R+=E,l+=Math.sqrt(k*k+I*I),k+=T,I+=R,l+=Math.sqrt(k*k+I*I),k+=T+M,I+=R+E,l+=Math.sqrt(k*k+I*I),m[W]=l,g=S,p=C;this.data.positionMode==Br.Percent&&(r*=l);let P;switch(this.data.spacingMode){case ps.Percent:P=l;break;case ps.Proportional:P=l/e;break;default:P=1}const F=this.segments;let X=0;for(let W=0,Y=0,_=0,O=0;W<e;W++,Y+=3){const z=c[W]*P;r+=z;let $=r;if(a)$%=l,$<0&&($+=l),_=0;else if($<0){this.addBeforePosition($,i,0,h,Y);continue}else if($>l){this.addAfterPosition($-l,i,o-4,h,Y);continue}for(;;_++){const N=m[_];if(!($>N)){if(_==0)$/=N;else{const V=m[_-1];$=($-V)/(N-V)}break}}if(_!=f){f=_;let N=_*6;for(g=i[N],p=i[N+1],y=i[N+2],w=i[N+3],b=i[N+4],x=i[N+5],S=i[N+6],C=i[N+7],A=(g-y*2+b)*.03,v=(p-w*2+x)*.03,M=((y-b)*3-g+S)*.006,E=((w-x)*3-p+C)*.006,T=A*2+M,R=v*2+E,k=(y-g)*.3+A+M*.16666667,I=(w-p)*.3+v+E*.16666667,X=Math.sqrt(k*k+I*I),F[0]=X,N=1;N<8;N++)k+=T,I+=R,T+=M,R+=E,X+=Math.sqrt(k*k+I*I),F[N]=X;k+=T,I+=R,X+=Math.sqrt(k*k+I*I),F[8]=X,k+=T+M,I+=R+E,X+=Math.sqrt(k*k+I*I),F[9]=X,O=0}for($*=X;;O++){const N=F[O];if(!($>N)){if(O==0)$/=N;else{const V=F[O-1];$=O+($-V)/(N-V)}break}}this.addCurvePosition($*.1,g,p,y,w,b,x,S,C,h,Y,s||W>0&&z==0)}return h}addBeforePosition(t,e,s,n,r){const c=e[s],h=e[s+1],i=e[s+2]-c,a=e[s+3]-h,o=Math.atan2(a,i);n[r]=c+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addAfterPosition(t,e,s,n,r){const c=e[s+2],h=e[s+3],i=c-e[s],a=h-e[s+1],o=Math.atan2(a,i);n[r]=c+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addCurvePosition(t,e,s,n,r,c,h,i,a,o,d,f){if(t==0||isNaN(t)){o[d]=e,o[d+1]=s,o[d+2]=Math.atan2(r-s,n-e);return}const m=t*t,l=m*t,g=1-t,p=g*g,y=p*g,w=g*t,b=w*3,x=g*b,S=b*t,C=e*y+n*x+c*S+i*l,A=s*y+r*x+h*S+a*l;o[d]=C,o[d+1]=A,f&&(t<.001?o[d+2]=Math.atan2(r-s,n-e):o[d+2]=Math.atan2(A-(s*p+r*w*2+h*m),C-(e*p+n*w*2+c*m)))}};Ne(Bo,"NONE",-1),Ne(Bo,"BEFORE",-2),Ne(Bo,"AFTER",-3),Ne(Bo,"epsilon",1e-5);let tv=Bo;var ev=Object.defineProperty,sv=(u,t,e)=>t in u?ev(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Vr=(u,t,e)=>sv(u,typeof t!="symbol"?t+"":t,e);class nv{constructor(t,e){if(Vr(this,"blendMode"),Vr(this,"data"),Vr(this,"bone"),Vr(this,"color"),Vr(this,"darkColor",null),Vr(this,"attachment",null),Vr(this,"attachmentState",0),Vr(this,"sequenceIndex",-1),Vr(this,"deform",new Array),!t)throw new Error("data cannot be null.");if(!e)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new Ft,this.darkColor=t.darkColor?new Ft:null,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&((!(t instanceof $r)||!(this.attachment instanceof $r)||t.timelineAttachment!=this.attachment.timelineAttachment)&&(this.deform.length=0),this.attachment=t,this.sequenceIndex=-1)}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName?(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName))):this.attachment=null}}var rv=Object.defineProperty,iv=(u,t,e)=>t in u?rv(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Un=(u,t,e)=>iv(u,typeof t!="symbol"?t+"":t,e);class av{constructor(t,e){if(Un(this,"data"),Un(this,"bones"),Un(this,"target"),Un(this,"mixRotate",0),Un(this,"mixX",0),Un(this,"mixY",0),Un(this,"mixScaleX",0),Un(this,"mixScaleY",0),Un(this,"mixShearY",0),Un(this,"temp",new pd),Un(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let n=0;n<t.bones.length;n++){const r=e.findBone(t.bones[n].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[n].name}.`);this.bones.push(r)}const s=e.findBone(t.target.name);if(!s)throw new Error(`Couldn't find target bone ${t.target.name}.`);this.target=s}isActive(){return this.active}update(){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleX==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,c=this.mixShearY,h=e!=0||s!=0,i=this.target,a=i.matrix,o=a.a,d=a.c,f=a.b,m=a.d,l=o*m-d*f>0?Q.degRad:-Q.degRad,g=this.data.offsetRotation*l,p=this.data.offsetShearY*l,y=this.bones;for(let w=0,b=y.length;w<b;w++){const x=y[w],S=x.matrix;if(t!=0){const C=S.a,A=S.c,v=S.b,M=S.d;let E=Math.atan2(f,o)-Math.atan2(v,C)+g;E>Q.PI?E-=Q.PI2:E<-Q.PI&&(E+=Q.PI2),E*=t;const T=Math.cos(E),R=Math.sin(E);S.a=T*C-R*v,S.c=T*A-R*M,S.b=R*C+T*v,S.d=R*A+T*M}if(h){const C=this.temp;i.localToWorld(C.set(this.data.offsetX,this.data.offsetY)),S.tx+=(C.x-S.tx)*e,S.ty+=(C.y-S.ty)*s}if(n!=0){let C=Math.sqrt(S.a*S.a+S.b*S.b);C!=0&&(C=(C+(Math.sqrt(o*o+f*f)-C+this.data.offsetScaleX)*n)/C),S.a*=C,S.b*=C}if(r!=0){let C=Math.sqrt(S.c*S.c+S.d*S.d);C!=0&&(C=(C+(Math.sqrt(d*d+m*m)-C+this.data.offsetScaleY)*r)/C),S.c*=C,S.d*=C}if(c>0){const C=S.c,A=S.d,v=Math.atan2(A,C);let M=Math.atan2(m,d)-Math.atan2(f,o)-(v-Math.atan2(S.b,S.a));M>Q.PI?M-=Q.PI2:M<-Q.PI&&(M+=Q.PI2),M=v+(M+p)*c;const E=Math.sqrt(C*C+A*A);S.c=Math.cos(M)*E,S.d=Math.sin(M)*E}x.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,c=this.mixShearY,h=e!=0||s!=0,i=this.target,a=i.matrix,o=a.a,d=a.c,f=a.b,m=a.d,l=o*m-d*f>0?Q.degRad:-Q.degRad,g=this.data.offsetRotation*l,p=this.data.offsetShearY*l,y=this.bones;for(let w=0,b=y.length;w<b;w++){const x=y[w],S=x.matrix;if(t!=0){const C=S.a,A=S.c,v=S.b,M=S.d;let E=Math.atan2(f,o)+g;E>Q.PI?E-=Q.PI2:E<-Q.PI&&(E+=Q.PI2),E*=t;const T=Math.cos(E),R=Math.sin(E);S.a=T*C-R*v,S.c=T*A-R*M,S.b=R*C+T*v,S.d=R*A+T*M}if(h){const C=this.temp;i.localToWorld(C.set(this.data.offsetX,this.data.offsetY)),S.tx+=C.x*e,S.ty+=C.y*s}if(n!=0){const C=(Math.sqrt(o*o+f*f)-1+this.data.offsetScaleX)*n+1;S.a*=C,S.b*=C}if(r!=0){const C=(Math.sqrt(d*d+m*m)-1+this.data.offsetScaleY)*r+1;S.c*=C,S.d*=C}if(c>0){let C=Math.atan2(m,d)-Math.atan2(f,o);C>Q.PI?C-=Q.PI2:C<-Q.PI&&(C+=Q.PI2);const A=S.c,v=S.d;C=Math.atan2(v,A)+(C-Q.PI/2+p)*c;const M=Math.sqrt(A*A+v*v);S.c=Math.cos(C)*M,S.d=Math.sin(C)*M}x.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,c=this.mixShearY,h=this.target,i=this.bones;for(let a=0,o=i.length;a<o;a++){const d=i[a];let f=d.arotation;if(t!=0){let w=h.arotation-f+this.data.offsetRotation;w-=(16384-(16384.499999999996-w/360|0))*360,f+=w*t}let m=d.ax,l=d.ay;m+=(h.ax-m+this.data.offsetX)*e,l+=(h.ay-l+this.data.offsetY)*s;let g=d.ascaleX,p=d.ascaleY;n!=0&&g!=0&&(g=(g+(h.ascaleX-g+this.data.offsetScaleX)*n)/g),r!=0&&p!=0&&(p=(p+(h.ascaleY-p+this.data.offsetScaleY)*r)/p);let y=d.ashearY;if(c!=0){let w=h.ashearY-y+this.data.offsetShearY;w-=(16384-(16384.499999999996-w/360|0))*360,y+=w*c}d.updateWorldTransformWith(m,l,f,g,p,d.ashearX,y)}}applyRelativeLocal(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,c=this.mixShearY,h=this.target,i=this.bones;for(let a=0,o=i.length;a<o;a++){const d=i[a],f=d.arotation+(h.arotation+this.data.offsetRotation)*t,m=d.ax+(h.ax+this.data.offsetX)*e,l=d.ay+(h.ay+this.data.offsetY)*s,g=d.ascaleX*((h.ascaleX-1+this.data.offsetScaleX)*n+1),p=d.ascaleY*((h.ascaleY-1+this.data.offsetScaleY)*r+1),y=d.ashearY+(h.ashearY+this.data.offsetShearY)*c;d.updateWorldTransformWith(m,l,f,g,p,d.ashearX,y)}}}var ov=Object.defineProperty,lv=(u,t,e)=>t in u?ov(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ys=(u,t,e)=>lv(u,typeof t!="symbol"?t+"":t,e);const Bg=class Ko{constructor(t){if(Ys(this,"data"),Ys(this,"bones"),Ys(this,"slots"),Ys(this,"drawOrder"),Ys(this,"ikConstraints"),Ys(this,"transformConstraints"),Ys(this,"pathConstraints"),Ys(this,"_updateCache",new Array),Ys(this,"skin",null),Ys(this,"color"),Ys(this,"scaleX",1),Ys(this,"scaleY",1),Ys(this,"x",0),Ys(this,"y",0),!t)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const s=t.bones[e];let n;if(!s.parent)n=new kg(s,this,null);else{const r=this.bones[s.parent.index];n=new kg(s,this,r),r.children.push(n)}this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const s=t.slots[e],n=this.bones[s.boneData.index],r=new nv(s,n);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const s=t.ikConstraints[e];this.ikConstraints.push(new zA(s,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const s=t.transformConstraints[e];this.transformConstraints.push(new av(s,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const s=t.pathConstraints[e];this.pathConstraints.push(new tv(s,this))}this.color=new Ft(1,1,1,1),this.updateCache()}updateCache(){const t=this._updateCache;t.length=0;const e=this.bones;for(let o=0,d=e.length;o<d;o++){const f=e[o];f.sorted=f.data.skinRequired,f.active=!f.sorted}if(this.skin){const o=this.skin.bones;for(let d=0,f=this.skin.bones.length;d<f;d++){let m=this.bones[o[d].index];do m.sorted=!1,m.active=!0,m=m.parent;while(m)}}const s=this.ikConstraints,n=this.transformConstraints,r=this.pathConstraints,c=s.length,h=n.length,i=r.length,a=c+h+i;t:for(let o=0;o<a;o++){for(let d=0;d<c;d++){const f=s[d];if(f.data.order==o){this.sortIkConstraint(f);continue t}}for(let d=0;d<h;d++){const f=n[d];if(f.data.order==o){this.sortTransformConstraint(f);continue t}}for(let d=0;d<i;d++){const f=r[d];if(f.data.order==o){this.sortPathConstraint(f);continue t}}}for(let o=0,d=e.length;o<d;o++)this.sortBone(e[o])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&dt.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target;this.sortBone(e);const s=t.bones,n=s[0];if(this.sortBone(n),s.length==1)this._updateCache.push(t),this.sortReset(n.children);else{const r=s[s.length-1];this.sortBone(r),this._updateCache.push(t),this.sortReset(n.children),r.sorted=!0}}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||this.skin&&dt.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target,s=e.data.index,n=e.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,s,n),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,n);for(let i=0,a=this.data.skins.length;i<a;i++)this.sortPathConstraintAttachment(this.data.skins[i],s,n);const r=e.getAttachment();r instanceof Fa&&this.sortPathConstraintAttachmentWith(r,n);const c=t.bones,h=c.length;for(let i=0;i<h;i++)this.sortBone(c[i]);this._updateCache.push(t);for(let i=0;i<h;i++)this.sortReset(c[i].children);for(let i=0;i<h;i++)c[i].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&dt.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);const e=t.bones,s=e.length;if(t.data.local)for(let n=0;n<s;n++){const r=e[n];this.sortBone(r.parent),this.sortBone(r)}else for(let n=0;n<s;n++)this.sortBone(e[n]);this._updateCache.push(t);for(let n=0;n<s;n++)this.sortReset(e[n].children);for(let n=0;n<s;n++)e[n].sorted=!0}sortPathConstraintAttachment(t,e,s){const n=t.attachments[e];if(n)for(const r in n)this.sortPathConstraintAttachmentWith(n[r],s)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof Fa))return;const s=t.bones;if(!s)this.sortBone(e);else{const n=this.bones;for(let r=0,c=s.length;r<c;){let h=s[r++];for(h+=r;r<h;)this.sortBone(n[s[r++]])}}}sortBone(t){if(!t||t.sorted)return;const e=t.parent;e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,s=t.length;e<s;e++){const n=t[e];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(){const t=this.bones;for(let s=0,n=t.length;s<n;s++){const r=t[s];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY}const e=this._updateCache;for(let s=0,n=e.length;s<n;s++)e[s].update()}updateWorldTransformWith(t){const e=this.getRootBone(),s=t.matrix.a,n=t.matrix.c,r=t.matrix.b,c=t.matrix.d;e.matrix.tx=s*this.x+n*this.y+t.worldX,e.matrix.ty=r*this.x+c*this.y+t.worldY;const h=e.rotation+90+e.shearY,i=Q.cosDeg(e.rotation+e.shearX)*e.scaleX,a=Q.cosDeg(h)*e.scaleY,o=Q.sinDeg(e.rotation+e.shearX)*e.scaleX,d=Q.sinDeg(h)*e.scaleY,f=this.scaleX,m=-this.scaleY;e.matrix.a=(s*i+n*o)*f,e.matrix.c=(s*a+n*d)*f,e.matrix.b=(r*i+c*o)*m,e.matrix.d=(r*a+c*d)*m;const l=this._updateCache;for(let g=0,p=l.length;g<p;g++){const y=l[g];y!=e&&y.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let r=0,c=t.length;r<c;r++)t[r].setToSetupPose();const e=this.ikConstraints;for(let r=0,c=e.length;r<c;r++){const h=e[r];h.mix=h.data.mix,h.softness=h.data.softness,h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch}const s=this.transformConstraints;for(let r=0,c=s.length;r<c;r++){const h=s[r],i=h.data;h.mixRotate=i.mixRotate,h.mixX=i.mixX,h.mixY=i.mixY,h.mixScaleX=i.mixScaleX,h.mixScaleY=i.mixScaleY,h.mixShearY=i.mixShearY}const n=this.pathConstraints;for(let r=0,c=n.length;r<c;r++){const h=n[r],i=h.data;h.position=i.position,h.spacing=i.spacing,h.mixRotate=i.mixRotate,h.mixX=i.mixX,h.mixY=i.mixY}}setSlotsToSetupPose(){const t=this.slots;dt.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,s=t.length;e<s;e++)t[e].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(!e)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(t)if(this.skin)t.attachAll(this,this.skin);else{const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s],c=r.data.attachmentName;if(c){const h=t.getAttachment(s,c);h&&r.setAttachment(h)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){const s=this.data.findSlot(t);if(!s)throw new Error(`Can't find slot with name ${t}`);return this.getAttachment(s.index,e)}getAttachment(t,e){if(!e)throw new Error("attachmentName cannot be null.");if(this.skin){const s=this.skin.getAttachment(t,e);if(s)return s}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(!t)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,r=s.length;n<r;n++){const c=s[n];if(c.data.name==t){let h=null;if(e&&(h=this.getAttachment(n,e),!h))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);c.setAttachment(h);return}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}getBoundsRect(){const t=new pd,e=new pd;return this.getBounds(t,e),{x:t.x,y:t.y,width:e.x,height:e.y}}getBounds(t,e,s=new Array(2)){if(!t)throw new Error("offset cannot be null.");if(!e)throw new Error("size cannot be null.");const n=this.drawOrder;let r=Number.POSITIVE_INFINITY,c=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY,i=Number.NEGATIVE_INFINITY;for(let a=0,o=n.length;a<o;a++){const d=n[a];if(!d.bone.active)continue;let f=0,m=null;const l=d.getAttachment();if(l instanceof eg)f=8,m=dt.setArraySize(s,f,0),l.computeWorldVertices(d,m,0,2);else if(l instanceof ka){const g=l;f=g.worldVerticesLength,m=dt.setArraySize(s,f,0),g.computeWorldVertices(d,0,f,m,0,2)}if(m)for(let g=0,p=m.length;g<p;g+=2){const y=m[g],w=m[g+1];r=Math.min(r,y),c=Math.min(c,w),h=Math.max(h,y),i=Math.max(i,w)}}t.set(r,c),e.set(h-r,i-c)}get flipX(){return this.scaleX==-1}set flipX(t){Ko.deprecatedWarning1||(Ko.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return this.scaleY==-1}set flipY(t){Ko.deprecatedWarning1||(Ko.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};Ys(Bg,"deprecatedWarning1",!1);let cv=Bg;var hv=Object.defineProperty,dv=(u,t,e)=>t in u?hv(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,De=(u,t,e)=>dv(u,typeof t!="symbol"?t+"":t,e);class Vg{constructor(){De(this,"name",null),De(this,"bones",new Array),De(this,"slots",new Array),De(this,"skins",new Array),De(this,"defaultSkin",null),De(this,"events",new Array),De(this,"animations",new Array),De(this,"ikConstraints",new Array),De(this,"transformConstraints",new Array),De(this,"pathConstraints",new Array),De(this,"x",0),De(this,"y",0),De(this,"width",0),De(this,"height",0),De(this,"version",null),De(this,"hash",null),De(this,"fps",0),De(this,"imagesPath",null),De(this,"audioPath",null)}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const e=this.skins;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const e=this.events;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const e=this.animations;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}}var uv=Object.defineProperty,fv=(u,t,e)=>t in u?uv(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,xa=(u,t,e)=>fv(u,typeof t!="symbol"?t+"":t,e);class Ng{constructor(t,e,s){if(xa(this,"index",0),xa(this,"name"),xa(this,"boneData"),xa(this,"color",new Ft(1,1,1,1)),xa(this,"darkColor",null),xa(this,"attachmentName",null),xa(this,"blendMode",G.BLEND_MODES.NORMAL),t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");if(!s)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=s}}var mv=Object.defineProperty,gv=(u,t,e)=>t in u?mv(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Rs=(u,t,e)=>gv(u,typeof t!="symbol"?t+"":t,e);class Dg extends Id{constructor(t){super(t,0,!1),Rs(this,"bones",new Array),Rs(this,"_target",null),Rs(this,"mixRotate",0),Rs(this,"mixX",0),Rs(this,"mixY",0),Rs(this,"mixScaleX",0),Rs(this,"mixScaleY",0),Rs(this,"mixShearY",0),Rs(this,"offsetRotation",0),Rs(this,"offsetX",0),Rs(this,"offsetY",0),Rs(this,"offsetScaleX",0),Rs(this,"offsetScaleY",0),Rs(this,"offsetShearY",0),Rs(this,"relative",!1),Rs(this,"local",!1)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}var pv=Object.defineProperty,bv=(u,t,e)=>t in u?pv(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Pl=(u,t,e)=>bv(u,typeof t!="symbol"?t+"":t,e);class Lg{constructor(t,e,s){this.slotIndex=t,this.name=e,this.attachment=s}}class Rd{constructor(t){if(Pl(this,"name"),Pl(this,"attachments",new Array),Pl(this,"bones",Array()),Pl(this,"constraints",new Array),!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,e,s){if(!s)throw new Error("attachment cannot be null.");const n=this.attachments;t>=n.length&&(n.length=t+1),n[t]||(n[t]={}),n[t][e]=s}addSkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];this.setAttachment(n.slotIndex,n.name,n.attachment)}}copySkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];n.attachment&&(n.attachment instanceof ka?(n.attachment=n.attachment.newLinkedMesh(),this.setAttachment(n.slotIndex,n.name,n.attachment)):(n.attachment=n.attachment.copy(),this.setAttachment(n.slotIndex,n.name,n.attachment)))}}getAttachment(t,e){const s=this.attachments[t];return s?s[e]:null}removeAttachment(t,e){const s=this.attachments[t];s&&delete s[e]}getAttachments(){const t=new Array;for(let e=0;e<this.attachments.length;e++){const s=this.attachments[e];if(s)for(const n in s){const r=s[n];r&&t.push(new Lg(e,n,r))}}return t}getAttachmentsForSlot(t,e){const s=this.attachments[t];if(s)for(const n in s){const r=s[n];r&&e.push(new Lg(t,n,r))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,e){let s=0;for(let n=0;n<t.slots.length;n++){const r=t.slots[n],c=r.getAttachment();if(c&&s<e.attachments.length){const h=e.attachments[s];for(const i in h){const a=h[i];if(c==a){const o=this.getAttachment(s,i);o&&r.setAttachment(o);break}}}s++}}}class xv{constructor(t,e=new Array,s=0,n=new DataView(t.buffer)){this.strings=e,this.index=s,this.buffer=n}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),s=e&127;return e&128&&(e=this.readByte(),s|=(e&127)<<7,e&128&&(e=this.readByte(),s|=(e&127)<<14,e&128&&(e=this.readByte(),s|=(e&127)<<21,e&128&&(e=this.readByte(),s|=(e&127)<<28)))),t?s:s>>>1^-(s&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let s=0;s<t;){const n=this.readUnsignedByte();switch(n>>4){case 12:case 13:e+=String.fromCharCode((n&31)<<6|this.readByte()&63),s+=2;break;case 14:e+=String.fromCharCode((n&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),s+=3;break;default:e+=String.fromCharCode(n),s++}}return e}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}}var wv=Object.defineProperty,yv=(u,t,e)=>t in u?wv(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,pr=(u,t,e)=>yv(u,typeof t!="symbol"?t+"":t,e);class Sv{constructor(t){pr(this,"ver40",!1),pr(this,"scale",1),pr(this,"attachmentLoader"),pr(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new Vg;s.name="";const n=new xv(t),r=n.readInt32(),c=n.readInt32();s.hash=c==0&&r==0?null:c.toString(16)+r.toString(16),s.version=n.readString();const h=s.version.substr(0,3);if(h!=="4.0"&&h!=="4.1"){const d=`Spine 4.1 loader cant load version ${s.version}. Please configure your pixi-spine bundle`;console.error(d)}this.ver40=h==="4.0",s.x=n.readFloat(),s.y=n.readFloat(),s.width=n.readFloat(),s.height=n.readFloat();const i=n.readBoolean();i&&(s.fps=n.readFloat(),s.imagesPath=n.readString(),s.audioPath=n.readString());let a=0;a=n.readInt(!0);for(let d=0;d<a;d++){const f=n.readString();if(!f)throw new Error("String in string table must not be null.");n.strings.push(f)}a=n.readInt(!0);for(let d=0;d<a;d++){const f=n.readString();if(!f)throw new Error("Bone name must not be null.");const m=d==0?null:s.bones[n.readInt(!0)],l=new Fg(d,f,m);l.rotation=n.readFloat(),l.x=n.readFloat()*e,l.y=n.readFloat()*e,l.scaleX=n.readFloat(),l.scaleY=n.readFloat(),l.shearX=n.readFloat(),l.shearY=n.readFloat(),l.length=n.readFloat()*e,l.transformMode=n.readInt(!0),l.skinRequired=n.readBoolean(),i&&Ft.rgba8888ToColor(l.color,n.readInt32()),s.bones.push(l)}a=n.readInt(!0);for(let d=0;d<a;d++){const f=n.readString();if(!f)throw new Error("Slot name must not be null.");const m=s.bones[n.readInt(!0)],l=new Ng(d,f,m);Ft.rgba8888ToColor(l.color,n.readInt32());const g=n.readInt32();g!=-1&&Ft.rgb888ToColor(l.darkColor=new Ft,g),l.attachmentName=n.readStringRef(),l.blendMode=n.readInt(!0),s.slots.push(l)}a=n.readInt(!0);for(let d=0,f;d<a;d++){const m=n.readString();if(!m)throw new Error("IK constraint data name must not be null.");const l=new _g(m);l.order=n.readInt(!0),l.skinRequired=n.readBoolean(),f=n.readInt(!0);for(let g=0;g<f;g++)l.bones.push(s.bones[n.readInt(!0)]);l.target=s.bones[n.readInt(!0)],l.mix=n.readFloat(),l.softness=n.readFloat()*e,l.bendDirection=n.readByte(),l.compress=n.readBoolean(),l.stretch=n.readBoolean(),l.uniform=n.readBoolean(),s.ikConstraints.push(l)}a=n.readInt(!0);for(let d=0,f;d<a;d++){const m=n.readString();if(!m)throw new Error("Transform constraint data name must not be null.");const l=new Dg(m);l.order=n.readInt(!0),l.skinRequired=n.readBoolean(),f=n.readInt(!0);for(let g=0;g<f;g++)l.bones.push(s.bones[n.readInt(!0)]);l.target=s.bones[n.readInt(!0)],l.local=n.readBoolean(),l.relative=n.readBoolean(),l.offsetRotation=n.readFloat(),l.offsetX=n.readFloat()*e,l.offsetY=n.readFloat()*e,l.offsetScaleX=n.readFloat(),l.offsetScaleY=n.readFloat(),l.offsetShearY=n.readFloat(),l.mixRotate=n.readFloat(),l.mixX=n.readFloat(),l.mixY=n.readFloat(),l.mixScaleX=n.readFloat(),l.mixScaleY=n.readFloat(),l.mixShearY=n.readFloat(),s.transformConstraints.push(l)}a=n.readInt(!0);for(let d=0,f;d<a;d++){const m=n.readString();if(!m)throw new Error("Path constraint data name must not be null.");const l=new Xg(m);l.order=n.readInt(!0),l.skinRequired=n.readBoolean(),f=n.readInt(!0);for(let g=0;g<f;g++)l.bones.push(s.bones[n.readInt(!0)]);l.target=s.slots[n.readInt(!0)],l.positionMode=n.readInt(!0),l.spacingMode=n.readInt(!0),l.rotateMode=n.readInt(!0),l.offsetRotation=n.readFloat(),l.position=n.readFloat(),l.positionMode==Br.Fixed&&(l.position*=e),l.spacing=n.readFloat(),(l.spacingMode==ps.Length||l.spacingMode==ps.Fixed)&&(l.spacing*=e),l.mixRotate=n.readFloat(),l.mixX=n.readFloat(),l.mixY=n.readFloat(),s.pathConstraints.push(l)}const o=this.readSkin(n,s,!0,i);o&&(s.defaultSkin=o,s.skins.push(o));{let d=s.skins.length;for(dt.setArraySize(s.skins,a=d+n.readInt(!0));d<a;d++){const f=this.readSkin(n,s,!1,i);if(!f)throw new Error("readSkin() should not have returned null.");s.skins[d]=f}}a=this.linkedMeshes.length;for(let d=0;d<a;d++){const f=this.linkedMeshes[d],m=f.skin?s.findSkin(f.skin):s.defaultSkin;if(!m)throw new Error("Not skin found for linked mesh.");if(!f.parent)throw new Error("Linked mesh parent must not be null");const l=m.getAttachment(f.slotIndex,f.parent);if(!l)throw new Error(`Parent mesh not found: ${f.parent}`);f.mesh.timelineAttachment=f.inheritTimeline?l:f.mesh,f.mesh.setParentMesh(l)}this.linkedMeshes.length=0,a=n.readInt(!0);for(let d=0;d<a;d++){const f=n.readStringRef();if(!f)throw new Error;const m=new $g(f);m.intValue=n.readInt(!1),m.floatValue=n.readFloat(),m.stringValue=n.readString(),m.audioPath=n.readString(),m.audioPath&&(m.volume=n.readFloat(),m.balance=n.readFloat()),s.events.push(m)}a=n.readInt(!0);for(let d=0;d<a;d++){const f=n.readString();if(!f)throw new Error("Animatio name must not be null.");s.animations.push(this.readAnimation(n,f,s))}return s}readSkin(t,e,s,n){let r=null,c=0;if(s){if(c=t.readInt(!0),c==0)return null;r=new Rd("default")}else{const h=t.readStringRef();if(!h)throw new Error("Skin name must not be null.");r=new Rd(h),r.bones.length=t.readInt(!0);for(let i=0,a=r.bones.length;i<a;i++)r.bones[i]=e.bones[t.readInt(!0)];for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.ikConstraints[t.readInt(!0)]);for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.transformConstraints[t.readInt(!0)]);for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.pathConstraints[t.readInt(!0)]);c=t.readInt(!0)}for(let h=0;h<c;h++){const i=t.readInt(!0);for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readStringRef();if(!d)throw new Error("Attachment name must not be null");const f=this.readAttachment(t,e,r,i,d,n);f&&r.setAttachment(i,d,f)}}return r}readAttachment(t,e,s,n,r,c){const h=this.scale;let i=t.readStringRef();switch(i||(i=r),t.readByte()){case Ee.Region:{let a=t.readStringRef();const o=t.readFloat(),d=t.readFloat(),f=t.readFloat(),m=t.readFloat(),l=t.readFloat(),g=t.readFloat(),p=t.readFloat(),y=t.readInt32(),w=this.readSequence(t);a||(a=i);const b=this.attachmentLoader.newRegionAttachment(s,i,a,w);return b?(b.path=a,b.x=d*h,b.y=f*h,b.scaleX=m,b.scaleY=l,b.rotation=o,b.width=g*h,b.height=p*h,Ft.rgba8888ToColor(b.color,y),b.sequence=w,w==null&&b.updateRegion(),b):null}case Ee.BoundingBox:{const a=t.readInt(!0),o=this.readVertices(t,a),d=c?t.readInt32():0,f=this.attachmentLoader.newBoundingBoxAttachment(s,i);return f?(f.worldVerticesLength=a<<1,f.vertices=o.vertices,f.bones=o.bones,c&&Ft.rgba8888ToColor(f.color,d),f):null}case Ee.Mesh:{let a=t.readStringRef();const o=t.readInt32(),d=t.readInt(!0),f=this.readFloatArray(t,d<<1,1),m=this.readShortArray(t),l=this.readVertices(t,d),g=t.readInt(!0),p=this.readSequence(t);let y=[],w=0,b=0;c&&(y=this.readShortArray(t),w=t.readFloat(),b=t.readFloat()),a||(a=i);const x=this.attachmentLoader.newMeshAttachment(s,i,a,p);return x?(x.path=a,Ft.rgba8888ToColor(x.color,o),x.bones=l.bones,x.vertices=l.vertices,x.worldVerticesLength=d<<1,x.triangles=m,x.regionUVs=new Float32Array(f),x.hullLength=g<<1,x.sequence=p,c&&(x.edges=y,x.width=w*h,x.height=b*h),x):null}case Ee.LinkedMesh:{let a=t.readStringRef();const o=t.readInt32(),d=t.readStringRef(),f=t.readStringRef(),m=t.readBoolean(),l=this.readSequence(t);let g=0,p=0;c&&(g=t.readFloat(),p=t.readFloat()),a||(a=i);const y=this.attachmentLoader.newMeshAttachment(s,i,a,l);return y?(y.path=a,Ft.rgba8888ToColor(y.color,o),y.sequence=l,c&&(y.width=g*h,y.height=p*h),this.linkedMeshes.push(new Cv(y,d,n,f,m)),y):null}case Ee.Path:{const a=t.readBoolean(),o=t.readBoolean(),d=t.readInt(!0),f=this.readVertices(t,d),m=dt.newArray(d/3,0);for(let p=0,y=m.length;p<y;p++)m[p]=t.readFloat()*h;const l=c?t.readInt32():0,g=this.attachmentLoader.newPathAttachment(s,i);return g?(g.closed=a,g.constantSpeed=o,g.worldVerticesLength=d<<1,g.vertices=f.vertices,g.bones=f.bones,g.lengths=m,c&&Ft.rgba8888ToColor(g.color,l),g):null}case Ee.Point:{const a=t.readFloat(),o=t.readFloat(),d=t.readFloat(),f=c?t.readInt32():0,m=this.attachmentLoader.newPointAttachment(s,i);return m?(m.x=o*h,m.y=d*h,m.rotation=a,c&&Ft.rgba8888ToColor(m.color,f),m):null}case Ee.Clipping:{const a=t.readInt(!0),o=t.readInt(!0),d=this.readVertices(t,o),f=c?t.readInt32():0,m=this.attachmentLoader.newClippingAttachment(s,i);return m?(m.endSlot=e.slots[a],m.worldVerticesLength=o<<1,m.vertices=d.vertices,m.bones=d.bones,c&&Ft.rgba8888ToColor(m.color,f),m):null}}return null}readSequence(t){if(this.ver40||!t.readBoolean())return null;const e=new ng(t.readInt(!0));return e.start=t.readInt(!0),e.digits=t.readInt(!0),e.setupIndex=t.readInt(!0),e}readDeformTimelineType(t){return this.ver40?Og:t.readByte()}readVertices(t,e){const s=this.scale,n=e<<1,r=new Av;if(!t.readBoolean())return r.vertices=this.readFloatArray(t,n,s),r;const c=new Array,h=new Array;for(let i=0;i<e;i++){const a=t.readInt(!0);h.push(a);for(let o=0;o<a;o++)h.push(t.readInt(!0)),c.push(t.readFloat()*s),c.push(t.readFloat()*s),c.push(t.readFloat())}return r.vertices=dt.toFloatArray(c),r.bones=h,r}readFloatArray(t,e,s){const n=new Array(e);if(s==1)for(let r=0;r<e;r++)n[r]=t.readFloat();else for(let r=0;r<e;r++)n[r]=t.readFloat()*s;return n}readShortArray(t){const e=t.readInt(!0),s=new Array(e);for(let n=0;n<e;n++)s[n]=t.readShort();return s}readAnimation(t,e,s){t.readInt(!0);const n=new Array,r=this.scale;for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0);for(let f=0,m=t.readInt(!0);f<m;f++){const l=t.readByte(),g=t.readInt(!0),p=g-1;switch(l){case $v:{const y=new $a(g,d);for(let w=0;w<g;w++)y.setFrame(w,t.readFloat(),t.readStringRef());n.push(y);break}case _v:{const y=t.readInt(!0),w=new mg(g,y,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255;for(let v=0,M=0;w.setFrame(v,b,x,S,C,A),v!=p;v++){const E=t.readFloat(),T=t.readUnsignedByte()/255,R=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255;switch(t.readByte()){case qn:w.setStepped(v);break;case Gn:_t(t,w,M++,v,0,b,E,x,T,1),_t(t,w,M++,v,1,b,E,S,R,1),_t(t,w,M++,v,2,b,E,C,k,1),_t(t,w,M++,v,3,b,E,A,I,1)}b=E,x=T,S=R,C=k,A=I}n.push(w);break}case Xv:{const y=t.readInt(!0),w=new gg(g,y,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255;for(let A=0,v=0;w.setFrame(A,b,x,S,C),A!=p;A++){const M=t.readFloat(),E=t.readUnsignedByte()/255,T=t.readUnsignedByte()/255,R=t.readUnsignedByte()/255;switch(t.readByte()){case qn:w.setStepped(A);break;case Gn:_t(t,w,v++,A,0,b,M,x,E,1),_t(t,w,v++,A,1,b,M,S,T,1),_t(t,w,v++,A,2,b,M,C,R,1)}b=M,x=E,S=T,C=R}n.push(w);break}case Bv:{const y=t.readInt(!0),w=new bg(g,y,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255,E=t.readUnsignedByte()/255;for(let T=0,R=0;w.setFrame(T,b,x,S,C,A,v,M,E),T!=p;T++){const k=t.readFloat(),I=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,W=t.readUnsignedByte()/255,Y=t.readUnsignedByte()/255,_=t.readUnsignedByte()/255;switch(t.readByte()){case qn:w.setStepped(T);break;case Gn:_t(t,w,R++,T,0,b,k,x,I,1),_t(t,w,R++,T,1,b,k,S,P,1),_t(t,w,R++,T,2,b,k,C,F,1),_t(t,w,R++,T,3,b,k,A,X,1),_t(t,w,R++,T,4,b,k,v,W,1),_t(t,w,R++,T,5,b,k,M,Y,1),_t(t,w,R++,T,6,b,k,E,_,1)}b=k,x=I,S=P,C=F,A=X,v=W,M=Y,E=_}n.push(w);break}case Vv:{const y=t.readInt(!0),w=new xg(g,y,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255;for(let E=0,T=0;w.setFrame(E,b,x,S,C,A,v,M),E!=p;E++){const R=t.readFloat(),k=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,W=t.readUnsignedByte()/255;switch(t.readByte()){case qn:w.setStepped(E);break;case Gn:_t(t,w,T++,E,0,b,R,x,k,1),_t(t,w,T++,E,1,b,R,S,I,1),_t(t,w,T++,E,2,b,R,C,P,1),_t(t,w,T++,E,3,b,R,A,F,1),_t(t,w,T++,E,4,b,R,v,X,1),_t(t,w,T++,E,5,b,R,M,W,1)}b=R,x=k,S=I,C=P,A=F,v=X,M=W}n.push(w);break}case Nv:{const y=new pg(g,t.readInt(!0),d);let w=t.readFloat(),b=t.readUnsignedByte()/255;for(let x=0,S=0;y.setFrame(x,w,b),x!=p;x++){const C=t.readFloat(),A=t.readUnsignedByte()/255;switch(t.readByte()){case qn:y.setStepped(x);break;case Gn:_t(t,y,S++,x,0,w,C,b,A,1)}w=C,b=A}n.push(y)}}}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0);for(let f=0,m=t.readInt(!0);f<m;f++){const l=t.readByte(),g=t.readInt(!0),p=t.readInt(!0);switch(l){case vv:n.push(Nr(t,new Il(g,p,d),1));break;case Mv:n.push(Pd(t,new ig(g,p,d),r));break;case Ev:n.push(Nr(t,new ag(g,p,d),r));break;case Tv:n.push(Nr(t,new og(g,p,d),r));break;case Iv:n.push(Pd(t,new lg(g,p,d),1));break;case Rv:n.push(Nr(t,new cg(g,p,d),1));break;case Pv:n.push(Nr(t,new hg(g,p,d),1));break;case kv:n.push(Pd(t,new dg(g,p,d),1));break;case Fv:n.push(Nr(t,new ug(g,p,d),1));break;case Yv:n.push(Nr(t,new fg(g,p,d),1))}}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),f=t.readInt(!0),m=f-1,l=new Cg(f,t.readInt(!0),d);let g=t.readFloat(),p=t.readFloat(),y=t.readFloat()*r;for(let w=0,b=0;l.setFrame(w,g,p,y,t.readByte(),t.readBoolean(),t.readBoolean()),w!=m;w++){const x=t.readFloat(),S=t.readFloat(),C=t.readFloat()*r;switch(t.readByte()){case qn:l.setStepped(w);break;case Gn:_t(t,l,b++,w,0,g,x,p,S,1),_t(t,l,b++,w,1,g,x,y,C,r)}g=x,p=S,y=C}n.push(l)}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),f=t.readInt(!0),m=f-1,l=new Ag(f,t.readInt(!0),d);let g=t.readFloat(),p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),b=t.readFloat(),x=t.readFloat(),S=t.readFloat();for(let C=0,A=0;l.setFrame(C,g,p,y,w,b,x,S),C!=m;C++){const v=t.readFloat(),M=t.readFloat(),E=t.readFloat(),T=t.readFloat(),R=t.readFloat(),k=t.readFloat(),I=t.readFloat();switch(t.readByte()){case qn:l.setStepped(C);break;case Gn:_t(t,l,A++,C,0,g,v,p,M,1),_t(t,l,A++,C,1,g,v,y,E,1),_t(t,l,A++,C,2,g,v,w,T,1),_t(t,l,A++,C,3,g,v,b,R,1),_t(t,l,A++,C,4,g,v,x,k,1),_t(t,l,A++,C,5,g,v,S,I,1)}g=v,p=M,y=E,w=T,b=R,x=k,S=I}n.push(l)}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),f=s.pathConstraints[d];for(let m=0,l=t.readInt(!0);m<l;m++)switch(t.readByte()){case Lv:n.push(Nr(t,new vg(t.readInt(!0),t.readInt(!0),d),f.positionMode==Br.Fixed?r:1));break;case Ov:n.push(Nr(t,new Mg(t.readInt(!0),t.readInt(!0),d),f.spacingMode==ps.Length||f.spacingMode==ps.Fixed?r:1));break;case Wv:const g=new Eg(t.readInt(!0),t.readInt(!0),d);let p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),b=t.readFloat();for(let x=0,S=0,C=g.getFrameCount()-1;g.setFrame(x,p,y,w,b),x!=C;x++){const A=t.readFloat(),v=t.readFloat(),M=t.readFloat(),E=t.readFloat();switch(t.readByte()){case qn:g.setStepped(x);break;case Gn:_t(t,g,S++,x,0,p,A,y,v,1),_t(t,g,S++,x,1,p,A,w,M,1),_t(t,g,S++,x,2,p,A,b,E,1)}p=A,y=v,w=M,b=E}n.push(g)}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=s.skins[t.readInt(!0)];for(let f=0,m=t.readInt(!0);f<m;f++){const l=t.readInt(!0);for(let g=0,p=t.readInt(!0);g<p;g++){const y=t.readStringRef();if(!y)throw new Error("attachmentName must not be null.");const w=d.getAttachment(l,y),b=this.readDeformTimelineType(t),x=t.readInt(!0),S=x-1;switch(b){case Og:{const C=w,A=C.bones,v=C.vertices,M=A?v.length/3*2:v.length,E=t.readInt(!0),T=new wg(x,E,l,C);let R=t.readFloat();for(let k=0,I=0;;k++){let P,F=t.readInt(!0);if(F==0)P=A?dt.newFloatArray(M):v;else{P=dt.newFloatArray(M);const W=t.readInt(!0);if(F+=W,r==1)for(let Y=W;Y<F;Y++)P[Y]=t.readFloat();else for(let Y=W;Y<F;Y++)P[Y]=t.readFloat()*r;if(!A)for(let Y=0,_=P.length;Y<_;Y++)P[Y]+=v[Y]}if(T.setFrame(k,R,P),k==S)break;const X=t.readFloat();switch(t.readByte()){case qn:T.setStepped(k);break;case Gn:_t(t,T,I++,k,0,R,X,0,1,1)}R=X}n.push(T);break}case Dv:{const C=new Tg(x,l,w);for(let A=0;A<x;A++){const v=t.readFloat(),M=t.readInt32();C.setFrame(A,v,rg[M&15],M>>4,t.readFloat())}n.push(C);break}}}}}const c=t.readInt(!0);if(c>0){const a=new _o(c),o=s.slots.length;for(let d=0;d<c;d++){const f=t.readFloat(),m=t.readInt(!0),l=dt.newArray(o,0);for(let w=o-1;w>=0;w--)l[w]=-1;const g=dt.newArray(o-m,0);let p=0,y=0;for(let w=0;w<m;w++){const b=t.readInt(!0);for(;p!=b;)g[y++]=p++;l[p+t.readInt(!0)]=p++}for(;p<o;)g[y++]=p++;for(let w=o-1;w>=0;w--)l[w]==-1&&(l[w]=g[--y]);a.setFrame(d,f,l)}n.push(a)}const h=t.readInt(!0);if(h>0){const a=new Ad(h);for(let o=0;o<h;o++){const d=t.readFloat(),f=s.events[t.readInt(!0)],m=new Yg(d,f);m.intValue=t.readInt(!1),m.floatValue=t.readFloat(),m.stringValue=t.readBoolean()?t.readString():f.stringValue,m.data.audioPath&&(m.volume=t.readFloat(),m.balance=t.readFloat()),a.setFrame(o,m)}n.push(a)}let i=0;for(let a=0,o=n.length;a<o;a++)i=Math.max(i,n[a].getDuration());return new Sd(e,n,i)}}pr(Sv,"BlendModeValues",[G.BLEND_MODES.NORMAL,G.BLEND_MODES.ADD,G.BLEND_MODES.MULTIPLY,G.BLEND_MODES.SCREEN]);let Cv=class{constructor(t,e,s,n,r){pr(this,"parent"),pr(this,"skin"),pr(this,"slotIndex"),pr(this,"mesh"),pr(this,"inheritTimeline"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritTimeline=r}};class Av{constructor(t=null,e=null){this.bones=t,this.vertices=e}}function Nr(u,t,e){let s=u.readFloat(),n=u.readFloat()*e;for(let r=0,c=0,h=t.getFrameCount()-1;t.setFrame(r,s,n),r!=h;r++){const i=u.readFloat(),a=u.readFloat()*e;switch(u.readByte()){case qn:t.setStepped(r);break;case Gn:_t(u,t,c++,r,0,s,i,n,a,e)}s=i,n=a}return t}function Pd(u,t,e){let s=u.readFloat(),n=u.readFloat()*e,r=u.readFloat()*e;for(let c=0,h=0,i=t.getFrameCount()-1;t.setFrame(c,s,n,r),c!=i;c++){const a=u.readFloat(),o=u.readFloat()*e,d=u.readFloat()*e;switch(u.readByte()){case qn:t.setStepped(c);break;case Gn:_t(u,t,h++,c,0,s,a,n,o,e),_t(u,t,h++,c,1,s,a,r,d,e)}s=a,n=o,r=d}return t}function _t(u,t,e,s,n,r,c,h,i,a){t.setBezier(e,s,n,r,h,u.readFloat(),u.readFloat()*a,u.readFloat(),u.readFloat()*a,c,i)}const vv=0,Mv=1,Ev=2,Tv=3,Iv=4,Rv=5,Pv=6,kv=7,Fv=8,Yv=9,$v=0,_v=1,Xv=2,Bv=3,Vv=4,Nv=5,Og=0,Dv=1,Lv=0,Ov=1,Wv=2,qn=1,Gn=2;var Uv=Object.defineProperty,qv=(u,t,e)=>t in u?Uv(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,wa=(u,t,e)=>qv(u,typeof t!="symbol"?t+"":t,e);class Gv{constructor(){wa(this,"minX",0),wa(this,"minY",0),wa(this,"maxX",0),wa(this,"maxY",0),wa(this,"boundingBoxes",new Array),wa(this,"polygons",new Array),wa(this,"polygonPool",new Gm(()=>dt.newFloatArray(16)))}update(t,e){if(!t)throw new Error("skeleton cannot be null.");const s=this.boundingBoxes,n=this.polygons,r=this.polygonPool,c=t.slots,h=c.length;s.length=0,r.freeAll(n),n.length=0;for(let i=0;i<h;i++){const a=c[i];if(!a.bone.active)continue;const o=a.getAttachment();if(o!=null&&o.type===Ee.BoundingBox){const d=o;s.push(d);let f=r.obtain();f.length!=d.worldVerticesLength&&(f=dt.newFloatArray(d.worldVerticesLength)),n.push(f),d.computeWorldVertices(a,0,d.worldVerticesLength,f,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY;const r=this.polygons;for(let c=0,h=r.length;c<h;c++){const i=r[c],a=i;for(let o=0,d=i.length;o<d;o+=2){const f=a[o],m=a[o+1];t=Math.min(t,f),e=Math.min(e,m),s=Math.max(s,f),n=Math.max(n,m)}}this.minX=t,this.minY=e,this.maxX=s,this.maxY=n}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,s,n){const r=this.minX,c=this.minY,h=this.maxX,i=this.maxY;if(t<=r&&s<=r||e<=c&&n<=c||t>=h&&s>=h||e>=i&&n>=i)return!1;const a=(n-e)/(s-t);let o=a*(r-t)+e;if(o>c&&o<i||(o=a*(h-t)+e,o>c&&o<i))return!0;let d=(c-e)/a+t;return d>r&&d<h||(d=(i-e)/a+t,d>r&&d<h)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){const s=this.polygons;for(let n=0,r=s.length;n<r;n++)if(this.containsPointPolygon(s[n],t,e))return this.boundingBoxes[n];return null}containsPointPolygon(t,e,s){const n=t,r=t.length;let c=r-2,h=!1;for(let i=0;i<r;i+=2){const a=n[i+1],o=n[c+1];if(a<s&&o>=s||o<s&&a>=s){const d=n[i];d+(s-a)/(o-a)*(n[c]-d)<e&&(h=!h)}c=i}return h}intersectsSegment(t,e,s,n){const r=this.polygons;for(let c=0,h=r.length;c<h;c++)if(this.intersectsSegmentPolygon(r[c],t,e,s,n))return this.boundingBoxes[c];return null}intersectsSegmentPolygon(t,e,s,n,r){const c=t,h=t.length,i=e-n,a=s-r,o=e*r-s*n;let d=c[h-2],f=c[h-1];for(let m=0;m<h;m+=2){const l=c[m],g=c[m+1],p=d*g-f*l,y=d-l,w=f-g,b=i*w-a*y,x=(o*y-i*p)/b;if((x>=d&&x<=l||x>=l&&x<=d)&&(x>=e&&x<=n||x>=n&&x<=e)){const S=(o*w-a*p)/b;if((S>=f&&S<=g||S>=g&&S<=f)&&(S>=s&&S<=r||S>=r&&S<=s))return!0}d=l,f=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const e=this.boundingBoxes.indexOf(t);return e==-1?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}}class zv extends Gv{}var Hv=Object.defineProperty,Kv=(u,t,e)=>t in u?Hv(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,Ai=(u,t,e)=>Kv(u,typeof t!="symbol"?t+"":t,e);class Wg{constructor(t){Ai(this,"attachmentLoader"),Ai(this,"scale",1),Ai(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new Vg,n=typeof t=="string"?JSON.parse(t):t,r=n.skeleton;if(r){s.hash=r.hash,s.version=r.spine;const c=s.version.substr(0,3);if(c!=="4.0"&&c!=="4.1"){const h=`Spine 4.1 loader cant load version ${r.spine}. Please configure your pixi-spine bundle`;console.error(h)}s.x=r.x,s.y=r.y,s.width=r.width,s.height=r.height,s.fps=r.fps,s.imagesPath=r.images}if(n.bones)for(let c=0;c<n.bones.length;c++){const h=n.bones[c];let i=null;const a=L(h,"parent",null);if(a!=null&&(i=s.findBone(a),i==null))throw new Error(`Parent bone not found: ${a}`);const o=new Fg(s.bones.length,h.name,i);o.length=L(h,"length",0)*e,o.x=L(h,"x",0)*e,o.y=L(h,"y",0)*e,o.rotation=L(h,"rotation",0),o.scaleX=L(h,"scaleX",1),o.scaleY=L(h,"scaleY",1),o.shearX=L(h,"shearX",0),o.shearY=L(h,"shearY",0),o.transformMode=dt.enumValue(dn,L(h,"transform","Normal")),o.skinRequired=L(h,"skin",!1);const d=L(h,"color",null);d&&o.color.setFromString(d),s.bones.push(o)}if(n.slots)for(let c=0;c<n.slots.length;c++){const h=n.slots[c],i=s.findBone(h.bone);if(!i)throw new Error(`Couldn't find bone ${h.bone} for slot ${h.name}`);const a=new Ng(s.slots.length,h.name,i),o=L(h,"color",null);o&&a.color.setFromString(o);const d=L(h,"dark",null);d&&(a.darkColor=Ft.fromString(d)),a.attachmentName=L(h,"attachment",null),a.blendMode=Wg.blendModeFromString(L(h,"blend","normal")),s.slots.push(a)}if(n.ik)for(let c=0;c<n.ik.length;c++){const h=n.ik[c],i=new _g(h.name);i.order=L(h,"order",0),i.skinRequired=L(h,"skin",!1);for(let a=0;a<h.bones.length;a++){const o=h.bones[a],d=s.findBone(o);if(d==null)throw new Error(`IK bone not found: ${o}`);i.bones.push(d)}i.target=s.findBone(h.target),i.mix=L(h,"mix",1),i.softness=L(h,"softness",0)*e,i.bendDirection=L(h,"bendPositive",!0)?1:-1,i.compress=L(h,"compress",!1),i.stretch=L(h,"stretch",!1),i.uniform=L(h,"uniform",!1),s.ikConstraints.push(i)}if(n.transform)for(let c=0;c<n.transform.length;c++){const h=n.transform[c],i=new Dg(h.name);i.order=L(h,"order",0),i.skinRequired=L(h,"skin",!1);for(let d=0;d<h.bones.length;d++){const f=h.bones[d],m=s.findBone(f);if(!m)throw new Error(`Couldn't find bone ${f} for transform constraint ${h.name}.`);i.bones.push(m)}const a=h.target,o=s.findBone(a);if(!o)throw new Error(`Couldn't find target bone ${a} for transform constraint ${h.name}.`);i.target=o,i.local=L(h,"local",!1),i.relative=L(h,"relative",!1),i.offsetRotation=L(h,"rotation",0),i.offsetX=L(h,"x",0)*e,i.offsetY=L(h,"y",0)*e,i.offsetScaleX=L(h,"scaleX",0),i.offsetScaleY=L(h,"scaleY",0),i.offsetShearY=L(h,"shearY",0),i.mixRotate=L(h,"mixRotate",1),i.mixX=L(h,"mixX",1),i.mixY=L(h,"mixY",i.mixX),i.mixScaleX=L(h,"mixScaleX",1),i.mixScaleY=L(h,"mixScaleY",i.mixScaleX),i.mixShearY=L(h,"mixShearY",1),s.transformConstraints.push(i)}if(n.path)for(let c=0;c<n.path.length;c++){const h=n.path[c],i=new Xg(h.name);i.order=L(h,"order",0),i.skinRequired=L(h,"skin",!1);for(let d=0;d<h.bones.length;d++){const f=h.bones[d],m=s.findBone(f);if(!m)throw new Error(`Couldn't find bone ${f} for path constraint ${h.name}.`);i.bones.push(m)}const a=h.target,o=s.findSlot(a);if(!o)throw new Error(`Couldn't find target slot ${a} for path constraint ${h.name}.`);i.target=o,i.positionMode=dt.enumValue(Br,L(h,"positionMode","Percent")),i.spacingMode=dt.enumValue(ps,L(h,"spacingMode","Length")),i.rotateMode=dt.enumValue(_a,L(h,"rotateMode","Tangent")),i.offsetRotation=L(h,"rotation",0),i.position=L(h,"position",0),i.positionMode==Br.Fixed&&(i.position*=e),i.spacing=L(h,"spacing",0),(i.spacingMode==ps.Length||i.spacingMode==ps.Fixed)&&(i.spacing*=e),i.mixRotate=L(h,"mixRotate",1),i.mixX=L(h,"mixX",1),i.mixY=L(h,"mixY",i.mixX),s.pathConstraints.push(i)}if(n.skins)for(let c=0;c<n.skins.length;c++){const h=n.skins[c],i=new Rd(h.name);if(h.bones)for(let a=0;a<h.bones.length;a++){const o=h.bones[a],d=s.findBone(o);if(!d)throw new Error(`Couldn't find bone ${o} for skin ${h.name}.`);i.bones.push(d)}if(h.ik)for(let a=0;a<h.ik.length;a++){const o=h.ik[a],d=s.findIkConstraint(o);if(!d)throw new Error(`Couldn't find IK constraint ${o} for skin ${h.name}.`);i.constraints.push(d)}if(h.transform)for(let a=0;a<h.transform.length;a++){const o=h.transform[a],d=s.findTransformConstraint(o);if(!d)throw new Error(`Couldn't find transform constraint ${o} for skin ${h.name}.`);i.constraints.push(d)}if(h.path)for(let a=0;a<h.path.length;a++){const o=h.path[a],d=s.findPathConstraint(o);if(!d)throw new Error(`Couldn't find path constraint ${o} for skin ${h.name}.`);i.constraints.push(d)}for(const a in h.attachments){const o=s.findSlot(a);if(!o)throw new Error(`Couldn't find slot ${a} for skin ${h.name}.`);const d=h.attachments[a];for(const f in d){const m=this.readAttachment(d[f],i,o.index,f,s);m&&i.setAttachment(o.index,f,m)}}s.skins.push(i),i.name=="default"&&(s.defaultSkin=i)}for(let c=0,h=this.linkedMeshes.length;c<h;c++){const i=this.linkedMeshes[c],a=i.skin?s.findSkin(i.skin):s.defaultSkin;if(!a)throw new Error(`Skin not found: ${i.skin}`);const o=a.getAttachment(i.slotIndex,i.parent);if(!o)throw new Error(`Parent mesh not found: ${i.parent}`);i.mesh.timelineAttachment=i.inheritTimeline?o:i.mesh,i.mesh.setParentMesh(o)}if(this.linkedMeshes.length=0,n.events)for(const c in n.events){const h=n.events[c],i=new $g(c);i.intValue=L(h,"int",0),i.floatValue=L(h,"float",0),i.stringValue=L(h,"string",""),i.audioPath=L(h,"audio",null),i.audioPath&&(i.volume=L(h,"volume",1),i.balance=L(h,"balance",0)),s.events.push(i)}if(n.animations)for(const c in n.animations){const h=n.animations[c];this.readAnimation(h,c,s)}return s}readAttachment(t,e,s,n,r){const c=this.scale;switch(n=L(t,"name",n),L(t,"type","region")){case"region":{const h=L(t,"path",n),i=this.readSequence(L(t,"sequence",null)),a=this.attachmentLoader.newRegionAttachment(e,n,h,i);if(!a)return null;a.path=h,a.x=L(t,"x",0)*c,a.y=L(t,"y",0)*c,a.scaleX=L(t,"scaleX",1),a.scaleY=L(t,"scaleY",1),a.rotation=L(t,"rotation",0),a.width=t.width*c,a.height=t.height*c,a.sequence=i;const o=L(t,"color",null);return o&&a.color.setFromString(o),a}case"boundingbox":{const h=this.attachmentLoader.newBoundingBoxAttachment(e,n);if(!h)return null;this.readVertices(t,h,t.vertexCount<<1);const i=L(t,"color",null);return i&&h.color.setFromString(i),h}case"mesh":case"linkedmesh":{const h=L(t,"path",n),i=this.readSequence(L(t,"sequence",null)),a=this.attachmentLoader.newMeshAttachment(e,n,h,i);if(!a)return null;a.path=h;const o=L(t,"color",null);o&&a.color.setFromString(o),a.width=L(t,"width",0)*c,a.height=L(t,"height",0)*c,a.sequence=i;const d=L(t,"parent",null);if(d)return this.linkedMeshes.push(new Zv(a,L(t,"skin",null),s,d,L(t,"timelines",!0))),a;const f=t.uvs;return this.readVertices(t,a,f.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(f),a.edges=L(t,"edges",null),a.hullLength=L(t,"hull",0)*2,a}case"path":{const h=this.attachmentLoader.newPathAttachment(e,n);if(!h)return null;h.closed=L(t,"closed",!1),h.constantSpeed=L(t,"constantSpeed",!0);const i=t.vertexCount;this.readVertices(t,h,i<<1);const a=dt.newArray(i/3,0);for(let d=0;d<t.lengths.length;d++)a[d]=t.lengths[d]*c;h.lengths=a;const o=L(t,"color",null);return o&&h.color.setFromString(o),h}case"point":{const h=this.attachmentLoader.newPointAttachment(e,n);if(!h)return null;h.x=L(t,"x",0)*c,h.y=L(t,"y",0)*c,h.rotation=L(t,"rotation",0);const i=L(t,"color",null);return i&&h.color.setFromString(i),h}case"clipping":{const h=this.attachmentLoader.newClippingAttachment(e,n);if(!h)return null;const i=L(t,"end",null);if(i!=null){const d=r.findSlot(i);if(d==null)throw new Error(`Clipping end slot not found: ${i}`);h.endSlot=d}const a=t.vertexCount;this.readVertices(t,h,a<<1);const o=L(t,"color",null);return o&&h.color.setFromString(o),h}}return null}readSequence(t){if(t==null)return null;const e=new ng(L(t,"count",0));return e.start=L(t,"start",1),e.digits=L(t,"digits",0),e.setupIndex=L(t,"setup",0),e}readVertices(t,e,s){const n=this.scale;e.worldVerticesLength=s;const r=t.vertices;if(s==r.length){const i=dt.toFloatArray(r);if(n!=1)for(let a=0,o=r.length;a<o;a++)i[a]*=n;e.vertices=i;return}const c=new Array,h=new Array;for(let i=0,a=r.length;i<a;){const o=r[i++];h.push(o);for(let d=i+o*4;i<d;i+=4)h.push(r[i]),c.push(r[i+1]*n),c.push(r[i+2]*n),c.push(r[i+3])}e.bones=h,e.vertices=dt.toFloatArray(c)}readAnimation(t,e,s){const n=this.scale,r=new Array;if(t.slots)for(const h in t.slots){const i=t.slots[h],a=s.findSlot(h);if(!a)throw new Error(`Slot not found: ${h}`);const o=a.index;for(const d in i){const f=i[d];if(!f)continue;const m=f.length;if(d=="attachment"){const l=new $a(m,o);for(let g=0;g<m;g++){const p=f[g];l.setFrame(g,L(p,"time",0),L(p,"name",null))}r.push(l)}else if(d=="rgba"){const l=new mg(m,m<<2,o);let g=f[0],p=L(g,"time",0),y=Ft.fromString(g.color);for(let w=0,b=0;;w++){l.setFrame(w,p,y.r,y.g,y.b,y.a);const x=f[w+1];if(!x){l.shrink(b);break}const S=L(x,"time",0),C=Ft.fromString(x.color),A=g.curve;A&&(b=Vt(A,l,b,w,0,p,S,y.r,C.r,1),b=Vt(A,l,b,w,1,p,S,y.g,C.g,1),b=Vt(A,l,b,w,2,p,S,y.b,C.b,1),b=Vt(A,l,b,w,3,p,S,y.a,C.a,1)),p=S,y=C,g=x}r.push(l)}else if(d=="rgb"){const l=new gg(m,m*3,o);let g=f[0],p=L(g,"time",0),y=Ft.fromString(g.color);for(let w=0,b=0;;w++){l.setFrame(w,p,y.r,y.g,y.b);const x=f[w+1];if(!x){l.shrink(b);break}const S=L(x,"time",0),C=Ft.fromString(x.color),A=g.curve;A&&(b=Vt(A,l,b,w,0,p,S,y.r,C.r,1),b=Vt(A,l,b,w,1,p,S,y.g,C.g,1),b=Vt(A,l,b,w,2,p,S,y.b,C.b,1)),p=S,y=C,g=x}r.push(l)}else if(d=="alpha")r.push(br(f,new pg(m,m,o),0,1));else if(d=="rgba2"){const l=new bg(m,m*7,o);let g=f[0],p=L(g,"time",0),y=Ft.fromString(g.light),w=Ft.fromString(g.dark);for(let b=0,x=0;;b++){l.setFrame(b,p,y.r,y.g,y.b,y.a,w.r,w.g,w.b);const S=f[b+1];if(!S){l.shrink(x);break}const C=L(S,"time",0),A=Ft.fromString(S.light),v=Ft.fromString(S.dark),M=g.curve;M&&(x=Vt(M,l,x,b,0,p,C,y.r,A.r,1),x=Vt(M,l,x,b,1,p,C,y.g,A.g,1),x=Vt(M,l,x,b,2,p,C,y.b,A.b,1),x=Vt(M,l,x,b,3,p,C,y.a,A.a,1),x=Vt(M,l,x,b,4,p,C,w.r,v.r,1),x=Vt(M,l,x,b,5,p,C,w.g,v.g,1),x=Vt(M,l,x,b,6,p,C,w.b,v.b,1)),p=C,y=A,w=v,g=S}r.push(l)}else if(d=="rgb2"){const l=new xg(m,m*6,o);let g=f[0],p=L(g,"time",0),y=Ft.fromString(g.light),w=Ft.fromString(g.dark);for(let b=0,x=0;;b++){l.setFrame(b,p,y.r,y.g,y.b,w.r,w.g,w.b);const S=f[b+1];if(!S){l.shrink(x);break}const C=L(S,"time",0),A=Ft.fromString(S.light),v=Ft.fromString(S.dark),M=g.curve;M&&(x=Vt(M,l,x,b,0,p,C,y.r,A.r,1),x=Vt(M,l,x,b,1,p,C,y.g,A.g,1),x=Vt(M,l,x,b,2,p,C,y.b,A.b,1),x=Vt(M,l,x,b,3,p,C,w.r,v.r,1),x=Vt(M,l,x,b,4,p,C,w.g,v.g,1),x=Vt(M,l,x,b,5,p,C,w.b,v.b,1)),p=C,y=A,w=v,g=S}r.push(l)}}}if(t.bones)for(const h in t.bones){const i=t.bones[h],a=s.findBone(h);if(!a)throw new Error(`Bone not found: ${h}`);const o=a.index;for(const d in i){const f=i[d],m=f.length;if(m!=0){if(d==="rotate")r.push(br(f,new Il(m,m,o),0,1));else if(d==="translate"){const l=new ig(m,m<<1,o);r.push(kd(f,l,"x","y",0,n))}else if(d==="translatex"){const l=new ag(m,m,o);r.push(br(f,l,0,n))}else if(d==="translatey"){const l=new og(m,m,o);r.push(br(f,l,0,n))}else if(d==="scale"){const l=new lg(m,m<<1,o);r.push(kd(f,l,"x","y",1,1))}else if(d==="scalex"){const l=new cg(m,m,o);r.push(br(f,l,1,1))}else if(d==="scaley"){const l=new hg(m,m,o);r.push(br(f,l,1,1))}else if(d==="shear"){const l=new dg(m,m<<1,o);r.push(kd(f,l,"x","y",0,1))}else if(d==="shearx"){const l=new ug(m,m,o);r.push(br(f,l,0,1))}else if(d==="sheary"){const l=new fg(m,m,o);r.push(br(f,l,0,1))}}}}if(t.ik)for(const h in t.ik){const i=t.ik[h];let a=i[0];if(!a)continue;const o=s.findIkConstraint(h);if(!o)throw new Error(`IK Constraint not found: ${h}`);const d=s.ikConstraints.indexOf(o),f=new Cg(i.length,i.length<<1,d);let m=L(a,"time",0),l=L(a,"mix",1),g=L(a,"softness",0)*n;for(let p=0,y=0;;p++){f.setFrame(p,m,l,g,L(a,"bendPositive",!0)?1:-1,L(a,"compress",!1),L(a,"stretch",!1));const w=i[p+1];if(!w){f.shrink(y);break}const b=L(w,"time",0),x=L(w,"mix",1),S=L(w,"softness",0)*n,C=a.curve;C&&(y=Vt(C,f,y,p,0,m,b,l,x,1),y=Vt(C,f,y,p,1,m,b,g,S,n)),m=b,l=x,g=S,a=w}r.push(f)}if(t.transform)for(const h in t.transform){const i=t.transform[h];let a=i[0];if(!a)continue;const o=s.findTransformConstraint(h);if(!o)throw new Error(`Transform constraint not found: ${h}`);const d=s.transformConstraints.indexOf(o),f=new Ag(i.length,i.length*6,d);let m=L(a,"time",0),l=L(a,"mixRotate",1),g=L(a,"mixX",1),p=L(a,"mixY",g),y=L(a,"mixScaleX",1),w=L(a,"mixScaleY",y);const b=L(a,"mixShearY",1);for(let x=0,S=0;;x++){f.setFrame(x,m,l,g,p,y,w,b);const C=i[x+1];if(!C){f.shrink(S);break}const A=L(C,"time",0),v=L(C,"mixRotate",1),M=L(C,"mixX",1),E=L(C,"mixY",M),T=L(C,"mixScaleX",1),R=L(C,"mixScaleY",T),k=L(C,"mixShearY",1),I=a.curve;I&&(S=Vt(I,f,S,x,0,m,A,l,v,1),S=Vt(I,f,S,x,1,m,A,g,M,1),S=Vt(I,f,S,x,2,m,A,p,E,1),S=Vt(I,f,S,x,3,m,A,y,T,1),S=Vt(I,f,S,x,4,m,A,w,R,1),S=Vt(I,f,S,x,5,m,A,b,k,1)),m=A,l=v,g=M,p=E,y=T,w=R,y=T,a=C}r.push(f)}if(t.path)for(const h in t.path){const i=t.path[h],a=s.findPathConstraint(h);if(!a)throw new Error(`Path constraint not found: ${h}`);const o=s.pathConstraints.indexOf(a);for(const d in i){const f=i[d];let m=f[0];if(!m)continue;const l=f.length;if(d==="position"){const g=new vg(l,l,o);r.push(br(f,g,0,a.positionMode==Br.Fixed?n:1))}else if(d==="spacing"){const g=new Mg(l,l,o);r.push(br(f,g,0,a.spacingMode==ps.Length||a.spacingMode==ps.Fixed?n:1))}else if(d==="mix"){const g=new Eg(l,l*3,o);let p=L(m,"time",0),y=L(m,"mixRotate",1),w=L(m,"mixX",1),b=L(m,"mixY",w);for(let x=0,S=0;;x++){g.setFrame(x,p,y,w,b);const C=f[x+1];if(!C){g.shrink(S);break}const A=L(C,"time",0),v=L(C,"mixRotate",1),M=L(C,"mixX",1),E=L(C,"mixY",M),T=m.curve;T&&(S=Vt(T,g,S,x,0,p,A,y,v,1),S=Vt(T,g,S,x,1,p,A,w,M,1),S=Vt(T,g,S,x,2,p,A,b,E,1)),p=A,y=v,w=M,b=E,m=C}r.push(g)}}}if(t.deform){t.attachments={};for(const h in t.deform){const i=t.deform[h],a=t.attachments[h]={};for(const o in i){const d=i[o],f=a[o]={};for(const m in d)f[m]={deform:d[m]}}}}if(t.attachments)for(const h in t.attachments){const i=t.attachments[h],a=s.findSkin(h);if(a!=null)for(const o in i){const d=i[o],f=s.findSlot(o);if(!f)throw new Error(`Slot not found: ${o}`);const m=f.index;for(const l in d){const g=d[l],p=a.getAttachment(m,l);for(const y in g){const w=g[y];let b=w[0];if(b){if(y=="deform"){const x=p.bones,S=p.vertices,C=x?S.length/3*2:S.length,A=new wg(w.length,w.length,m,p);let v=L(b,"time",0);for(let M=0,E=0;;M++){let T;const R=L(b,"vertices",null);if(!R)T=x?dt.newFloatArray(C):S;else{T=dt.newFloatArray(C);const F=L(b,"offset",0);if(dt.arrayCopy(R,0,T,F,R.length),n!=1)for(let X=F,W=X+R.length;X<W;X++)T[X]*=n;if(!x)for(let X=0;X<C;X++)T[X]+=S[X]}A.setFrame(M,v,T);const k=w[M+1];if(!k){A.shrink(E);break}const I=L(k,"time",0),P=b.curve;P&&(E=Vt(P,A,E,M,0,v,I,0,1,1)),v=I,b=k}r.push(A)}else if(y=="sequence"){const x=new Tg(w.length,m,p);let S=0;for(let C=0;C<w.length;C++){const A=L(b,"delay",S),v=L(b,"time",0),M=_r[L(b,"mode","hold")],E=L(b,"index",0);x.setFrame(C,v,M,E,A),S=A,b=w[C+1]}r.push(x)}}}}}}if(t.drawOrder){const h=new _o(t.drawOrder.length),i=s.slots.length;let a=0;for(let o=0;o<t.drawOrder.length;o++,a++){const d=t.drawOrder[o];let f=null;const m=L(d,"offsets",null);if(m){f=dt.newArray(i,-1);const l=dt.newArray(i-m.length,0);let g=0,p=0;for(let y=0;y<m.length;y++){const w=m[y],b=s.findSlot(w.slot);if(!b)throw new Error(`Slot not found: ${b}`);const x=b.index;for(;g!=x;)l[p++]=g++;f[g+w.offset]=g++}for(;g<i;)l[p++]=g++;for(let y=i-1;y>=0;y--)f[y]==-1&&(f[y]=l[--p])}h.setFrame(a,L(d,"time",0),f)}r.push(h)}if(t.events){const h=new Ad(t.events.length);let i=0;for(let a=0;a<t.events.length;a++,i++){const o=t.events[a],d=s.findEvent(o.name);if(!d)throw new Error(`Event not found: ${o.name}`);const f=new Yg(dt.toSinglePrecision(L(o,"time",0)),d);f.intValue=L(o,"int",d.intValue),f.floatValue=L(o,"float",d.floatValue),f.stringValue=L(o,"string",d.stringValue),f.data.audioPath&&(f.volume=L(o,"volume",1),f.balance=L(o,"balance",0)),h.setFrame(i,f)}r.push(h)}let c=0;for(let h=0,i=r.length;h<i;h++)c=Math.max(c,r[h].getDuration());if(isNaN(c))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new Sd(e,r,c))}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return G.BLEND_MODES.NORMAL;if(t=="additive")return G.BLEND_MODES.ADD;if(t=="multiply")return G.BLEND_MODES.MULTIPLY;if(t=="screen")return G.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}}class Zv{constructor(t,e,s,n,r){Ai(this,"parent"),Ai(this,"skin"),Ai(this,"slotIndex"),Ai(this,"mesh"),Ai(this,"inheritTimeline"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritTimeline=r}}function br(u,t,e,s){let n=u[0],r=L(n,"time",0),c=L(n,"value",e)*s,h=0;for(let i=0;;i++){t.setFrame(i,r,c);const a=u[i+1];if(!a)return t.shrink(h),t;const o=L(a,"time",0),d=L(a,"value",e)*s;n.curve&&(h=Vt(n.curve,t,h,i,0,r,o,c,d,s)),r=o,c=d,n=a}}function kd(u,t,e,s,n,r){let c=u[0],h=L(c,"time",0),i=L(c,e,n)*r,a=L(c,s,n)*r,o=0;for(let d=0;;d++){t.setFrame(d,h,i,a);const f=u[d+1];if(!f)return t.shrink(o),t;const m=L(f,"time",0),l=L(f,e,n)*r,g=L(f,s,n)*r,p=c.curve;p&&(o=Vt(p,t,o,d,0,h,m,i,l,r),o=Vt(p,t,o,d,1,h,m,a,g,r)),h=m,i=l,a=g,c=f}}function Vt(u,t,e,s,n,r,c,h,i,a){if(u=="stepped")return t.setStepped(s),e;const o=n<<2,d=u[o],f=u[o+1]*a,m=u[o+2],l=u[o+3]*a;return t.setBezier(e,s,n,r,h,d,f,m,l,c,i),e+1}function L(u,t,e){return u[t]!==void 0?u[t]:e}class cM extends Qm{createSkeleton(t){this.skeleton=new cv(t),this.skeleton.updateWorldTransform(),this.stateData=new YA(t),this.state=new MA(this.stateData)}}return Rt.AttachmentType=hn,Rt.BinaryInput=AC,Rt.Color=IC,Rt.DebugUtils=PC,Rt.IntSet=EC,Rt.Interpolation=$m,Rt.MathUtils=Ym,Rt.MixBlend=Im,Rt.MixDirection=Rm,Rt.Physics=cd,Rt.Pool=Bm,Rt.PositionMode=Pm,Rt.Pow=_m,Rt.PowOut=RC,Rt.RotateMode=km,Rt.SPINE_VERSION=md,Rt.SkeletonBounds=zv,Rt.SkeletonBoundsBase=Vm,Rt.Spine=CC,Rt.SpineBase=Wm,Rt.SpineDebugRenderer=HC,Rt.SpineMesh=Lm,Rt.SpineSprite=Dm,Rt.StringSet=TC,Rt.TextureAtlas=OC,Rt.TextureAtlasPage=ud,Rt.TextureAtlasRegion=fd,Rt.TextureFilter=bi,Rt.TextureRegion=Tl,Rt.TextureWrap=xi,Rt.TimeKeeper=FC,Rt.TransformMode=Fm,Rt.Utils=hd,Rt.Vector2=kC,Rt.WindowedMean=YC,Rt.detectSpineVersion=Nm,Rt.filterFromString=dd,Rt.settings=gd,Rt.wrapFromString=VC,Rt}({},PIXI,PIXI,PIXI,PIXI,PIXI,PIXI);
//# sourceMappingURL=pixi-spine.js.map
